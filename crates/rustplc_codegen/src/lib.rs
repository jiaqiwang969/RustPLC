pub mod expression;
pub mod state_machine;

use rustplc_ir::{StateMachine, TimingModel, TopologyGraph};
use std::fmt::Write;
use std::path::Path;

#[derive(Debug)]
pub struct CodegenError(pub String);

impl std::fmt::Display for CodegenError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "codegen error: {}", self.0)
    }
}

pub struct CodegenConfig {
    pub cycle_time_ms: u64,
}

impl Default for CodegenConfig {
    fn default() -> Self {
        Self { cycle_time_ms: 50 }
    }
}

/// Generate a complete Cargo project in `output_dir` from verified IR.
pub fn generate_project(
    state_machine: &StateMachine,
    _topology: &TopologyGraph,
    _timing_model: &TimingModel,
    config: &CodegenConfig,
    output_dir: &Path,
) -> Result<(), CodegenError> {
    std::fs::create_dir_all(output_dir.join("src"))
        .map_err(|e| CodegenError(format!("cannot create output dir: {e}")))?;

    let main_rs = generate_main_source(state_machine, config);

    std::fs::write(output_dir.join("src/main.rs"), &main_rs)
        .map_err(|e| CodegenError(format!("cannot write main.rs: {e}")))?;

    let cargo_toml = generate_cargo_toml();
    std::fs::write(output_dir.join("Cargo.toml"), &cargo_toml)
        .map_err(|e| CodegenError(format!("cannot write Cargo.toml: {e}")))?;

    Ok(())
}

/// Generate the Rust source code as a String (for testing without filesystem).
pub fn generate_main_source(state_machine: &StateMachine, config: &CodegenConfig) -> String {
    let mut out = String::with_capacity(4096);

    writeln!(out, "// AUTO-GENERATED by RustPLC codegen â€” do not edit").unwrap();
    writeln!(out, "use rustplc_hal::traits::HalBackend;").unwrap();
    writeln!(out, "use rustplc_hal::sim::SimBackend;").unwrap();
    writeln!(out, "use rustplc_runtime::engine::ScanCycleEngine;").unwrap();
    writeln!(out, "use rustplc_runtime::timer::TimerBank;").unwrap();
    writeln!(out).unwrap();

    state_machine::emit_state_enum(&mut out, state_machine);
    writeln!(out).unwrap();
    state_machine::emit_scan_cycle_fn(&mut out, state_machine);
    writeln!(out).unwrap();
    emit_main_fn(&mut out, config);

    out
}

fn emit_main_fn(out: &mut String, config: &CodegenConfig) {
    writeln!(out, "fn main() {{").unwrap();
    writeln!(out, "    let hal = SimBackend::new();").unwrap();
    writeln!(
        out,
        "    let mut engine = ScanCycleEngine::new(hal, PlcState::initial(), {}, scan_cycle);",
        config.cycle_time_ms
    )
    .unwrap();
    writeln!(out, "    engine.run_realtime();").unwrap();
    writeln!(out, "}}").unwrap();
}

fn generate_cargo_toml() -> String {
    r#"[package]
name = "plc_runtime"
version = "0.1.0"
edition = "2024"

[dependencies]
rustplc_hal = { path = "../../crates/rustplc_hal" }
rustplc_runtime = { path = "../../crates/rustplc_runtime" }
log = "0.4"
env_logger = "0.11"
"#
    .to_string()
}
