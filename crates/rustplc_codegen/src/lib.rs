pub mod expression;
pub mod state_machine;

use rustplc_ir::{
    StateMachine, TimingModel, TopologyGraph, TransitionAction, TransitionGuard,
};
use std::collections::BTreeSet;
use std::fmt::Write;
use std::path::Path;

#[derive(Debug)]
pub struct CodegenError(pub String);

impl std::fmt::Display for CodegenError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "codegen error: {}", self.0)
    }
}

pub struct CodegenConfig {
    pub cycle_time_ms: u64,
}

impl Default for CodegenConfig {
    fn default() -> Self {
        Self { cycle_time_ms: 50 }
    }
}

/// Generate a complete Cargo project in `output_dir` from verified IR.
///
/// `crates_root` is the directory containing the workspace crates (e.g. `<project>/crates`).
/// If `None`, dependency paths default to `../crates/` (output one level below project root).
pub fn generate_project(
    state_machine: &StateMachine,
    _topology: &TopologyGraph,
    _timing_model: &TimingModel,
    config: &CodegenConfig,
    output_dir: &Path,
) -> Result<(), CodegenError> {
    std::fs::create_dir_all(output_dir.join("src"))
        .map_err(|e| CodegenError(format!("cannot create output dir: {e}")))?;

    let main_rs = generate_main_source(state_machine, config);

    std::fs::write(output_dir.join("src/main.rs"), &main_rs)
        .map_err(|e| CodegenError(format!("cannot write main.rs: {e}")))?;

    // Compute relative path from output_dir to the workspace crates/ directory.
    let crates_rel = compute_crates_rel_path(output_dir);
    let cargo_toml = generate_cargo_toml(&crates_rel);
    std::fs::write(output_dir.join("Cargo.toml"), &cargo_toml)
        .map_err(|e| CodegenError(format!("cannot write Cargo.toml: {e}")))?;

    Ok(())
}

/// Compute the relative path from `output_dir` to the sibling `crates/` directory.
///
/// Strategy: canonicalize `output_dir`, walk up looking for a parent that contains `crates/`,
/// then build the relative `../` prefix. Falls back to `../crates` if detection fails.
fn compute_crates_rel_path(output_dir: &Path) -> String {
    // Try to canonicalize; if output_dir doesn't exist yet, use its parent
    let abs = output_dir
        .canonicalize()
        .or_else(|_| {
            output_dir
                .parent()
                .unwrap_or(Path::new("."))
                .canonicalize()
                .map(|p| p.join(output_dir.file_name().unwrap_or_default()))
        })
        .unwrap_or_else(|_| output_dir.to_path_buf());

    // Walk up from output_dir looking for a parent that has a `crates` subdirectory
    let mut current = abs.as_path();
    let mut depth: usize = 0;
    loop {
        if let Some(parent) = current.parent() {
            depth += 1;
            if parent.join("crates").is_dir() {
                let prefix = "../".repeat(depth);
                return format!("{prefix}crates");
            }
            current = parent;
        } else {
            break;
        }
    }

    // Fallback: assume one level below project root
    "../crates".to_string()
}

/// Extract all device names referenced in the state machine.
/// Returns (outputs, inputs) as sorted sets.
fn extract_device_names(sm: &StateMachine) -> (BTreeSet<String>, BTreeSet<String>) {
    let mut outputs = BTreeSet::new();
    let mut inputs = BTreeSet::new();

    for t in &sm.transitions {
        for action in &t.actions {
            match action {
                TransitionAction::Extend { target }
                | TransitionAction::Retract { target }
                | TransitionAction::Set { target, .. } => {
                    outputs.insert(target.clone());
                }
                TransitionAction::Log { .. } => {}
            }
        }
        if let TransitionGuard::Condition { expression } = &t.guard {
            // Extract device name from expressions like "sensor_A == true"
            if let Some(dev) = expression.split_whitespace().next() {
                inputs.insert(dev.to_string());
            }
        }
    }

    (outputs, inputs)
}

/// Generate the Rust source code as a String (for testing without filesystem).
pub fn generate_main_source(state_machine: &StateMachine, _config: &CodegenConfig) -> String {
    let mut out = String::with_capacity(4096);

    let (outputs, inputs) = extract_device_names(state_machine);

    writeln!(out, "// AUTO-GENERATED by RustPLC codegen â€” do not edit").unwrap();
    writeln!(out, "// Required devices (configure in hal_config.toml [mapping]):").unwrap();
    if !outputs.is_empty() {
        let names: Vec<&str> = outputs.iter().map(|s| s.as_str()).collect();
        writeln!(out, "//   Outputs (coils): {}", names.join(", ")).unwrap();
    }
    if !inputs.is_empty() {
        let names: Vec<&str> = inputs.iter().map(|s| s.as_str()).collect();
        writeln!(out, "//   Inputs (discrete_inputs): {}", names.join(", ")).unwrap();
    }
    writeln!(out, "use rustplc_hal::traits::HalBackend;").unwrap();
    writeln!(out, "use rustplc_orchestrator::{{OrchestratorConfig, create_backend}};").unwrap();
    writeln!(out, "use rustplc_runtime::engine::ScanCycleEngine;").unwrap();
    writeln!(out, "use rustplc_runtime::timer::TimerBank;").unwrap();
    writeln!(out).unwrap();

    state_machine::emit_state_enum(&mut out, state_machine);
    writeln!(out).unwrap();
    state_machine::emit_scan_cycle_fn(&mut out, state_machine);
    writeln!(out).unwrap();
    emit_main_fn(&mut out);

    out
}

fn emit_main_fn(out: &mut String) {
    writeln!(out, "fn main() {{").unwrap();
    writeln!(out, "    env_logger::init();").unwrap();
    writeln!(out, "    let config_path = std::env::args().nth(1).unwrap_or_else(|| \"hal_config.toml\".into());").unwrap();
    writeln!(out, "    let config = OrchestratorConfig::from_file(&config_path)").unwrap();
    writeln!(out, "        .expect(\"failed to load HAL config\");").unwrap();
    writeln!(out, "    let hal = create_backend(&config)").unwrap();
    writeln!(out, "        .expect(\"failed to create HAL backend\");").unwrap();
    writeln!(out, "    let cycle_time = config.runtime.cycle_time_ms;").unwrap();
    writeln!(out, "    let mut engine = ScanCycleEngine::new(hal, PlcState::initial(), cycle_time, scan_cycle);").unwrap();
    writeln!(out, "    engine.run_realtime();").unwrap();
    writeln!(out, "}}").unwrap();
}

fn generate_cargo_toml(crates_rel: &str) -> String {
    format!(
        r#"[package]
name = "plc_runtime"
version = "0.1.0"
edition = "2024"

[workspace]

[dependencies]
rustplc_hal = {{ path = "{crates_rel}/rustplc_hal" }}
rustplc_runtime = {{ path = "{crates_rel}/rustplc_runtime" }}
rustplc_orchestrator = {{ path = "{crates_rel}/rustplc_orchestrator" }}
log = "0.4"
env_logger = "0.11"
"#
    )
}
