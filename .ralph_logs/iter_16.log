OpenAI Codex v0.98.0 (research preview)
--------
workdir: /mnt/e/personal_project/rust_plc
model: gpt-5.3-codex
provider: codex
approval: never
sandbox: danger-full-access
reasoning effort: high
reasoning summaries: auto
session id: 019c4aed-d346-72a1-8b92-cbf59d980765
--------
user
# Ralph Agent Instructions

You are an autonomous coding agent working on a software project.

## Your Task

1. Read the PRD at `prd.json` (in the same directory as this file)
2. Read the progress log at `progress.txt` (check Codebase Patterns section first)
3. Check you're on the correct branch from PRD `branchName`. If not, check it out or create from main.
4. Pick the **highest priority** user story where `passes: false`
5. Implement that single user story
6. Run quality checks (e.g., typecheck, lint, test - use whatever your project requires)
7. Update AGENTS.md files if you discover reusable patterns (see below)
8. If checks pass, commit ALL changes with message: `feat: [Story ID] - [Story Title]`
9. Update the PRD to set `passes: true` for the completed story
10. Append your progress to `progress.txt`

## Progress Report Format

APPEND to progress.txt (never replace, always append):
```
## [Date/Time] - [Story ID]
Thread: https://ampcode.com/threads/$AMP_CURRENT_THREAD_ID
- What was implemented
- Files changed
- **Learnings for future iterations:**
  - Patterns discovered (e.g., "this codebase uses X for Y")
  - Gotchas encountered (e.g., "don't forget to update Z when changing W")
  - Useful context (e.g., "the evaluation panel is in component X")
---
```

Include the thread URL so future iterations can use the `read_thread` tool to reference previous work if needed.

The learnings section is critical - it helps future iterations avoid repeating mistakes and understand the codebase better.

## Consolidate Patterns

If you discover a **reusable pattern** that future iterations should know, add it to the `## Codebase Patterns` section at the TOP of progress.txt (create it if it doesn't exist). This section should consolidate the most important learnings:

```
## Codebase Patterns
- Example: Use `sql<number>` template for aggregations
- Example: Always use `IF NOT EXISTS` for migrations
- Example: Export types from actions.ts for UI components
```

Only add patterns that are **general and reusable**, not story-specific details.

## Update AGENTS.md Files

Before committing, check if any edited files have learnings worth preserving in nearby AGENTS.md files:

1. **Identify directories with edited files** - Look at which directories you modified
2. **Check for existing AGENTS.md** - Look for AGENTS.md in those directories or parent directories
3. **Add valuable learnings** - If you discovered something future developers/agents should know:
   - API patterns or conventions specific to that module
   - Gotchas or non-obvious requirements
   - Dependencies between files
   - Testing approaches for that area
   - Configuration or environment requirements

**Examples of good AGENTS.md additions:**
- "When modifying X, also update Y to keep them in sync"
- "This module uses pattern Z for all API calls"
- "Tests require the dev server running on PORT 3000"
- "Field names must match the template exactly"

**Do NOT add:**
- Story-specific implementation details
- Temporary debugging notes
- Information already in progress.txt

Only update AGENTS.md if you have **genuinely reusable knowledge** that would help future work in that directory.

## Quality Requirements

- ALL commits must pass your project's quality checks (typecheck, lint, test)
- Do NOT commit broken code
- Keep changes focused and minimal
- Follow existing code patterns

## Browser Testing (Required for Frontend Stories)

For any story that changes UI, you MUST verify it works in the browser:

1. Load the `dev-browser` skill
2. Navigate to the relevant page
3. Verify the UI changes work as expected
4. Take a screenshot if helpful for the progress log

A frontend story is NOT complete until browser verification passes.

## Stop Condition

After completing a user story, check if ALL stories have `passes: true`.

If ALL stories are complete and passing, reply with:
<promise>COMPLETE</promise>

If there are still stories with `passes: false`, end your response normally (another iteration will pick up the next story).

## Important

- Work on ONE story per iteration
- Commit frequently
- Keep CI green
- Read the Codebase Patterns section in progress.txt before starting

mcp startup: no servers

thinking
**Reviewing agent instructions**
exec
/bin/bash -lc "bash -lc 'ls -la'" in /mnt/e/personal_project/rust_plc succeeded in 51ms:
total 116
drwxrwxrwx 1 liangyuhang liangyuhang  4096 Feb 11 10:12 .
drwxrwxrwx 1 liangyuhang liangyuhang  4096 Feb 10 20:47 ..
drwxrwxrwx 1 liangyuhang liangyuhang  4096 Feb 11 00:34 .claude
drwxrwxrwx 1 liangyuhang liangyuhang  4096 Feb 11 01:09 .codex
drwxrwxrwx 1 liangyuhang liangyuhang  4096 Feb 11 12:19 .git
-rwxrwxrwx 1 liangyuhang liangyuhang     8 Feb 11 01:17 .gitignore
drwxrwxrwx 1 liangyuhang liangyuhang  4096 Feb 11 12:20 .ralph_logs
-rwxrwxrwx 1 liangyuhang liangyuhang  4307 Feb 11 01:14 CODEX.md
-rwxrwxrwx 1 liangyuhang liangyuhang  7674 Feb 11 09:01 Cargo.lock
-rwxrwxrwx 1 liangyuhang liangyuhang   249 Feb 11 09:00 Cargo.toml
drwxrwxrwx 1 liangyuhang liangyuhang  4096 Feb 11 10:11 examples
-rwxrwxrwx 1 liangyuhang liangyuhang 18674 Feb 11 12:17 prd.json
-rwxrwxrwx 1 liangyuhang liangyuhang 38276 Feb 11 00:28 prd.md
-rwxrwxrwx 1 liangyuhang liangyuhang 25681 Feb 11 12:17 progress.txt
-rwxrwxrwx 1 liangyuhang liangyuhang  4307 Jan 23 10:30 prompt.md
-rwxrwxrwx 1 liangyuhang liangyuhang  3816 Feb 11 01:14 ralph.sh
drwxrwxrwx 1 liangyuhang liangyuhang  4096 Feb 11 11:55 src
drwxrwxrwx 1 liangyuhang liangyuhang  4096 Feb 11 10:12 target
drwxrwxrwx 1 liangyuhang liangyuhang  4096 Feb 11 10:12 tests

thinking
**Searching for agent instructions**
exec
/bin/bash -lc "bash -lc 'rg --files -g \"AGENTS.md\"'" in /mnt/e/personal_project/rust_plc exited 1 in 51ms:


thinking
**Identifying key config files**
exec
/bin/bash -lc "bash -lc 'sed -n \"1,220p\" progress.txt'" in /mnt/e/personal_project/rust_plc succeeded in 50ms:
# Ralph Progress Log
## Codebase Patterns
- For timing envelopes, include upstream `response_time` along `connected_to` chains and treat incoming `StateMachine` guards as must_start_after lower bounds (`timeout` contributes delay, `always/condition` = 0ms).
- TopologyGraph JSON 调试依赖 `petgraph` 的 `serde-1` feature；若缺失会导致 DiGraph 无法序列化。
- In parser-to-AST lowering, unwrap wrapper PEG rules (e.g., `constraint_declaration`, `step_statement`) before matching concrete rule kinds, or valid nodes can be silently skipped.
- Keep public module declarations centralized in `src/lib.rs`; implementation files live at `src/<module>/mod.rs`.
- For early story scaffolding, keep module placeholders compiling so CLI and library can evolve incrementally without breaking builds.
- Model DSL enums with `serde(rename_all = "snake_case")` and tagged enums so serialized AST tokens stay aligned with DSL keywords.
- In pest grammars, define silent `WHITESPACE` and `COMMENT` rules so inline `#` comments and multiline section formatting parse without extra boilerplate.
- For block-style DSL sections, parse optional `reason: "..."` clauses directly in each declaration rule so indented multiline annotations remain valid without separate line handling.
- In nested `parallel`/`race` grammar, require branch bodies to consume concrete statements so step-level directives are not misparsed as branch labels.
- In semantic topology lowering, treat `connected_to` as upstream linkage (`target -> current`) so causality traversals follow physical flow direction.
- Preserve directive line metadata in AST (e.g., `GotoDirective.line`, `TaskDeclaration.on_complete_line`) so semantic passes can report precise line-numbered errors without reparsing source text.
- For constraint semantic validation, seed known device states from device-type defaults plus `sensor.detects` references before checking `safety` state expressions.
- Use `PlcError` constructors (`undefined_reference` / `type_mismatch` / `duplicate_definition`) so diagnostics share unified ERROR blocks with `位置/原因/建议` fields.
- For end-to-end compilation paths (CLI/tests), run all four semantic builders and aggregate their errors so users get complete diagnostics in one run.
- For causality verification, augment TopologyGraph with logical edges from `detects.device -> sensor` before running reachability, otherwise output-to-sensor chains may appear disconnected.
Started: Wed Feb 11 01:14:39 CST 2026
---
## [2026-02-11 01:19:50 CST] - US-001

thinking
**Inspecting branch and story order**
exec
/bin/bash -lc "bash -lc 'git status --short --branch'" in /mnt/e/personal_project/rust_plc succeeded in 180ms:
## ralph/phase1-2-parser-and-verification
 M .ralph_logs/iter_15.log
?? .ralph_logs/iter_16.log

thinking
**Checking presence of config fields**
exec
/bin/bash -lc "bash -lc 'jq \".branchName, .userStories[] | {id, title, priority, passes}\" prd.json'" in /mnt/e/personal_project/rust_plc exited 127 in 51ms:
bash: line 1: jq: command not found

thinking
**Switching to Python JSON parsing**
exec
/bin/bash -lc "bash -lc 'python3 - <<\"PY\"
import json
with open(\"prd.json\") as f:
    d=json.load(f)
print(\"branchName:\", d.get(\"branchName\"))
for us in d.get(\"userStories\",[]):
    print(us.get(\"id\"), us.get(\"title\"), \"priority\", us.get(\"priority\"), \"passes\", us.get(\"passes\"))
PY'" in /mnt/e/personal_project/rust_plc succeeded in 50ms:
branchName: ralph/phase1-2-parser-and-verification
US-001 初始化 Rust 项目与依赖 priority 1 passes True
US-002 定义 AST 数据结构 priority 2 passes True
US-003 编写 topology 段的 PEG 语法 priority 3 passes True
US-004 编写 constraints 段的 PEG 语法 priority 4 passes True
US-005 编写 tasks 段的 PEG 语法 priority 5 passes True
US-006 实现 AST 构建器（解析树转 AST） priority 6 passes True
US-007 定义 IR 数据结构 priority 7 passes True
US-008 实现语义分析：AST 转 TopologyGraph priority 8 passes True
US-009 实现语义分析：AST 转 StateMachine priority 9 passes True
US-010 实现语义分析：AST 转 ConstraintSet 和 TimingModel priority 10 passes True
US-011 实现错误报告系统 priority 11 passes True
US-012 创建示例 .plc 文件和集成测试 priority 12 passes True
US-013 实现因果链检查器（Causality Checker） priority 13 passes True
US-014 实现时序检查器（Timing Checker） priority 14 passes True
US-015 实现活性检查器（Liveness Checker） priority 15 passes False
US-016 实现安全性检查器（Safety Checker + Z3） priority 16 passes False
US-017 集成所有验证并进行端到端测试 priority 17 passes False

thinking
**Preparing story implementation**
exec
/bin/bash -lc "bash -lc 'python3 - <<\"PY\"
import json, pprint
with open(\"prd.json\") as f:
    d=json.load(f)
for us in d[\"userStories\"]:
    if us[\"id\"]==\"US-015\":
        pprint.pp(us)
        break
PY'" in /mnt/e/personal_project/rust_plc succeeded in 50ms:
{'id': 'US-015',
 'title': '实现活性检查器（Liveness Checker）',
 'description': '作为开发者，我需要活性验证，检测状态机中的潜在死锁。',
 'acceptanceCriteria': ['src/verification/liveness.rs 实现死锁检测',
                        '检查所有 wait 语句是否有 timeout 或 allow_indefinite_wait',
                        '检查非终态状态是否有零出边',
                        'on_complete: goto 形成的循环（如 ready -> init -> '
                        'ready）是合法的，不算死锁',
                        'on_complete: unreachable 的 task 仅在所有内部路径以 goto '
                        '结尾时有效；若存在可到达 on_complete 的路径则报错',
                        '检查是否存在不包含 allow_indefinite_wait 或 timeout 出边的强连通分量',
                        '失败时：报告位置、原因、物理分析和修复建议（匹配 PRD 3.2.2 节错误格式）',
                        '错误信息为中文，包含行号',
                        '单元测试：验证 PRD 5.5.1-5.5.3 节示例（有 timeout 和 '
                        'allow_indefinite_wait）活性通过',
                        '单元测试：验证 wait 无 timeout 且无 allow_indefinite_wait 时活性失败',
                        '类型检查通过'],
 'priority': 15,
 'passes': False,
 'notes': ''}

thinking
**Inspecting verification module**
exec
/bin/bash -lc "bash -lc 'rg --files src'" in /mnt/e/personal_project/rust_plc succeeded in 51ms:
src/main.rs
src/lib.rs
src/error/mod.rs
src/ir/mod.rs
src/semantic/mod.rs
src/parser/mod.rs
src/parser/plc.pest
src/ast/mod.rs
src/verification/mod.rs
src/verification/causality.rs
src/verification/timing.rs

thinking
**Locating state machine structures**
exec
/bin/bash -lc "bash -lc 'sed -n \"1,260p\" src/verification/mod.rs'" in /mnt/e/personal_project/rust_plc succeeded in 51ms:
pub mod causality;
pub mod timing;

thinking
**Assessing test presence and timing**
exec
/bin/bash -lc "bash -lc 'sed -n \"1,320p\" src/verification/causality.rs'" in /mnt/e/personal_project/rust_plc succeeded in 51ms:
use crate::ast::{
    ActionStatement, BinaryValue, ComparisonOperator, LiteralValue, PlcProgram, StepStatement,
    WaitStatement,
};
use crate::ir::{ConstraintSet, DeviceKind, TopologyGraph};
use petgraph::algo::has_path_connecting;
use petgraph::graph::{DiGraph, NodeIndex};
use petgraph::visit::EdgeRef;
use std::collections::{HashMap, HashSet, VecDeque};
use std::fmt;

#[derive(Debug, Clone, PartialEq, Eq)]
pub struct CausalityDiagnostic {
    pub line: usize,
    pub action: Option<String>,
    pub wait: Option<String>,
    pub broken_link: String,
    pub expected_chain: String,
    pub actual_chain: String,
    pub suggestion: String,
exec
/bin/bash -lc "bash -lc 'sed -n \"320,680p\" src/verification/causality.rs'" in /mnt/e/personal_project/rust_plc succeeded in 51ms:
    }

    for (action_text, action_target) in &actions {
        for (wait_text, wait_sensor) in &waits {
            pairs.push(ActionWaitPair {
                line,
                action: action_text.clone(),
                action_target: action_target.clone(),
                wait: wait_text.clone(),
                wait_sensor: wait_sensor.clone(),
            });
        }
    }
}

fn action_to_text_and_target(action: &ActionStatement) -> Option<(String, String)> {
    match action {
        ActionStatement::Extend { target } => Some((format!("extend {target}"), target.clone())),
        ActionStatement::Retract { target } => Some((format!("retract {target}"), target.clone())),
        ActionStatement::Set { target, value } => Some((
exec
/bin/bash -lc "bash -lc 'sed -n \"680,980p\" src/verification/causality.rs'" in /mnt/e/personal_project/rust_plc succeeded in 51ms:
        let topology = build_topology_graph(&program).expect("拓扑应能构建");
        let constraints = build_constraint_set(&program).expect("约束应能构建");

        let errors = verify_causality(&program, &topology, &constraints)
            .expect_err("缺失 valve_A -> cyl_A 链路时应报错");

        assert!(
            errors
                .iter()
                .any(|error| error.to_string().contains("ERROR [causality] 因果链断裂")),
            "错误应包含因果链断裂标题"
        );
        assert!(
            errors
                .iter()
                .any(|error| error.to_string().contains("断裂链路: valve_A -> cyl_A")),
            "错误应指出断裂的链路"
        );
        assert!(
            errors

thinking
**Timing module started**
exec
/bin/bash -lc "bash -lc 'sed -n \"1,420p\" src/verification/timing.rs'" in /mnt/e/personal_project/rust_plc succeeded in 51ms:
use crate::ast::{ActionStatement, PlcProgram, StepStatement};
use crate::ir::{
    ConstraintSet, StateMachine, TimingRelation, TimingScope, TopologyGraph, TransitionGuard,
};
use petgraph::visit::EdgeRef;
use std::collections::{HashMap, HashSet};
use std::fmt;

#[derive(Debug, Clone, PartialEq, Eq)]
pub struct TimingDiagnostic {
    pub line: usize,
    pub constraint: String,
    pub analysis: String,
    pub conclusion: String,
}

impl fmt::Display for TimingDiagnostic {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        writeln!(f, "ERROR [timing] 时序包络违反")?;
        writeln!(f, "  位置: <input>:{}:1", self.line)?;

thinking
**Planning partial file extraction**
exec
/bin/bash -lc "bash -lc 'sed -n \"420,860p\" src/verification/timing.rs'" in /mnt/e/personal_project/rust_plc succeeded in 51ms:

    timeout_max_ms
}

fn step_key(task: &str, step: &str) -> String {
    format!("{task}.{step}")
}

fn format_timing_constraint(rule: &crate::ir::TimingRule) -> String {
    format!(
        "{} {} {}ms",
        format_scope(&rule.scope),
        format_relation(&rule.relation),
        rule.duration_ms
    )
}

fn format_scope(scope: &TimingScope) -> String {
    match scope {
        TimingScope::Task { task } => format!("task.{task}"),

thinking
**Examining IR for state details**
exec
/bin/bash -lc "bash -lc 'sed -n \"1,380p\" src/ir/mod.rs'" in /mnt/e/personal_project/rust_plc succeeded in 50ms:
use petgraph::graph::{DiGraph, NodeIndex};
use serde::{Deserialize, Serialize};
use std::collections::BTreeMap;

#[derive(Debug, Clone, Serialize, Deserialize, PartialEq)]
pub struct Device {
    pub name: String,
    pub kind: DeviceKind,
}

#[derive(Debug, Clone, Serialize, Deserialize, PartialEq)]
#[serde(rename_all = "snake_case")]
pub enum DeviceKind {
    DigitalOutput,
    DigitalInput,
    SolenoidValve,
    Cylinder,
    Sensor,
    Motor,
}

thinking
**Inspecting semantic state machine**
exec
/bin/bash -lc "bash -lc 'rg -n \"build_state_machine|on_complete|allow_indefinite_wait|unreachable|goto|TransitionGuard|timeout|StepStatement::Wait\" src/semantic/mod.rs'" in /mnt/e/personal_project/rust_plc succeeded in 51ms:
14:    Transition, TransitionAction, TransitionGuard,
29:pub fn build_state_machine(program: &PlcProgram) -> Result<StateMachine, Vec<PlcError>> {
30:    build_state_machine_from_ast(&program.tasks)
222:pub fn build_state_machine_from_ast(tasks: &TasksSection) -> Result<StateMachine, Vec<PlcError>> {
274:    let mut task_on_complete_targets = HashMap::<String, Option<State>>::new();
276:        let on_complete_target = match &task.on_complete {
278:                let line = task.on_complete_line.unwrap_or(task.line);
279:                resolve_task_target(step, line, &task_initial_states, &mut errors, "on_complete")
283:        task_on_complete_targets.insert(task.name.clone(), on_complete_target);
293:                completion_target_for_step(task, step_index, &task_on_complete_targets);
327:            for goto in &analyzed.gotos {
329:                    &goto.step,
330:                    goto.line,
333:                    "goto",
338:                        TransitionGuard::Always,
345:            for (timeout_index, timeout) in analyzed.timeouts.iter().enumerate() {
347:                    &timeout.target.step,
348:                    timeout.target.line,
351:                    "timeout -> goto",
353:                    let duration_ms = duration_to_ms(timeout);

thinking
**Inspecting build state machine**
exec
/bin/bash -lc "bash -lc 'sed -n \"220,520p\" src/semantic/mod.rs'" in /mnt/e/personal_project/rust_plc succeeded in 51ms:
}

pub fn build_state_machine_from_ast(tasks: &TasksSection) -> Result<StateMachine, Vec<PlcError>> {
    let mut builder = StateMachineBuilder::default();
    let mut errors = Vec::new();

    if tasks.tasks.is_empty() {
        errors.push(PlcError::semantic(1, "[tasks] 段至少需要一个 task"));
        return Err(errors);
    }

    let mut task_initial_states = HashMap::<String, State>::new();

    for task in &tasks.tasks {
        if task.steps.is_empty() {
            errors.push(PlcError::semantic(
                task.line,
                format!("task {} 至少需要一个 step", task.name),
            ));
            continue;

thinking
**Extending analysis of statement liveness**
exec
/bin/bash -lc "bash -lc 'sed -n \"760,1240p\" src/semantic/mod.rs'" in /mnt/e/personal_project/rust_plc succeeded in 51ms:
    })
}

fn insert_action_timing(intervals: &mut BTreeMap<String, ActionTiming>, timing: ActionTiming) {
    let action_name = action_kind_name(&timing.action.action_kind);
    let target = timing.action.target.as_deref().unwrap_or("_");
    let base_key = format!(
        "{}.{}.{}.{}",
        timing.action.task_name, timing.action.step_name, action_name, target
    );

    if !intervals.contains_key(&base_key) {
        intervals.insert(base_key, timing);
        return;
    }

    let mut duplicate_index = 2usize;
    loop {
        let key = format!("{base_key}.{duplicate_index}");
        if !intervals.contains_key(&key) {

thinking
**Planning AST inspection for build edges**
exec
/bin/bash -lc "bash -lc 'sed -n \"1,420p\" src/ast/mod.rs'" in /mnt/e/personal_project/rust_plc succeeded in 51ms:
use serde::{Deserialize, Serialize};

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct PlcProgram {
    pub topology: TopologySection,
    pub constraints: ConstraintsSection,
    pub tasks: TasksSection,
}

#[derive(Debug, Clone, Serialize, Deserialize, Default)]
pub struct TopologySection {
    pub devices: Vec<DeviceDeclaration>,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct DeviceDeclaration {
    #[serde(default)]
    pub line: usize,
    pub name: String,
    pub device_type: DeviceType,

thinking
**Assessing liveness verification approach**
exec
/bin/bash -lc "bash -lc 'sed -n \"1,320p\" src/main.rs'" in /mnt/e/personal_project/rust_plc succeeded in 51ms:
use rust_plc::error::PlcError;
use rust_plc::ir::{ConstraintSet, StateMachine, TimingModel, TopologyGraph};
use rust_plc::parser::parse_plc;
use rust_plc::semantic::{
    build_constraint_set, build_state_machine, build_timing_model, build_topology_graph,
};
use serde::Serialize;
use std::env;
use std::fs;
use std::path::Path;

#[derive(Debug, Serialize)]
struct IrBundle {
    topology: TopologyGraph,
    state_machine: StateMachine,
    constraints: ConstraintSet,
    timing_model: TimingModel,
}

fn main() {

thinking
**Checking library exports**
exec
/bin/bash -lc "bash -lc 'sed -n \"1,220p\" src/lib.rs'" in /mnt/e/personal_project/rust_plc succeeded in 51ms:
pub mod ast;
pub mod error;
pub mod ir;
pub mod parser;
pub mod semantic;
pub mod verification;

thinking
**Running existing tests baseline**
exec
/bin/bash -lc "bash -lc 'cargo test -q'" in /mnt/e/personal_project/rust_plc succeeded in 1.36s:

running 30 tests
..............................
test result: ok. 30 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.01s


running 0 tests

test result: ok. 0 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s


running 4 tests
....
test result: ok. 4 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.02s


running 0 tests

test result: ok. 0 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s


thinking
**Planning PRD inspection**
exec
/bin/bash -lc "bash -lc 'rg -n \"5\\.5|3\\.2\\.2|活性|deadlock|allow_indefinite_wait|unreachable|on_complete\" prd.md'" in /mnt/e/personal_project/rust_plc succeeded in 51ms:
13:用 Rust 替代传统 PLC 编程语言（梯形图/ST/FBD），建立一套 **"程序即结构"** 的工业控制系统。用户用极简的领域专用语言（DSL）描述物理拓扑、控制逻辑和安全约束，系统在编译期自动完成形式化验证（安全性、活性、时序、因果链），验证通过后生成确定性 Rust 执行代码。
82:#### 3.2.2 活性保障（Liveness）
93:- 检查是否存在无出边的非终态节点（注意：常驻循环中的 task 通过 on_complete: goto 形成闭环，这是合法的，不算死锁）
94:- 标记为 `on_complete: unreachable` 的 task 视为"所有出边均为内部跳转的已封闭节点"，不算无出边的非终态（前提：该 task 内所有执行路径都以 goto 或 timeout->goto 结尾，编译器会验证这一前提，若存在未跳转的路径则报错）
95:- 标记为 `allow_indefinite_wait: true` 的 wait 语句豁免 timeout 检查（典型用途：等待人工按下启动按钮）
97:- 检查是否存在不包含 `allow_indefinite_wait` 或 `timeout` 出边的强连通分量（即：一组状态互相可达但全都没有超时出口，意味着一旦进入就可能永远出不来）
419:### 5.5 控制逻辑 [tasks]
421:#### 5.5.0 执行语义规则
455:#### 5.5.1 基本顺序执行
481:    on_complete: goto ready
484:#### 5.5.2 等待与跳转
490:        allow_indefinite_wait: true     # 显式允许无限等待
491:    on_complete: goto main_cycle
494:#### 5.5.3 故障处理
504:    on_complete: goto ready
507:#### 5.5.4 并行执行
523:    on_complete: goto next_task
528:#### 5.5.5 竞争分支
545:    on_complete: unreachable          # race 必定跳转，不会走到这里
548:#### 5.5.6 流程控制关键词汇总

thinking
**Preparing to extract test examples**
exec
/bin/bash -lc "bash -lc 'sed -n \"70,120p\" prd.md'" in /mnt/e/personal_project/rust_plc succeeded in 51ms:

```
ERROR [safety] 状态互斥违反
  约束: cyl_A.extended conflicts_with cyl_B.extended (main.plc:12)
  违反路径:
    1. init -> step_1 (extend cyl_A)
    2. step_1 中 sensor_A_ext 超时 -> error_recovery
    3. error_recovery 未等待 cyl_A 缩回 -> step_3 (extend cyl_B)
    4. 此时 cyl_A 可能仍处于 extended 状态  <-- 冲突
  建议: 在 error_recovery 中添加 retract cyl_A 并等待 sensor_A_ret
```

#### 3.2.2 活性保障（Liveness）

**目标**：证明程序绝不会死锁——每个非人工等待的状态都有出路。注意：工控程序通常是常驻循环运行的（如 ready -> work -> ready -> ...），Liveness 不要求程序"最终终止"，而是要求"不会卡死在某个中间状态"。

**场景示例**：
- 用户写了 `wait: sensor_A == true` 但没写 timeout
- 如果 sensor_A 物理损坏永远为 false，程序将永远卡在此处
- 编译器检测到无超时的等待，报错

thinking
**Planning wait examples**
exec
/bin/bash -lc "bash -lc 'sed -n \"430,560p\" prd.md'" in /mnt/e/personal_project/rust_plc succeeded in 51ms:

示例：

```plc
# 这两条 action 在同一周期同时执行（并行）
step safe_position:
    action: retract cyl_A        # 同时发出
    action: retract cyl_B        # 同时发出
    # 时间 = max(cyl_A.retract_time, cyl_B.retract_time)，不是两者之和
```

如果需要**串行执行**（先做 A 再做 B），必须拆成多个 step：

```plc
# 这两条 action 串行执行
step retract_A_first:
    action: retract cyl_A
    wait: sensor_A_ret == true
    timeout: 500ms -> goto fault_handler
step retract_B_second:

thinking
**Analyzing test coverage and line metadata**
exec
/bin/bash -lc "bash -lc 'rg -n \"allow_indefinite|on_complete|unreachable|line\" src/parser/mod.rs'" in /mnt/e/personal_project/rust_plc succeeded in 51ms:
73:    let line = line_of(&pair);
88:        line,
89:        name: name.ok_or_else(|| PlcError::parse(line, "device 声明缺少名称"))?,
90:        device_type: device_type.ok_or_else(|| PlcError::parse(line, "device 声明缺少类型"))?,
96:    let line = line_of(&pair);
104:        other => Err(PlcError::parse(line, format!("未知设备类型: {other}"))),
121:    let line = line_of(&pair);
126:        .ok_or_else(|| PlcError::parse(line, "属性缺少名称"))?
131:        .ok_or_else(|| PlcError::parse(line, format!("属性 {attr_name} 缺少值")))?;
132:    let value = first_inner(value_wrapper, line, "属性值")?;
170:                line,
189:        let line = line_of(&item);
190:        let constraint = first_inner(item, line, "约束声明")?;
207:    let line = line_of(&pair);
224:        line,
225:        left: left.ok_or_else(|| PlcError::parse(line, "safety 约束缺少左侧状态"))?,
226:        relation: relation.ok_or_else(|| PlcError::parse(line, "safety 约束缺少关系符"))?,
227:        right: right.ok_or_else(|| PlcError::parse(line, "safety 约束缺少右侧状态"))?,
233:    let line = line_of(&pair);
237:        other => Err(PlcError::parse(line, format!("未知 safety 关系: {other}"))),

thinking
**Assessing parser verification coverage**
exec
/bin/bash -lc "bash -lc 'rg -n \"verify_causality|verify_timing|verification\" -g\"*.rs\"'" in /mnt/e/personal_project/rust_plc succeeded in 51ms:
src/lib.rs:6:pub mod verification;
src/verification/causality.rs:42:pub fn verify_causality(
src/verification/causality.rs:574:    use super::verify_causality;
src/verification/causality.rs:640:        verify_causality(&program, &topology, &constraints)
src/verification/causality.rs:683:        let errors = verify_causality(&program, &topology, &constraints)
src/verification/timing.rs:50:pub fn verify_timing(
src/verification/timing.rs:486:    use super::verify_timing;
src/verification/timing.rs:524:        verify_timing(&program, &topology, &constraints, &state_machine)
src/verification/timing.rs:562:        let errors = verify_timing(&program, &topology, &constraints, &state_machine)
src/verification/timing.rs:610:        verify_timing(&program, &topology, &constraints, &state_machine)
src/verification/timing.rs:639:        let errors = verify_timing(&program, &topology, &constraints, &state_machine)

thinking
**Inspecting recent log entries**
exec
/bin/bash -lc "bash -lc 'tail -n 220 progress.txt'" in /mnt/e/personal_project/rust_plc succeeded in 51ms:
- Files changed
  - `src/ast/mod.rs`, `prd.json`, `progress.txt`
- **Learnings for future iterations:**
  - Patterns discovered (e.g., "this codebase uses X for Y")
    - Keeping AST enums `snake_case` via serde attributes avoids ad-hoc keyword conversion once parser lowering starts.
  - Gotchas encountered (e.g., "do not forget to update Z when changing W")
    - `cargo clippy` is unavailable in this toolchain unless the clippy component is installed (`rustup component add clippy`).
  - Useful context (e.g., "the evaluation panel is in component X")
    - `StepStatement` is modeled as a tagged enum, so parser work can map each DSL statement kind directly without extra wrapper types.
---
## [2026-02-11 01:39:19 CST] - US-003
Thread: https://ampcode.com/threads/$AMP_CURRENT_THREAD_ID
- What was implemented
  - Added `src/parser/plc.pest` with topology-section PEG rules covering `[topology]`, bare port declarations, attribute blocks, all required device types, and all required topology attribute keys.
  - Added parser entrypoint `parse_topology` in `src/parser/mod.rs` using `pest_derive::Parser` against `parser/plc.pest`.
  - Added parser unit tests for the PRD 5.3 topology sample and an additional topology case that exercises every supported device type plus identifier/string/duration/measured/state-reference value forms.
- Files changed
  - `src/parser/plc.pest`, `src/parser/mod.rs`, `prd.json`, `progress.txt`
- **Learnings for future iterations:**
  - Patterns discovered (e.g., "this codebase uses X for Y")

thinking
**Planning story implementation**
exec
/bin/bash -lc "bash -lc 'python3 - <<\"PY\"
import json, pprint
with open(\"prd.json\") as f: d=json.load(f)
keys=[k for k in d.keys() if k not in {\"userStories\"}]
print(\"top keys\",keys)
print(\"qualityGates\",d.get(\"qualityGates\"))
print(\"testStrategy\",d.get(\"testStrategy\"))
for us in d[\"userStories\"]:
    if us[\"id\"] in [\"US-015\",\"US-016\",\"US-017\"]:
        print(\"\\n\",us[\"id\"],us[\"title\"])
        for k,v in us.items():
            if k not in [\"id\",\"title\"]:
                print(k,\":\",v)
PY'" in /mnt/e/personal_project/rust_plc succeeded in 51ms:
top keys ['project', 'branchName', 'description']
qualityGates None
testStrategy None

 US-015 实现活性检查器（Liveness Checker）
description : 作为开发者，我需要活性验证，检测状态机中的潜在死锁。
acceptanceCriteria : ['src/verification/liveness.rs 实现死锁检测', '检查所有 wait 语句是否有 timeout 或 allow_indefinite_wait', '检查非终态状态是否有零出边', 'on_complete: goto 形成的循环（如 ready -> init -> ready）是合法的，不算死锁', 'on_complete: unreachable 的 task 仅在所有内部路径以 goto 结尾时有效；若存在可到达 on_complete 的路径则报错', '检查是否存在不包含 allow_indefinite_wait 或 timeout 出边的强连通分量', '失败时：报告位置、原因、物理分析和修复建议（匹配 PRD 3.2.2 节错误格式）', '错误信息为中文，包含行号', '单元测试：验证 PRD 5.5.1-5.5.3 节示例（有 timeout 和 allow_indefinite_wait）活性通过', '单元测试：验证 wait 无 timeout 且无 allow_indefinite_wait 时活性失败', '类型检查通过']
priority : 15
passes : False
notes : 

 US-016 实现安全性检查器（Safety Checker + Z3）
description : 作为开发者，我需要安全性验证，使用 Z3 SMT 求解器证明状态互斥性质。
acceptanceCriteria : ['Cargo.toml 添加 z3 crate 依赖', 'src/verification/safety.rs 使用 Z3 实现安全性检查', '将状态机转移编码为 Z3 布尔公式', '对每个 conflicts_with 约束，检查两个状态是否可同时可达', '实现分层策略：先尝试 k-induction，失败则回退到 BMC', 'BMC 默认最大展开深度 = 状态节点数；若存在 SCC 则至少展开 |SCC| + 1 层', '尊重用户配置的 bmc_max_depth 上限', "超过 bmc_max_depth 时停止搜索并输出有界验证警告：'WARNING: Safety 在深度 N 内未发现反例，但未获得完备证明'", '报告验证结论级别：完备证明（k-induction/穷举）vs 有界验证（仅 BMC）', '失败时：报告约束、违反路径和修复建议（匹配 PRD 3.2.1 节错误格式）', '错误信息为中文，包含行号', '单元测试：验证双气缸顺序逻辑（不会同时伸出）安全性通过', '单元测试：验证 parallel 块同时伸出两个冲突气缸时安全性失败', '单元测试：验证含 SCC 的状态机至少展开 |SCC| + 1 层', '单元测试：验证超过 bmc_max_depth 时输出有界验证警告', '冲突规则：当 bmc_max_depth < |SCC| + 1 时，截断至 bmc_max_depth 并输出有界验证警告（非完备证明）', '单元测试：当 bmc_max_depth < |SCC| + 1 时，验证截断至上限并输出有界验证警告', '类型检查通过']
priority : 16
passes : False
notes : 

 US-017 集成所有验证并进行端到端测试
description : 作为开发者，我需要将四项验证集成到编译流水线中，并输出统一的验证报告。

thinking
**Planning multi-step progress tracking**
Plan update
Implementing US-015 requires reading existing verifier/state-machine patterns, adding a new liveness checker with tests, then validating and updating project tracking artifacts.
  → Inspect PRD US-015 requirements and current verification/state-machine code paths relevant to liveness checks
  • Implement liveness verification module and expose it in verification mod, including diagnostics format and deadlock/SCC/unreachable checks
  • Add/adjust unit tests for PRD 5.5.1-5.5.3 pass cases and missing-timeout fail case
  • Run quality checks, update prd.json+progress.txt, and commit with required message

thinking
**Preparing liveness analysis on concurrency**
exec
/bin/bash -lc "bash -lc 'python3 - <<\"PY\"
from pathlib import Path
text=Path(\"src/semantic/mod.rs\").read_text()
for fn in [\"fn build_parallel_block\",\"fn build_race_block\",\"fn resolve_task_target\"]:
    i=text.find(fn)
    if i"'!=-1:
        print("'"\\n===\",fn,\"===\")
        print(text[i:i+2500])
PY'" in /mnt/e/personal_project/rust_plc succeeded in 51ms:

=== fn build_parallel_block ===
fn build_parallel_block(
    builder: &mut StateMachineBuilder,
    task: &TaskDeclaration,
    step_name: &str,
    source_state: &State,
    block_index: usize,
    block: &ParallelBlock,
    completion_target: Option<State>,
    task_initial_states: &HashMap<String, State>,
    errors: &mut Vec<PlcError>,
    parent_actions: Vec<TransitionAction>,
) {
    let fork_state_name = format!("{step_name}__parallel_{}_fork", block_index + 1);
    let join_state_name = format!("{step_name}__parallel_{}_join", block_index + 1);

    let fork_state = builder.add_state(&task.name, &fork_state_name);
    let join_state = builder.add_state(&task.name, &join_state_name);


thinking
**Refining function extraction method**
exec
/bin/bash -lc "bash -lc 'rg -n \"fn build_parallel_block|fn build_race_block\" src/semantic/mod.rs'" in /mnt/e/personal_project/rust_plc succeeded in 50ms:
847:fn build_parallel_block(
1012:fn build_race_block(

thinking
**Confirming small sed ranges**
exec
/bin/bash -lc "bash -lc 'sed -n \"840,1125p\" src/semantic/mod.rs'" in /mnt/e/personal_project/rust_plc succeeded in 51ms:
            StepStatement::AllowIndefiniteWait(_) => {}
        }
    }

    analyzed
}

fn build_parallel_block(
    builder: &mut StateMachineBuilder,
    task: &TaskDeclaration,
    step_name: &str,
    source_state: &State,
    block_index: usize,
    block: &ParallelBlock,
    completion_target: Option<State>,
    task_initial_states: &HashMap<String, State>,
    errors: &mut Vec<PlcError>,
    parent_actions: Vec<TransitionAction>,
) {
    let fork_state_name = format!("{step_name}__parallel_{}_fork", block_index + 1);

thinking
**Extending parsing beyond function end**
exec
/bin/bash -lc "bash -lc 'sed -n \"1125,1225p\" src/semantic/mod.rs'" in /mnt/e/personal_project/rust_plc succeeded in 50ms:
        {
            build_parallel_block(
                builder,
                task,
                &format!(
                    "{step_name}__race_{}_branch_{}",
                    block_index + 1,
                    branch_index + 1
                ),
                &branch_state,
                nested_parallel_index,
                nested_parallel,
                branch_completion_target.clone(),
                task_initial_states,
                errors,
                analyzed.actions.clone(),
            );
        }

        for (nested_race_index, nested_race) in analyzed.race_blocks.iter().enumerate() {

thinking
**Assessing state machine liveness semantics**
exec
/bin/bash -lc "bash -lc 'sed -n \"1,240p\" examples/two_cylinder.plc && echo \"---\" && sed -n \"1,260p\" examples/half_rotation.plc'" in /mnt/e/personal_project/rust_plc succeeded in 51ms:
[topology]

device Y0: digital_output
device Y1: digital_output
device X0: digital_input
device X1: digital_input
device X2: digital_input
device X3: digital_input
device X4: digital_input

device start_button: digital_input {
    connected_to: X4
    debounce: 20ms
}

device valve_A: solenoid_valve {
    connected_to: Y0
    response_time: 20ms
}


thinking
**Planning liveness checking approach**
exec
/bin/bash -lc "bash -lc 'sed -n \"1570,1875p\" src/semantic/mod.rs'" in /mnt/e/personal_project/rust_plc succeeded in 51ms:
        assert!(matches!(
            constraints.timing[0].relation,
            TimingRelation::MustCompleteWithin
        ));
        assert_eq!(constraints.timing[0].duration_ms, 5000);

        assert!(matches!(
            constraints.timing[1].scope,
            TimingScope::Step { ref task, ref step } if task == "init" && step == "step_extend_A"
        ));
        assert_eq!(constraints.causality[0].devices.len(), 4);
        assert_eq!(constraints.causality[0].devices[0], "Y0");
        assert_eq!(constraints.causality[0].devices[3], "sensor_A_ext");

        let extend_key = "init.step_extend_A.extend.cyl_A";
        let retract_key = "init.step_retract_A.retract.cyl_A";
        let motor_key = "ready.start_motor.set.motor_ctrl";

        assert_eq!(timing_model.intervals[extend_key].interval.min_ms, 200);
        assert_eq!(timing_model.intervals[extend_key].interval.max_ms, 200);



thinking
**Designing comprehensive liveness checks**
thinking
**Designing recursive control-flow analysis**
thinking
**Designing SCC and liveness diagnostics**
Plan update
  ✓ Inspect PRD US-015 requirements and current verification/state-machine code paths relevant to liveness checks
  → Implement liveness verification module and expose it in verification mod, including diagnostics format and deadlock/SCC/unreachable checks
  • Add/adjust unit tests for PRD 5.5.1-5.5.3 pass cases and missing-timeout fail case
  • Run quality checks, update prd.json+progress.txt, and commit with required message

thinking
**Creating liveness module**
exec
/bin/bash -lc "bash -lc 'cat > src/verification/liveness.rs <<\"RS\"
use crate::ast::{
    ComparisonOperator, LiteralValue, OnCompleteDirective, PlcProgram, StepStatement, TaskDeclaration,
    WaitStatement,
};
use crate::ir::{StateMachine, TransitionGuard};
use petgraph::algo::kosaraju_scc;
use petgraph::graph::DiGraph;
use petgraph::visit::EdgeRef;
use std::collections::{HashMap, HashSet};
use std::fmt;

#[derive(Debug, Clone, PartialEq, Eq)]
pub struct LivenessDiagnostic {
    pub line: usize,
    pub reason: String,
    pub physical_analysis: String,
    pub suggestion: String,
}

impl fmt::Display for LivenessDiagnostic {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        writeln"'!(f, "ERROR [liveness] 潜在死锁")?;
        writeln!(f, "  位置: <input>:{}:1", self.line)?;
        writeln!(f, "  原因: {}", self.reason)?;
        writeln!(f, "  物理分析: {}", self.physical_analysis)?;
        write!(f, "  建议: {}", self.suggestion)
    }
}

#[derive(Debug, Clone, Default)]
struct StepLivenessFacts {
    waits: Vec<String>,
    has_timeout: bool,
    has_allow_indefinite_wait: bool,
}

#[derive(Debug, Clone, Copy, Default)]
struct FlowSummary {
    has_jump_path: bool,
    has_non_jump_path: bool,
}

impl FlowSummary {
    fn merge(&mut self, other: Self) {
        self.has_jump_path |= other.has_jump_path;
        self.has_non_jump_path |= other.has_non_jump_path;
    }

    fn guarantees_jump(&self) -> bool {
        self.has_jump_path && !self.has_non_jump_path
    }
}

#[derive(Debug, Clone, Copy)]
struct LivenessEdge {
    is_timeout: bool,
    source_has_allow_wait: bool,
}

pub fn verify_liveness(
    program: &PlcProgram,
    state_machine: &StateMachine,
) -> Result<(), Vec<LivenessDiagnostic>> {
    let mut diagnostics = Vec::new();

    let step_line_map = collect_step_line_map(program);
    check_wait_timeout_or_allow(program, &mut diagnostics);
    check_unreachable_on_complete(program, &mut diagnostics);
    check_non_terminal_zero_out_degree(program, state_machine, &step_line_map, &mut diagnostics);
    check_strongly_connected_components(program, state_machine, &step_line_map, &mut diagnostics);

    if diagnostics.is_empty() {
        Ok(())
    } else {
        Err(diagnostics)
    }
}

fn check_wait_timeout_or_allow(program: &PlcProgram, diagnostics: &mut Vec<LivenessDiagnostic>) {
    for task in &program.tasks.tasks {
        for step in &task.steps {
            let mut facts = StepLivenessFacts::default();
            collect_step_liveness_facts(&step.statements, &mut facts);

            if facts.waits.is_empty() || facts.has_timeout || facts.has_allow_indefinite_wait {
                continue;
            }

            for wait in facts.waits {
                diagnostics.push(LivenessDiagnostic {
                    line: step.line.max(1),
                    reason: format!(
                        "task {}.{} 的 wait 条件 `{wait}` 缺少 timeout 分支，且未设置 allow_indefinite_wait",
                        task.name, step.name
                    ),
                    physical_analysis: "若传感器信号长期不满足（线路故障/执行器卡滞/设备离线），控制逻辑会永久停留在该等待点".to_string(),
                    suggestion: "请为该 step 添加 `timeout: <时长> -> goto <恢复 task>`，或在人工等待场景显式设置 `allow_indefinite_wait: true`".to_string(),
                });
            }
        }
    }
}

fn check_unreachable_on_complete(program: &PlcProgram, diagnostics: &mut Vec<LivenessDiagnostic>) {
    for task in &program.tasks.tasks {
        if !matches!(task.on_complete, Some(OnCompleteDirective::Unreachable)) {
            continue;
        }

        let Some(last_step) = task.steps.last() else {
            continue;
        };

        let summary = summarize_statements(&last_step.statements, false);
        if summary.guarantees_jump() {
            continue;
        }

        diagnostics.push(LivenessDiagnostic {
            line: task.on_complete_line.unwrap_or(task.line).max(1),
            reason: format!(
                "task {} 声明了 on_complete: unreachable，但最后一步 {} 仍存在非跳转执行路径",
                task.name, last_step.name
            ),
            physical_analysis:
                "该 task 仍可能在不执行 goto 的情况下到达完成点或停滞，`unreachable` 标记与真实控制流不一致"
                    .to_string(),
            suggestion:
                "请确保最后一步的所有路径都通过 goto/timeout->goto 离开该 task，或改为 `on_complete: goto <task>`"
                    .to_string(),
        });
    }
}

fn check_non_terminal_zero_out_degree(
    program: &PlcProgram,
    state_machine: &StateMachine,
    step_line_map: &HashMap<(String, String), usize>,
    diagnostics: &mut Vec<LivenessDiagnostic>,
) {
    let out_degree = out_degree_map(state_machine);

    for state in &state_machine.states {
        let key = state_key(&state.task_name, &state.step_name);
        if out_degree.get(&key).copied().unwrap_or(0) > 0 {
            continue;
        }

        if is_terminal_state(program, &state.task_name, &state.step_name) {
            continue;
        }

        let line = state_line(step_line_map, program, &state.task_name, &state.step_name);
        diagnostics.push(LivenessDiagnostic {
            line,
            reason: format!("状态 {}.{} 没有任何出边", state.task_name, state.step_name),
            physical_analysis:
                "该状态既不是显式终态，也不存在转移分支；运行到此处后控制流程将无法继续推进"
                    .to_string(),
            suggestion:
                "请补充 wait+timeout、goto 或 on_complete 跳转，确保该状态至少存在一条可执行出边"
                    .to_string(),
        });
    }
}

fn check_strongly_connected_components(
    program: &PlcProgram,
    state_machine: &StateMachine,
    step_line_map: &HashMap<(String, String), usize>,
    diagnostics: &mut Vec<LivenessDiagnostic>,
) {
    let allow_wait_states = collect_allow_wait_states(program);
    let mut graph = DiGraph::<(String, String), LivenessEdge>::new();
    let mut node_map = HashMap::<(String, String), petgraph::graph::NodeIndex>::new();

    for state in &state_machine.states {
        let key = state_key(&state.task_name, &state.step_name);
        let index = graph.add_node(key.clone());
        node_map.insert(key, index);
    }

    for transition in &state_machine.transitions {
        let from_key = state_key(&transition.from.task_name, &transition.from.step_name);
        let to_key = state_key(&transition.to.task_name, &transition.to.step_name);

        let Some(from_index) = node_map.get(&from_key).copied() else {
            continue;
        };
        let Some(to_index) = node_map.get(&to_key).copied() else {
            continue;
        };

        graph.add_edge(
            from_index,
            to_index,
            LivenessEdge {
                is_timeout: matches!(transition.guard, TransitionGuard::Timeout { .. }),
                source_has_allow_wait: allow_wait_states.contains(&from_key),
            },
        );
    }

    for component in kosaraju_scc(&graph) {
        if component.is_empty() {
            continue;
        }

        let has_cycle = component.len() > 1
            || graph
                .edges(component[0])
                .any(|edge| edge.target() == component[0]);
        if !has_cycle {
            continue;
        }

        let component_set: HashSet<_> = component.iter().copied().collect();
        let mut has_timeout_or_allow = false;
        for node in &component {
            for edge in graph.edges(*node) {
                if edge.weight().is_timeout || edge.weight().source_has_allow_wait {
                    has_timeout_or_allow = true;
                    break;
                }
            }
            if has_timeout_or_allow {
                break;
            }
        }

        if has_timeout_or_allow {
            continue;
        }

        let mut component_states = component
            .iter()
            .map(|node| {
                let (task, step) = &graph[*node];
                format!("{task}.{step}")
            })
            .collect::<Vec<_>>();
        component_states.sort();

        let line = component
            .iter()
            .map(|node| {
                let (task, step) = &graph[*node];
                state_line(step_line_map, program, task, step)
            })
            .min()
            .unwrap_or(1)
            .max(1);

        diagnostics.push(LivenessDiagnostic {
            line,
            reason: format!(
                "检测到强连通分量 [{}] 不包含 timeout 或 allow_indefinite_wait 出边",
                component_states.join(", ")
            ),
            physical_analysis:
                "一旦进入该循环，若条件长期不满足，流程会在环内反复执行且没有超时/人工等待豁免出口"
                    .to_string(),
            suggestion:
                "请在该循环中添加 timeout 逃生分支，或在人工等待点显式声明 allow_indefinite_wait: true"
                    .to_string(),
        });

        let _ = component_set;
    }
}

fn collect_step_liveness_facts(statements: &[StepStatement], facts: &mut StepLivenessFacts) {
    for statement in statements {
        match statement {
            StepStatement::Wait(wait) => facts.waits.push(wait_to_text(wait)),
            StepStatement::Timeout(_) => facts.has_timeout = true,
            StepStatement::AllowIndefiniteWait(value) => {
                if *value {
                    facts.has_allow_indefinite_wait = true;
                }
            }
            StepStatement::Parallel(block) => {
                for branch in &block.branches {
                    collect_step_liveness_facts(&branch.statements, facts);
                }
            }
            StepStatement::Race(block) => {
                for branch in &block.branches {
                    collect_step_liveness_facts(&branch.statements, facts);
                }
            }
            StepStatement::Action(_) | StepStatement::Goto(_) => {}
        }
    }
}

fn summarize_statements(statements: &[StepStatement], completion_is_jump: bool) -> FlowSummary {
    let mut summary = FlowSummary::default();
    let mut has_control_flow = false;

    for statement in statements {
        match statement {
            StepStatement::Goto(_) | StepStatement::Timeout(_) => {
                has_control_flow = true;
                summary.has_jump_path = true;
            }
            StepStatement::Wait(_) => {
                has_control_flow = true;
                if completion_is_jump {
                    summary.has_jump_path = true;
                } else {
                    summary.has_non_jump_path = true;
                }
            }
            StepStatement::Parallel(block) => {
                has_control_flow = true;
                for branch in &block.branches {
                    summary.merge(summarize_statements(&branch.statements, completion_is_jump));
                }
            }
            StepStatement::Race(block) => {
                has_control_flow = true;
                for branch in &block.branches {
                    let branch_completion_is_jump = branch.then_goto.is_some() || completion_is_jump;
                    summary.merge(summarize_statements(
                        &branch.statements,
                        branch_completion_is_jump,
                    ));
                }
            }
            StepStatement::Action(_) | StepStatement::AllowIndefiniteWait(_) => {}
        }
    }

    if !has_control_flow {
        if completion_is_jump {
            summary.has_jump_path = true;
        } else {
            summary.has_non_jump_path = true;
        }
    }

    summary
}

fn collect_step_line_map(program: &PlcProgram) -> HashMap<(String, String), usize> {
    let mut map = HashMap::new();
    for task in &program.tasks.tasks {
        for step in &task.steps {
            map.insert(
                state_key(&task.name, &step.name),
                step.line.max(task.line).max(1),
            );
        }
    }
    map
}

fn out_degree_map(state_machine: &StateMachine) -> HashMap<(String, String), usize> {
    let mut out_degree = HashMap::new();

    for transition in &state_machine.transitions {
        let key = state_key(&transition.from.task_name, &transition.from.step_name);
        *out_degree.entry(key).or_insert(0) += 1;
    }

    out_degree
}

fn is_terminal_state(program: &PlcProgram, task_name: &str, step_name: &str) -> bool {
    let Some(task) = program.tasks.tasks.iter().find(|task| task.name == task_name) else {
        return false;
    };

    if task.on_complete.is_some() {
        return false;
    }

    task
        .steps
        .last()
        .map(|step| step.name == step_name)
        .unwrap_or(false)
}

fn state_line(
    step_line_map: &HashMap<(String, String), usize>,
    program: &PlcProgram,
    task_name: &str,
    step_name: &str,
) -> usize {
    let direct_key = state_key(task_name, step_name);
    if let Some(line) = step_line_map.get(&direct_key) {
        return (*line).max(1);
    }

    let base_step = step_name
        .split("__")
        .next()
        .unwrap_or(step_name)
        .to_string();
    let normalized_key = state_key(task_name, &base_step);
    if let Some(line) = step_line_map.get(&normalized_key) {
        return (*line).max(1);
    }

    program
        .tasks
        .tasks
        .iter()
        .find(|task| task.name == task_name)
        .map(|task| task.line.max(1))
        .unwrap_or(1)
}

fn collect_allow_wait_states(program: &PlcProgram) -> HashSet<(String, String)> {
    let mut states = HashSet::new();

    for task in &program.tasks.tasks {
        for step in &task.steps {
            if step
                .statements
                .iter()
                .any(|statement| matches!(statement, StepStatement::AllowIndefiniteWait(true)))
            {
                states.insert(state_key(&task.name, &step.name));
            }
        }
    }

    states
}

fn state_key(task_name: &str, step_name: &str) -> (String, String) {
    (task_name.to_string(), step_name.to_string())
}

fn wait_to_text(wait: &WaitStatement) -> String {
    format!(
        "{} {} {}",
        wait.condition.left,
        comparison_operator_text(&wait.condition.operator),
        literal_to_text(&wait.condition.right)
    )
}

fn comparison_operator_text(operator: &ComparisonOperator) -> &'"'static str {
    match operator {
        ComparisonOperator::Eq => \"==\",
        ComparisonOperator::Neq => \""'!=",
    }
}

fn literal_to_text(literal: &LiteralValue) -> String {
    match literal {
        LiteralValue::Boolean(value) => value.to_string(),
        LiteralValue::Number(value) => value.to_string(),
        LiteralValue::String(value) => format!("'"\\\"{value}\\\"\"),
        LiteralValue::State(state) => format"'!("{}.{}", state.device, state.state),
    }
}

#[cfg(test)]
mod tests {
    use super::verify_liveness;
    use crate::parser::parse_plc;
    use crate::semantic::build_state_machine;

    #[test]
    fn passes_prd_5_5_1_to_5_5_3_liveness_examples() {
        let source = r#"
[topology]

[constraints]

[tasks]

task init:
    step extend_A:
        action: extend cyl_A
        wait: sensor_A_ext == true
        timeout: 600ms -> goto fault_handler

    step retract_A:
        action: retract cyl_A
        wait: sensor_A_ret == true
        timeout: 500ms -> goto fault_handler

    step extend_B:
        action: extend cyl_B
        wait: sensor_B_ext == true
        timeout: 800ms -> goto fault_handler

    step retract_B:
        action: retract cyl_B
        wait: sensor_B_ret == true
        timeout: 700ms -> goto fault_handler

    on_complete: goto ready

task fault_handler:
    step safe_position:
        action: retract cyl_A
        action: retract cyl_B
    step alarm:
        action: set alarm_light on
        action: log "动作超时，已执行安全复位"
    on_complete: goto ready

task ready:
    step wait_start:
        wait: start_button == true
        allow_indefinite_wait: true
    on_complete: goto init
"#;

        let program = parse_plc(source).expect("PRD 5.5.1-5.5.3 示例应能解析");
        let state_machine = build_state_machine(&program).expect("状态机应构建成功");

        verify_liveness(&program, &state_machine).expect("带 timeout 和 allow_indefinite_wait 的流程应通过活性检查");
    }

    #[test]
    fn fails_when_wait_has_no_timeout_and_no_allow_indefinite_wait() {
        let source = r#"
[topology]

[constraints]

[tasks]

task init:
    step wait_sensor:
        wait: sensor_A == true
    on_complete: goto ready

task ready:
    step idle:
        action: log "ready"
"#;

        let program = parse_plc(source).expect("测试程序应能解析");
        let state_machine = build_state_machine(&program).expect("状态机应构建成功");

        let errors = verify_liveness(&program, &state_machine)
            .expect_err("wait 无 timeout 且无 allow_indefinite_wait 时应报错");

        assert!(
            errors
                .iter()
                .any(|error| error.to_string().contains("缺少 timeout 分支")),
            "错误应指出 wait 缺少 timeout"
        );
        assert!(
            errors.iter().all(|error| error.line > 0),
            "所有活性错误都应包含有效行号"
        );
    }

    #[test]
    fn accepts_on_complete_goto_cycle_as_non_deadlock() {
        let source = r#"
[topology]

[constraints]

[tasks]

task init:
    step boot:
        action: log "boot"
    on_complete: goto ready

task ready:
    step wait_start:
        wait: start_button == true
        allow_indefinite_wait: true
    on_complete: goto init
"#;

        let program = parse_plc(source).expect("测试程序应能解析");
        let state_machine = build_state_machine(&program).expect("状态机应构建成功");

        verify_liveness(&program, &state_machine)
            .expect("on_complete: goto 构成的循环不应被视为死锁");
    }

    #[test]
    fn rejects_unreachable_on_complete_when_last_step_has_non_jump_path() {
        let source = r#"
[topology]

[constraints]

[tasks]

task search:
    step detect:
        wait: sensor_A == true
        timeout: 800ms -> goto fault_handler
    on_complete: unreachable

task fault_handler:
    step alarm:
        action: log "fault"
"#;

        let program = parse_plc(source).expect("测试程序应能解析");
        let state_machine = build_state_machine(&program).expect("状态机应构建成功");

        let errors = verify_liveness(&program, &state_machine)
            .expect_err("unreachable 声明与可完成路径冲突时应报错");

        assert!(
            errors
                .iter()
                .any(|error| error.to_string().contains("on_complete: unreachable")),
            "错误应明确指出 unreachable 标记无效"
        );
    }

    #[test]
    fn rejects_scc_without_timeout_or_allow_indefinite_wait_edges() {
        let source = r#"
[topology]

[constraints]

[tasks]

task init:
    step start:
        action: log "start"
    on_complete: goto loop

task loop:
    step spin:
        action: log "spin"
    on_complete: goto init
"#;

        let program = parse_plc(source).expect("测试程序应能解析");
        let state_machine = build_state_machine(&program).expect("状态机应构建成功");

        let errors = verify_liveness(&program, &state_machine)
            .expect_err("无 timeout/allow_indefinite_wait 的循环 SCC 应报错");

        assert!(
            errors
                .iter()
                .any(|error| error.to_string().contains("强连通分量")),
            "错误应包含 SCC 死锁风险说明"
        );
    }

    #[test]
    fn allows_unreachable_when_all_race_paths_jump_away() {
        let source = r#"
[topology]

[constraints]

[tasks]

task search:
    step detect:
        race:
            branch_A:
                wait: sensor_A == true
                then: goto process_A
            branch_B:
                wait: sensor_B == true
                then: goto process_B
        timeout: 800ms -> goto fault_handler
    on_complete: unreachable

task process_A:
    step done:
        action: log "A"

task process_B:
    step done:
        action: log "B"

task fault_handler:
    step done:
        action: log "fault"
"#;

        let program = parse_plc(source).expect("测试程序应能解析");
        let state_machine = build_state_machine(&program).expect("状态机应构建成功");

        verify_liveness(&program, &state_machine)
            .expect("race 每条路径都通过 goto/timeout 跳转时 unreachable 应合法");
    }
}
RS'"'" in /mnt/e/personal_project/rust_plc exited 2 in 50ms:
/bin/bash: -c: line 22: syntax error near unexpected token `)'
/bin/bash: -c: line 22: `    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {'

thinking
**Switching to Python script writing**
exec
/bin/bash -lc "python3 - <<'PY'
from pathlib import Path
content = r'''use crate::ast::{
    ComparisonOperator, LiteralValue, OnCompleteDirective, PlcProgram, StepStatement, WaitStatement,
};
use crate::ir::{StateMachine, TransitionGuard};
use petgraph::algo::kosaraju_scc;
use petgraph::graph::DiGraph;
use petgraph::visit::EdgeRef;
use std::collections::{HashMap, HashSet};
use std::fmt;

#[derive(Debug, Clone, PartialEq, Eq)]
pub struct LivenessDiagnostic {
    pub line: usize,
    pub reason: String,
    pub physical_analysis: String,
    pub suggestion: String,
}

impl fmt::Display for LivenessDiagnostic {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        writeln"'!(f, "ERROR [liveness] 潜在死锁")?;
        writeln!(f, "  位置: <input>:{}:1", self.line)?;
        writeln!(f, "  原因: {}", self.reason)?;
        writeln!(f, "  物理分析: {}", self.physical_analysis)?;
        write!(f, "  建议: {}", self.suggestion)
    }
}

#[derive(Debug, Clone, Default)]
struct StepLivenessFacts {
    waits: Vec<String>,
    has_timeout: bool,
    has_allow_indefinite_wait: bool,
}

#[derive(Debug, Clone, Copy, Default)]
struct FlowSummary {
    has_jump_path: bool,
    has_non_jump_path: bool,
}

impl FlowSummary {
    fn merge(&mut self, other: Self) {
        self.has_jump_path |= other.has_jump_path;
        self.has_non_jump_path |= other.has_non_jump_path;
    }

    fn guarantees_jump(&self) -> bool {
        self.has_jump_path && !self.has_non_jump_path
    }
}

#[derive(Debug, Clone, Copy)]
struct LivenessEdge {
    is_timeout: bool,
    source_has_allow_wait: bool,
}

pub fn verify_liveness(
    program: &PlcProgram,
    state_machine: &StateMachine,
) -> Result<(), Vec<LivenessDiagnostic>> {
    let mut diagnostics = Vec::new();

    let step_line_map = collect_step_line_map(program);
    check_wait_timeout_or_allow(program, &mut diagnostics);
    check_unreachable_on_complete(program, &mut diagnostics);
    check_non_terminal_zero_out_degree(program, state_machine, &step_line_map, &mut diagnostics);
    check_strongly_connected_components(program, state_machine, &step_line_map, &mut diagnostics);

    if diagnostics.is_empty() {
        Ok(())
    } else {
        Err(diagnostics)
    }
}

fn check_wait_timeout_or_allow(program: &PlcProgram, diagnostics: &mut Vec<LivenessDiagnostic>) {
    for task in &program.tasks.tasks {
        for step in &task.steps {
            let mut facts = StepLivenessFacts::default();
            collect_step_liveness_facts(&step.statements, &mut facts);

            if facts.waits.is_empty() || facts.has_timeout || facts.has_allow_indefinite_wait {
                continue;
            }

            for wait in facts.waits {
                diagnostics.push(LivenessDiagnostic {
                    line: step.line.max(1),
                    reason: format!(
                        "task {}.{} 的 wait 条件 `{wait}` 缺少 timeout 分支，且未设置 allow_indefinite_wait",
                        task.name, step.name
                    ),
                    physical_analysis: "若传感器信号长期不满足（线路故障/执行器卡滞/设备离线），控制逻辑会永久停留在该等待点".to_string(),
                    suggestion: "请为该 step 添加 `timeout: <时长> -> goto <恢复 task>`，或在人工等待场景显式设置 `allow_indefinite_wait: true`".to_string(),
                });
            }
        }
    }
}

fn check_unreachable_on_complete(program: &PlcProgram, diagnostics: &mut Vec<LivenessDiagnostic>) {
    for task in &program.tasks.tasks {
        if !matches!(task.on_complete, Some(OnCompleteDirective::Unreachable)) {
            continue;
        }

        let Some(last_step) = task.steps.last() else {
            continue;
        };

        let summary = summarize_statements(&last_step.statements, false);
        if summary.guarantees_jump() {
            continue;
        }

        diagnostics.push(LivenessDiagnostic {
            line: task.on_complete_line.unwrap_or(task.line).max(1),
            reason: format!(
                "task {} 声明了 on_complete: unreachable，但最后一步 {} 仍存在非跳转执行路径",
                task.name, last_step.name
            ),
            physical_analysis:
                "该 task 仍可能在不执行 goto 的情况下到达完成点或停滞，`unreachable` 标记与真实控制流不一致"
                    .to_string(),
            suggestion:
                "请确保最后一步的所有路径都通过 goto/timeout->goto 离开该 task，或改为 `on_complete: goto <task>`"
                    .to_string(),
        });
    }
}

fn check_non_terminal_zero_out_degree(
    program: &PlcProgram,
    state_machine: &StateMachine,
    step_line_map: &HashMap<(String, String), usize>,
    diagnostics: &mut Vec<LivenessDiagnostic>,
) {
    let out_degree = out_degree_map(state_machine);

    for state in &state_machine.states {
        let key = state_key(&state.task_name, &state.step_name);
        if out_degree.get(&key).copied().unwrap_or(0) > 0 {
            continue;
        }

        if is_terminal_state(program, &state.task_name, &state.step_name) {
            continue;
        }

        let line = state_line(step_line_map, program, &state.task_name, &state.step_name);
        diagnostics.push(LivenessDiagnostic {
            line,
            reason: format!("状态 {}.{} 没有任何出边", state.task_name, state.step_name),
            physical_analysis:
                "该状态既不是显式终态，也不存在转移分支；运行到此处后控制流程将无法继续推进"
                    .to_string(),
            suggestion:
                "请补充 wait+timeout、goto 或 on_complete 跳转，确保该状态至少存在一条可执行出边"
                    .to_string(),
        });
    }
}

fn check_strongly_connected_components(
    program: &PlcProgram,
    state_machine: &StateMachine,
    step_line_map: &HashMap<(String, String), usize>,
    diagnostics: &mut Vec<LivenessDiagnostic>,
) {
    let allow_wait_states = collect_allow_wait_states(program);
    let mut graph = DiGraph::<(String, String), LivenessEdge>::new();
    let mut node_map = HashMap::<(String, String), petgraph::graph::NodeIndex>::new();

    for state in &state_machine.states {
        let key = state_key(&state.task_name, &state.step_name);
        let index = graph.add_node(key.clone());
        node_map.insert(key, index);
    }

    for transition in &state_machine.transitions {
        let from_key = state_key(&transition.from.task_name, &transition.from.step_name);
        let to_key = state_key(&transition.to.task_name, &transition.to.step_name);

        let Some(from_index) = node_map.get(&from_key).copied() else {
            continue;
        };
        let Some(to_index) = node_map.get(&to_key).copied() else {
            continue;
        };

        graph.add_edge(
            from_index,
            to_index,
            LivenessEdge {
                is_timeout: matches!(transition.guard, TransitionGuard::Timeout { .. }),
                source_has_allow_wait: allow_wait_states.contains(&from_key),
            },
        );
    }

    for component in kosaraju_scc(&graph) {
        if component.is_empty() {
            continue;
        }

        let has_cycle = component.len() > 1
            || graph
                .edges(component[0])
                .any(|edge| edge.target() == component[0]);
        if !has_cycle {
            continue;
        }

        let mut has_timeout_or_allow = false;
        for node in &component {
            for edge in graph.edges(*node) {
                if edge.weight().is_timeout || edge.weight().source_has_allow_wait {
                    has_timeout_or_allow = true;
                    break;
                }
            }
            if has_timeout_or_allow {
                break;
            }
        }

        if has_timeout_or_allow {
            continue;
        }

        let mut component_states = component
            .iter()
            .map(|node| {
                let (task, step) = &graph[*node];
                format!("{task}.{step}")
            })
            .collect::<Vec<_>>();
        component_states.sort();

        let line = component
            .iter()
            .map(|node| {
                let (task, step) = &graph[*node];
                state_line(step_line_map, program, task, step)
            })
            .min()
            .unwrap_or(1)
            .max(1);

        diagnostics.push(LivenessDiagnostic {
            line,
            reason: format!(
                "检测到强连通分量 [{}] 不包含 timeout 或 allow_indefinite_wait 出边",
                component_states.join(", ")
            ),
            physical_analysis:
                "一旦进入该循环，若条件长期不满足，流程会在环内反复执行且没有超时/人工等待豁免出口"
                    .to_string(),
            suggestion:
                "请在该循环中添加 timeout 逃生分支，或在人工等待点显式声明 allow_indefinite_wait: true"
                    .to_string(),
        });
    }
}

fn collect_step_liveness_facts(statements: &[StepStatement], facts: &mut StepLivenessFacts) {
    for statement in statements {
        match statement {
            StepStatement::Wait(wait) => facts.waits.push(wait_to_text(wait)),
            StepStatement::Timeout(_) => facts.has_timeout = true,
            StepStatement::AllowIndefiniteWait(value) => {
                if *value {
                    facts.has_allow_indefinite_wait = true;
                }
            }
            StepStatement::Parallel(block) => {
                for branch in &block.branches {
                    collect_step_liveness_facts(&branch.statements, facts);
                }
            }
            StepStatement::Race(block) => {
                for branch in &block.branches {
                    collect_step_liveness_facts(&branch.statements, facts);
                }
            }
            StepStatement::Action(_) | StepStatement::Goto(_) => {}
        }
    }
}

fn summarize_statements(statements: &[StepStatement], completion_is_jump: bool) -> FlowSummary {
    let mut summary = FlowSummary::default();
    let mut has_control_flow = false;

    for statement in statements {
        match statement {
            StepStatement::Goto(_) | StepStatement::Timeout(_) => {
                has_control_flow = true;
                summary.has_jump_path = true;
            }
            StepStatement::Wait(_) => {
                has_control_flow = true;
                if completion_is_jump {
                    summary.has_jump_path = true;
                } else {
                    summary.has_non_jump_path = true;
                }
            }
            StepStatement::Parallel(block) => {
                has_control_flow = true;
                for branch in &block.branches {
                    summary.merge(summarize_statements(&branch.statements, completion_is_jump));
                }
            }
            StepStatement::Race(block) => {
                has_control_flow = true;
                for branch in &block.branches {
                    let branch_completion_is_jump = branch.then_goto.is_some() || completion_is_jump;
                    summary.merge(summarize_statements(
                        &branch.statements,
                        branch_completion_is_jump,
                    ));
                }
            }
            StepStatement::Action(_) | StepStatement::AllowIndefiniteWait(_) => {}
        }
    }

    if !has_control_flow {
        if completion_is_jump {
            summary.has_jump_path = true;
        } else {
            summary.has_non_jump_path = true;
        }
    }

    summary
}

fn collect_step_line_map(program: &PlcProgram) -> HashMap<(String, String), usize> {
    let mut map = HashMap::new();
    for task in &program.tasks.tasks {
        for step in &task.steps {
            map.insert(
                state_key(&task.name, &step.name),
                step.line.max(task.line).max(1),
            );
        }
    }
    map
}

fn out_degree_map(state_machine: &StateMachine) -> HashMap<(String, String), usize> {
    let mut out_degree = HashMap::new();

    for transition in &state_machine.transitions {
        let key = state_key(&transition.from.task_name, &transition.from.step_name);
        *out_degree.entry(key).or_insert(0) += 1;
    }

    out_degree
}

fn is_terminal_state(program: &PlcProgram, task_name: &str, step_name: &str) -> bool {
    let Some(task) = program.tasks.tasks.iter().find(|task| task.name == task_name) else {
        return false;
    };

    if task.on_complete.is_some() {
        return false;
    }

    task
        .steps
        .last()
        .map(|step| step.name == step_name)
        .unwrap_or(false)
}

fn state_line(
    step_line_map: &HashMap<(String, String), usize>,
    program: &PlcProgram,
    task_name: &str,
    step_name: &str,
) -> usize {
    let direct_key = state_key(task_name, step_name);
    if let Some(line) = step_line_map.get(&direct_key) {
        return (*line).max(1);
    }

    let base_step = step_name
        .split("__")
        .next()
        .unwrap_or(step_name)
        .to_string();
    let normalized_key = state_key(task_name, &base_step);
    if let Some(line) = step_line_map.get(&normalized_key) {
        return (*line).max(1);
    }

    program
        .tasks
        .tasks
        .iter()
        .find(|task| task.name == task_name)
        .map(|task| task.line.max(1))
        .unwrap_or(1)
}

fn collect_allow_wait_states(program: &PlcProgram) -> HashSet<(String, String)> {
    let mut states = HashSet::new();

    for task in &program.tasks.tasks {
        for step in &task.steps {
            if step
                .statements
                .iter()
                .any(|statement| matches!(statement, StepStatement::AllowIndefiniteWait(true)))
            {
                states.insert(state_key(&task.name, &step.name));
            }
        }
    }

    states
}

fn state_key(task_name: &str, step_name: &str) -> (String, String) {
    (task_name.to_string(), step_name.to_string())
}

fn wait_to_text(wait: &WaitStatement) -> String {
    format!(
        "{} {} {}",
        wait.condition.left,
        comparison_operator_text(&wait.condition.operator),
        literal_to_text(&wait.condition.right)
    )
}

fn comparison_operator_text(operator: &ComparisonOperator) -> &'"'static str {
    match operator {
        ComparisonOperator::Eq => \"==\",
        ComparisonOperator::Neq => \""'!=",
    }
}

fn literal_to_text(literal: &LiteralValue) -> String {
    match literal {
        LiteralValue::Boolean(value) => value.to_string(),
        LiteralValue::Number(value) => value.to_string(),
        LiteralValue::String(value) => format!("'"\\\"{value}\\\"\"),
        LiteralValue::State(state) => format"'!("{}.{}", state.device, state.state),
    }
}

#[cfg(test)]
mod tests {
    use super::verify_liveness;
    use crate::parser::parse_plc;
    use crate::semantic::build_state_machine;

    #[test]
    fn passes_prd_5_5_1_to_5_5_3_liveness_examples() {
        let source = r#"
[topology]

[constraints]

[tasks]

task init:
    step extend_A:
        action: extend cyl_A
        wait: sensor_A_ext == true
        timeout: 600ms -> goto fault_handler

    step retract_A:
        action: retract cyl_A
        wait: sensor_A_ret == true
        timeout: 500ms -> goto fault_handler

    step extend_B:
        action: extend cyl_B
        wait: sensor_B_ext == true
        timeout: 800ms -> goto fault_handler

    step retract_B:
        action: retract cyl_B
        wait: sensor_B_ret == true
        timeout: 700ms -> goto fault_handler

    on_complete: goto ready

task fault_handler:
    step safe_position:
        action: retract cyl_A
        action: retract cyl_B
    step alarm:
        action: set alarm_light on
        action: log "动作超时，已执行安全复位"
    on_complete: goto ready

task ready:
    step wait_start:
        wait: start_button == true
        allow_indefinite_wait: true
    on_complete: goto init
"#;

        let program = parse_plc(source).expect("PRD 5.5.1-5.5.3 示例应能解析");
        let state_machine = build_state_machine(&program).expect("状态机应构建成功");

        verify_liveness(&program, &state_machine)
            .expect("带 timeout 和 allow_indefinite_wait 的流程应通过活性检查");
    }

    #[test]
    fn fails_when_wait_has_no_timeout_and_no_allow_indefinite_wait() {
        let source = r#"
[topology]

[constraints]

[tasks]

task init:
    step wait_sensor:
        wait: sensor_A == true
    on_complete: goto ready

task ready:
    step idle:
        action: log "ready"
"#;

        let program = parse_plc(source).expect("测试程序应能解析");
        let state_machine = build_state_machine(&program).expect("状态机应构建成功");

        let errors = verify_liveness(&program, &state_machine)
            .expect_err("wait 无 timeout 且无 allow_indefinite_wait 时应报错");

        assert!(
            errors
                .iter()
                .any(|error| error.to_string().contains("缺少 timeout 分支")),
            "错误应指出 wait 缺少 timeout"
        );
        assert!(
            errors.iter().all(|error| error.line > 0),
            "所有活性错误都应包含有效行号"
        );
    }

    #[test]
    fn accepts_on_complete_goto_cycle_as_non_deadlock() {
        let source = r#"
[topology]

[constraints]

[tasks]

task init:
    step boot:
        action: log "boot"
    on_complete: goto ready

task ready:
    step wait_start:
        wait: start_button == true
        allow_indefinite_wait: true
    on_complete: goto init
"#;

        let program = parse_plc(source).expect("测试程序应能解析");
        let state_machine = build_state_machine(&program).expect("状态机应构建成功");

        verify_liveness(&program, &state_machine)
            .expect("on_complete: goto 构成的循环不应被视为死锁");
    }

    #[test]
    fn rejects_unreachable_on_complete_when_last_step_has_non_jump_path() {
        let source = r#"
[topology]

[constraints]

[tasks]

task search:
    step detect:
        wait: sensor_A == true
        timeout: 800ms -> goto fault_handler
    on_complete: unreachable

task fault_handler:
    step alarm:
        action: log "fault"
"#;

        let program = parse_plc(source).expect("测试程序应能解析");
        let state_machine = build_state_machine(&program).expect("状态机应构建成功");

        let errors = verify_liveness(&program, &state_machine)
            .expect_err("unreachable 声明与可完成路径冲突时应报错");

        assert!(
            errors
                .iter()
                .any(|error| error.to_string().contains("on_complete: unreachable")),
            "错误应明确指出 unreachable 标记无效"
        );
    }

    #[test]
    fn rejects_scc_without_timeout_or_allow_indefinite_wait_edges() {
        let source = r#"
[topology]

[constraints]

[tasks]

task init:
    step start:
        action: log "start"
    on_complete: goto loop

task loop:
    step spin:
        action: log "spin"
    on_complete: goto init
"#;

        let program = parse_plc(source).expect("测试程序应能解析");
        let state_machine = build_state_machine(&program).expect("状态机应构建成功");

        let errors = verify_liveness(&program, &state_machine)
            .expect_err("无 timeout/allow_indefinite_wait 的循环 SCC 应报错");

        assert!(
            errors
                .iter()
                .any(|error| error.to_string().contains("强连通分量")),
            "错误应包含 SCC 死锁风险说明"
        );
    }

    #[test]
    fn allows_unreachable_when_all_race_paths_jump_away() {
        let source = r#"
[topology]

[constraints]

[tasks]

task search:
    step detect:
        race:
            branch_A:
                wait: sensor_A == true
                then: goto process_A
            branch_B:
                wait: sensor_B == true
                then: goto process_B
        timeout: 800ms -> goto fault_handler
    on_complete: unreachable

task process_A:
    step done:
        action: log "A"

task process_B:
    step done:
        action: log "B"

task fault_handler:
    step done:
        action: log "fault"
"#;

        let program = parse_plc(source).expect("测试程序应能解析");
        let state_machine = build_state_machine(&program).expect("状态机应构建成功");

        verify_liveness(&program, &state_machine)
            .expect("race 每条路径都通过 goto/timeout 跳转时 unreachable 应合法");
    }
}
'"'''
Path('/mnt/e/personal_project/rust_plc/src/verification/liveness.rs').write_text(content)
PY" in /mnt/e/personal_project/rust_plc succeeded in 51ms:


thinking
**Adding public liveness module**
exec
/bin/bash -lc "python3 - <<'PY'
from pathlib import Path
path=Path('/mnt/e/personal_project/rust_plc/src/verification/mod.rs')
text=path.read_text()
if 'pub mod liveness;' not in text:
    text=text + ('\\n' if not text.endswith('\\n') else '') + 'pub mod liveness;\\n'
path.write_text(text)
PY" in /mnt/e/personal_project/rust_plc succeeded in 51ms:


thinking
**Running tests to verify warnings**
exec
/bin/bash -lc "bash -lc 'cargo test -q'" in /mnt/e/personal_project/rust_plc succeeded in 16.76s:

running 36 tests
....................................
test result: ok. 36 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.01s


running 0 tests

test result: ok. 0 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s


running 4 tests
....
test result: ok. 4 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.03s


running 0 tests

test result: ok. 0 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s


thinking
**Revalidating code formatting and checks**
exec
/bin/bash -lc "bash -lc 'cargo fmt --all'" in /mnt/e/personal_project/rust_plc succeeded in 220ms:


thinking
**Running tests after formatting**
exec
/bin/bash -lc "bash -lc 'cargo test -q'" in /mnt/e/personal_project/rust_plc succeeded in 14.74s:

running 36 tests
....................................
test result: ok. 36 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.02s


running 0 tests

test result: ok. 0 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s


running 4 tests
....
test result: ok. 4 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.03s


running 0 tests

test result: ok. 0 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s


thinking
**Verifying type correctness**
exec
/bin/bash -lc "bash -lc 'cargo check -q'" in /mnt/e/personal_project/rust_plc succeeded in 2.12s:


thinking
**Confirming progress on steps**
Plan update
  ✓ Inspect PRD US-015 requirements and current verification/state-machine code paths relevant to liveness checks
  ✓ Implement liveness verification module and expose it in verification mod, including diagnostics format and deadlock/SCC/unreachable checks
  ✓ Add/adjust unit tests for PRD 5.5.1-5.5.3 pass cases and missing-timeout fail case
  → Run quality checks, update prd.json+progress.txt, and commit with required message

thinking
**Checking git status and diff**
exec
/bin/bash -lc "bash -lc 'git status --short'" in /mnt/e/personal_project/rust_plc succeeded in 260ms:
 M .ralph_logs/iter_15.log
 M src/verification/mod.rs
?? .ralph_logs/iter_16.log
?? src/verification/liveness.rs

thinking
**Including all log changes**
exec
/bin/bash -lc "python3 - <<'PY'
import json
from pathlib import Path
path=Path('/mnt/e/personal_project/rust_plc/prd.json')
data=json.loads(path.read_text())
for story in data.get('userStories',[]):
    if story.get('id')=='US-015':
        story['passes']=True
        break
path.write_text(json.dumps(data, ensure_ascii=False, indent=2)+\"\\n\")
PY" in /mnt/e/personal_project/rust_plc succeeded in 52ms:


thinking
**Logging liveness pattern discovery**
exec
/bin/bash -lc "bash -lc 'date \"+%Y-%m-%d %H:%M:%S %Z\"'" in /mnt/e/personal_project/rust_plc succeeded in 51ms:
2026-02-11 12:34:08 CST

thinking
**Inspecting progress file structure**
exec
/bin/bash -lc "bash -lc 'sed -n \"1,40p\" progress.txt'" in /mnt/e/personal_project/rust_plc succeeded in 51ms:
# Ralph Progress Log
## Codebase Patterns
- For timing envelopes, include upstream `response_time` along `connected_to` chains and treat incoming `StateMachine` guards as must_start_after lower bounds (`timeout` contributes delay, `always/condition` = 0ms).
- TopologyGraph JSON 调试依赖 `petgraph` 的 `serde-1` feature；若缺失会导致 DiGraph 无法序列化。
- In parser-to-AST lowering, unwrap wrapper PEG rules (e.g., `constraint_declaration`, `step_statement`) before matching concrete rule kinds, or valid nodes can be silently skipped.
- Keep public module declarations centralized in `src/lib.rs`; implementation files live at `src/<module>/mod.rs`.
- For early story scaffolding, keep module placeholders compiling so CLI and library can evolve incrementally without breaking builds.
- Model DSL enums with `serde(rename_all = "snake_case")` and tagged enums so serialized AST tokens stay aligned with DSL keywords.
- In pest grammars, define silent `WHITESPACE` and `COMMENT` rules so inline `#` comments and multiline section formatting parse without extra boilerplate.
- For block-style DSL sections, parse optional `reason: "..."` clauses directly in each declaration rule so indented multiline annotations remain valid without separate line handling.
- In nested `parallel`/`race` grammar, require branch bodies to consume concrete statements so step-level directives are not misparsed as branch labels.
- In semantic topology lowering, treat `connected_to` as upstream linkage (`target -> current`) so causality traversals follow physical flow direction.
- Preserve directive line metadata in AST (e.g., `GotoDirective.line`, `TaskDeclaration.on_complete_line`) so semantic passes can report precise line-numbered errors without reparsing source text.
- For constraint semantic validation, seed known device states from device-type defaults plus `sensor.detects` references before checking `safety` state expressions.
- Use `PlcError` constructors (`undefined_reference` / `type_mismatch` / `duplicate_definition`) so diagnostics share unified ERROR blocks with `位置/原因/建议` fields.
- For end-to-end compilation paths (CLI/tests), run all four semantic builders and aggregate their errors so users get complete diagnostics in one run.
- For causality verification, augment TopologyGraph with logical edges from `detects.device -> sensor` before running reachability, otherwise output-to-sensor chains may appear disconnected.
Started: Wed Feb 11 01:14:39 CST 2026
---
## [2026-02-11 01:19:50 CST] - US-001

thinking
**Planning bullet insertion and entry append**
exec
/bin/bash -lc "python3 - <<'PY'
from pathlib import Path
path=Path('/mnt/e/personal_project/rust_plc/progress.txt')
text=path.read_text()
pattern='- Liveness checks should combine AST metadata ("'`allow_indefinite_wait`, `on_complete`) with StateMachine transitions; IR guards alone cannot reconstruct all wait exemptions.'"'
if pattern not in text:
    marker='Started:'
    idx=text.find(marker)
    if idx"'!=-1:
        text=text[:idx]+pattern+'"'\\n'+text[idx:]
    else:
        text += '\\n'+pattern+'\\n'
entry='''\\n## [2026-02-11 12:34:08 CST] - US-015
Thread: https://ampcode.com/threads/"'$AMP_CURRENT_THREAD_ID
- What was implemented
  - Added `src/verification/liveness.rs` with `verify_liveness`, implementing deadlock-focused checks for missing wait escape paths, invalid `on_complete: unreachable`, non-terminal zero out-degree states, and SCC loops lacking timeout/allow-indefinite exits.
  - Introduced Chinese liveness diagnostics that follow PRD 3.2.2 style (`ERROR [liveness]` + `位置/原因/物理分析/建议`) with line-numbered reporting.
  - Added six liveness unit tests covering PRD 5.5.1-5.5.3 passing flow, missing-timeout failure, legal `on_complete: goto` loops, invalid `on_complete: unreachable`, SCC risk detection, and valid race+unreachable patterns.
  - Exposed the new verifier through `src/verification/mod.rs`.
- Files changed
  - `src/verification/liveness.rs`, `src/verification/mod.rs`, `prd.json`, `progress.txt`, `.ralph_logs/iter_15.log`, `.ralph_logs/iter_16.log`
- **Learnings for future iterations:**
  - Patterns discovered (e.g., "this codebase uses X for Y")
    - Liveness validation needs both AST context and IR transitions because `allow_indefinite_wait` is not encoded as a dedicated transition guard.
  - Gotchas encountered (e.g., "do not forget to update Z when changing W")
    - `on_complete: unreachable` cannot be validated from transition counts alone; you must analyze whether the final step still has non-jump control-flow paths.
  - Useful context (e.g., "the evaluation panel is in component X")
    - Current line mapping for synthetic parallel/race states reuses the parent step line by splitting synthetic names at `__`, which keeps diagnostics stable for nested control-flow checks.
---
'"'''
if not text.endswith('\\n'):
    text += '\\n'
text += entry
path.write_text(text)
PY" in /mnt/e/personal_project/rust_plc succeeded in 51ms:


thinking
**Reviewing progress formatting**
exec
/bin/bash -lc "bash -lc 'sed -n \"1,28p\" progress.txt && echo \"---TAIL---\" && tail -n 70 progress.txt'" in /mnt/e/personal_project/rust_plc succeeded in 51ms:
# Ralph Progress Log
## Codebase Patterns
- For timing envelopes, include upstream `response_time` along `connected_to` chains and treat incoming `StateMachine` guards as must_start_after lower bounds (`timeout` contributes delay, `always/condition` = 0ms).
- TopologyGraph JSON 调试依赖 `petgraph` 的 `serde-1` feature；若缺失会导致 DiGraph 无法序列化。
- In parser-to-AST lowering, unwrap wrapper PEG rules (e.g., `constraint_declaration`, `step_statement`) before matching concrete rule kinds, or valid nodes can be silently skipped.
- Keep public module declarations centralized in `src/lib.rs`; implementation files live at `src/<module>/mod.rs`.
- For early story scaffolding, keep module placeholders compiling so CLI and library can evolve incrementally without breaking builds.
- Model DSL enums with `serde(rename_all = "snake_case")` and tagged enums so serialized AST tokens stay aligned with DSL keywords.
- In pest grammars, define silent `WHITESPACE` and `COMMENT` rules so inline `#` comments and multiline section formatting parse without extra boilerplate.
- For block-style DSL sections, parse optional `reason: "..."` clauses directly in each declaration rule so indented multiline annotations remain valid without separate line handling.
- In nested `parallel`/`race` grammar, require branch bodies to consume concrete statements so step-level directives are not misparsed as branch labels.
- In semantic topology lowering, treat `connected_to` as upstream linkage (`target -> current`) so causality traversals follow physical flow direction.
- Preserve directive line metadata in AST (e.g., `GotoDirective.line`, `TaskDeclaration.on_complete_line`) so semantic passes can report precise line-numbered errors without reparsing source text.
- For constraint semantic validation, seed known device states from device-type defaults plus `sensor.detects` references before checking `safety` state expressions.
- Use `PlcError` constructors (`undefined_reference` / `type_mismatch` / `duplicate_definition`) so diagnostics share unified ERROR blocks with `位置/原因/建议` fields.
- For end-to-end compilation paths (CLI/tests), run all four semantic builders and aggregate their errors so users get complete diagnostics in one run.
- For causality verification, augment TopologyGraph with logical edges from `detects.device -> sensor` before running reachability, otherwise output-to-sensor chains may appear disconnected.
- Liveness checks should combine AST metadata (`allow_indefinite_wait`, `on_complete`) with StateMachine transitions; IR guards alone cannot reconstruct all wait exemptions.
Started: Wed Feb 11 01:14:39 CST 2026
---

thinking
**Verifying no agent docs**
exec
/bin/bash -lc "bash -lc 'cat src/verification/mod.rs'" in /mnt/e/personal_project/rust_plc succeeded in 51ms:
pub mod causality;
pub mod liveness;
pub mod timing;

thinking
**Extending status check details**
exec
/bin/bash -lc "bash -lc 'git status --short'" in /mnt/e/personal_project/rust_plc succeeded in 204ms:
 M .ralph_logs/iter_15.log
 M prd.json
 M progress.txt
 M src/verification/mod.rs
?? .ralph_logs/iter_16.log
?? src/verification/liveness.rs

thinking
**Reviewing log view changes**
exec
/bin/bash -lc "bash -lc 'ls -l .ralph_logs/iter_15.log .ralph_logs/iter_16.log && tail -n 40 .ralph_logs/iter_15.log && echo \"---\" && sed -n \"1,120p\" .ralph_logs/iter_16.log'" in /mnt/e/personal_project/rust_plc succeeded in 51ms:
-rwxrwxrwx 1 liangyuhang liangyuhang 104292 Feb 11 12:20 .ralph_logs/iter_15.log
-rwxrwxrwx 1 liangyuhang liangyuhang  95614 Feb 11 12:35 .ralph_logs/iter_16.log

Commit created:
- `71ff2d5`
- Message: `feat: [US-014] - [实现时序检查器（Timing Checker）]`

There are still stories with `passes: false` (US-015, US-016, US-017), so this iteration ends normally.
file update:
diff --git a/src/verification/mod.rs b/src/verification/mod.rs
index 210f379c1e732ffff36ac3222eb51055c809581d..f6ab36aa410316b9e4d4170d094e9ae2085fcbf0
--- a/src/verification/mod.rs
+++ b/src/verification/mod.rs
@@ -1 +1,2 @@
 pub mod causality;
+pub mod timing;

tokens used
1,683,623
Implemented US-014 (highest-priority remaining story) on branch `ralph/phase1-2-parser-and-verification`.

thinking
**Reviewing liveness check concerns**
exec
/bin/bash -lc "python3 - <<'PY'
import json
with open('/mnt/e/personal_project/rust_plc/prd.json') as f:
 d=json.load(f)
for us in d['userStories']:
 if us['id'] in ['US-015','US-016','US-017']:
  print(us['id'], us['passes'])
PY" in /mnt/e/personal_project/rust_plc succeeded in 51ms:
US-015 True
US-016 False
US-017 False

thinking
**Verifying absence of AGENTS files**
exec
/bin/bash -lc "bash -lc 'rg --files -g \"AGENTS.md\"'" in /mnt/e/personal_project/rust_plc exited 1 in 51ms:


thinking
**Staging and preparing commit message**
exec
/bin/bash -lc "bash -lc 'git diff --stat'" in /mnt/e/personal_project/rust_plc succeeded in 707ms:
 .ralph_logs/iter_15.log | 100 ++++++++++++++++++++++++++++++++++++++++++++++--
 prd.json                |   2 +-
 progress.txt            |  19 +++++++++
 src/verification/mod.rs |   1 +
 4 files changed, 118 insertions(+), 4 deletions(-)

thinking
**Noting untracked files need staging**
exec
/bin/bash -lc "bash -lc 'git add -A'" in /mnt/e/personal_project/rust_plc succeeded in 167ms:


thinking
**Committing with exact message**
exec
/bin/bash -lc "bash -lc 'git commit -m \"feat: [US-015] - [实现活性检查器（Liveness Checker）]\"'" in /mnt/e/personal_project/rust_plc succeeded in 412ms:
[ralph/phase1-2-parser-and-verification bf0b010] feat: [US-015] - [实现活性检查器（Liveness Checker）]
 6 files changed, 3432 insertions(+), 4 deletions(-)
 create mode 100644 .ralph_logs/iter_16.log
 create mode 100644 src/verification/liveness.rs

thinking
**Confirming large commit completion**
exec
/bin/bash -lc "bash -lc 'git status --short --branch'" in /mnt/e/personal_project/rust_plc succeeded in 225ms:
## ralph/phase1-2-parser-and-verification
 M .ralph_logs/iter_16.log

thinking
**Deciding how to handle post-commit log changes**
exec
/bin/bash -lc "bash -lc 'git add .ralph_logs/iter_16.log && git commit --amend --no-edit'" in /mnt/e/personal_project/rust_plc succeeded in 515ms:
[ralph/phase1-2-parser-and-verification b7f7d1e] feat: [US-015] - [实现活性检查器（Liveness Checker）]
 Date: Wed Feb 11 12:35:50 2026 +0800
 6 files changed, 3452 insertions(+), 4 deletions(-)
 create mode 100644 .ralph_logs/iter_16.log
 create mode 100644 src/verification/liveness.rs

thinking
**Rechecking file status**
exec
/bin/bash -lc "bash -lc 'git status --short --branch'" in /mnt/e/personal_project/rust_plc succeeded in 95ms:
## ralph/phase1-2-parser-and-verification
 M .ralph_logs/iter_16.log

thinking
**Finalizing with last amended commit**
exec
/bin/bash -lc "bash -lc 'git add .ralph_logs/iter_16.log && git commit --amend --no-edit'" in /mnt/e/personal_project/rust_plc succeeded in 579ms:
[ralph/phase1-2-parser-and-verification 38c6e3d] feat: [US-015] - [实现活性检查器（Liveness Checker）]
 Date: Wed Feb 11 12:35:50 2026 +0800
 6 files changed, 3469 insertions(+), 4 deletions(-)
 create mode 100644 .ralph_logs/iter_16.log
 create mode 100644 src/verification/liveness.rs

thinking
**Confirming safe use of update plan**
Plan update
  ✓ Inspect PRD US-015 requirements and current verification/state-machine code paths relevant to liveness checks
  ✓ Implement liveness verification module and expose it in verification mod, including diagnostics format and deadlock/SCC/unreachable checks
  ✓ Add/adjust unit tests for PRD 5.5.1-5.5.3 pass cases and missing-timeout fail case
  ✓ Run quality checks, update prd.json+progress.txt, and commit with required message

thinking
**Deciding file reference lines**
exec
/bin/bash -lc "bash -lc 'nl -ba src/verification/liveness.rs | sed -n \"1,260p\"; echo \"---\"; nl -ba src/verification/liveness.rs | sed -n \"260,520p\"; echo \"---\"; nl -ba src/verification/mod.rs; echo \"---\"; nl -ba progress.txt | tail -n 90; echo \"---\"; nl -ba prd.json | rg -n \"US-015|\\\"passes\\\"\"'" in /mnt/e/personal_project/rust_plc succeeded in 51ms:
     1	use crate::ast::{
     2	    ComparisonOperator, LiteralValue, OnCompleteDirective, PlcProgram, StepStatement, WaitStatement,
     3	};
     4	use crate::ir::{StateMachine, TransitionGuard};
     5	use petgraph::algo::kosaraju_scc;
     6	use petgraph::graph::DiGraph;
     7	use petgraph::visit::EdgeRef;
     8	use std::collections::{HashMap, HashSet};
     9	use std::fmt;
    10	
    11	#[derive(Debug, Clone, PartialEq, Eq)]
    12	pub struct LivenessDiagnostic {
    13	    pub line: usize,
    14	    pub reason: String,
    15	    pub physical_analysis: String,
    16	    pub suggestion: String,
    17	}
    18	
    19	impl fmt::Display for LivenessDiagnostic {
    20	    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {

thinking
**Confirming line numbers for references**
exec
/bin/bash -lc "bash -lc 'rg -n \"pub fn verify_liveness|check_unreachable_on_complete|check_strongly_connected_components|passes_prd_5_5_1_to_5_5_3_liveness_examples|fails_when_wait_has_no_timeout_and_no_allow_indefinite_wait|allows_unreachable_when_all_race_paths_jump_away\" src/verification/liveness.rs; nl -ba src/verification/mod.rs; rg -n \"US-015|passes\" prd.json | head -n 5; rg -n \"US-015|Codebase Patterns|Liveness checks should combine\" progress.txt | head -n 5'" in /mnt/e/personal_project/rust_plc succeeded in 51ms:
59:pub fn verify_liveness(
67:    check_unreachable_on_complete(program, &mut diagnostics);
69:    check_strongly_connected_components(program, state_machine, &step_line_map, &mut diagnostics);
103:fn check_unreachable_on_complete(program: &PlcProgram, diagnostics: &mut Vec<LivenessDiagnostic>) {
166:fn check_strongly_connected_components(
471:    fn passes_prd_5_5_1_to_5_5_3_liveness_examples() {
526:    fn fails_when_wait_has_no_timeout_and_no_allow_indefinite_wait() {
659:    fn allows_unreachable_when_all_race_paths_jump_away() {
     1	pub mod causality;
     2	pub mod liveness;
     3	pub mod timing;
20:      "passes": true,
37:      "passes": true,
56:      "passes": true,
74:      "passes": true,
95:      "passes": true,
2:## Codebase Patterns
18:- Liveness checks should combine AST metadata (`allow_indefinite_wait`, `on_complete`) with StateMachine transitions; IR guards alone cannot reconstruct all wait exemptions.
264:## [2026-02-11 12:34:08 CST] - US-015

thinking
**Extracting targeted lines for US-015**
exec
/bin/bash -lc "bash -lc 'nl -ba prd.json | sed -n \"266,288p\"'" in /mnt/e/personal_project/rust_plc succeeded in 51ms:
   266	    {
   267	      "id": "US-015",
   268	      "title": "实现活性检查器（Liveness Checker）",
   269	      "description": "作为开发者，我需要活性验证，检测状态机中的潜在死锁。",
   270	      "acceptanceCriteria": [
   271	        "src/verification/liveness.rs 实现死锁检测",
   272	        "检查所有 wait 语句是否有 timeout 或 allow_indefinite_wait",
   273	        "检查非终态状态是否有零出边",
   274	        "on_complete: goto 形成的循环（如 ready -> init -> ready）是合法的，不算死锁",
   275	        "on_complete: unreachable 的 task 仅在所有内部路径以 goto 结尾时有效；若存在可到达 on_complete 的路径则报错",
   276	        "检查是否存在不包含 allow_indefinite_wait 或 timeout 出边的强连通分量",
   277	        "失败时：报告位置、原因、物理分析和修复建议（匹配 PRD 3.2.2 节错误格式）",
   278	        "错误信息为中文，包含行号",
   279	        "单元测试：验证 PRD 5.5.1-5.5.3 节示例（有 timeout 和 allow_indefinite_wait）活性通过",
   280	        "单元测试：验证 wait 无 timeout 且无 allow_indefinite_wait 时活性失败",
   281	        "类型检查通过"
   282	      ],
   283	      "priority": 15,
   284	      "passes": true,
   285	      "notes": ""

thinking
**Finalizing commit with latest changes**
