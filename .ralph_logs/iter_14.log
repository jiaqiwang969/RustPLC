OpenAI Codex v0.98.0 (research preview)
--------
workdir: /mnt/e/personal_project/rust_plc
model: gpt-5.3-codex
provider: codex
approval: never
sandbox: danger-full-access
reasoning effort: high
reasoning summar
Ralph completed all tasks!
Completed at iteration 1 of 1

--------
user
# Ralph Agent Instructions

You are an autonomous coding agent working on a software project.

## Your Task

1. Read the PRD at `prd.json` (in the same directory as this file)
2. Read the progress log at `progress.txt` (check Codebase Patterns section first)
3. Check you're on the correct branch from PRD `branchName`. If not, check it out or create from main.
4. Pick the **highest priority** user story where `passes: false`
5. Implement that single user story
6. Run quality checks (e.g., typecheck, lint, test - use whatever your project requires)
7. Update AGENTS.md files if you discover reusable patterns (see below)
8. If checks pass, commit ALL changes with message: `feat: [Story ID] - [Story Title]`
9. Update the PRD to set `passes: true` for the completed story
10. Append your progress to `progress.txt`

## Progress Report Format

APPEND to progress.txt (never replace, always append):
```
## [Date/Time] - [Story ID]
Thread: https://ampcode.com/threads/$AMP_CURRENT_THREAD_ID
- What was implemented
- Files changed
- **Learnings for future iterations:**
  - Patterns discovered (e.g., "this codebase uses X for Y")
  - Gotchas encountered (e.g., "don't forget to update Z when changing W")
  - Useful context (e.g., "the evaluation panel is in component X")
---
```

Include the thread URL so future iterations can use the `read_thread` tool to reference previous work if needed.

The learnings section is critical - it helps future iterations avoid repeating mistakes and understand the codebase better.

## Consolidate Patterns

If you discover a **reusable pattern** that future iterations should know, add it to the `## Codebase Patterns` section at the TOP of progress.txt (create it if it doesn't exist). This section should consolidate the most important learnings:

```
## Codebase Patterns
- Example: Use `sql<number>` template for aggregations
- Example: Always use `IF NOT EXISTS` for migrations
- Example: Export types from actions.ts for UI components
```

Only add patterns that are **general and reusable**, not story-specific details.

## Update AGENTS.md Files

Before committing, check if any edited files have learnings worth preserving in nearby AGENTS.md files:

1. **Identify directories with edited files** - Look at which directories you modified
2. **Check for existing AGENTS.md** - Look for AGENTS.md in those directories or parent directories
3. **Add valuable learnings** - If you discovered something future developers/agents should know:
   - API patterns or conventions specific to that module
   - Gotchas or non-obvious requirements
   - Dependencies between files
   - Testing approaches for that area
   - Configuration or environment requirements

**Examples of good AGENTS.md additions:**
- "When modifying X, also update Y to keep them in sync"
- "This module uses pattern Z for all API calls"
- "Tests require the dev server running on PORT 3000"
- "Field names must match the template exactly"

**Do NOT add:**
- Story-specific implementation details
- Temporary debugging notes
- Information already in progress.txt

Only update AGENTS.md if you have **genuinely reusable knowledge** that would help future work in that directory.

## Quality Requirements

- ALL commits must pass your project's quality checks (typecheck, lint, test)
- Do NOT commit broken code
- Keep changes focused and minimal
- Follow existing code patterns

## Browser Testing (Required for Frontend Stories)

For any story that changes UI, you MUST verify it works in the browser:

1. Load the `dev-browser` skill
2. Navigate to the relevant page
3. Verify the UI changes work as expected
4. Take a screenshot if helpful for the progress log

A frontend story is NOT complete until browser verification passes.

## Stop Condition

After completing a user story, check if ALL stories have `passes: true`.

If ALL stories are complete and passing, reply with:
<promise>COMPLETE</promise>

If there are still stories with `passes: false`, end your response normally (another iteration will pick up the next story).

## Important

- Work on ONE story per iteration
- Commit frequently
- Keep CI green
- Read the Codebase Patterns section in progress.txt before starting

mcp startup: no servers

thinking
**Planning multi-step inspection**
exec
/bin/bash -lc "bash -lc 'ls -la'" in /mnt/e/personal_project/rust_plc succeeded in 51ms:
total 112
drwxrwxrwx 1 liangyuhang liangyuhang  4096 Feb 11 10:12 .
drwxrwxrwx 1 liangyuhang liangyuhang  4096 Feb 10 20:47 ..
drwxrwxrwx 1 liangyuhang liangyuhang  4096 Feb 11 00:34 .claude
drwxrwxrwx 1 liangyuhang liangyuhang  4096 Feb 11 01:09 .codex
drwxrwxrwx 1 liangyuhang liangyuhang  4096 Feb 11 10:18 .git
-rwxrwxrwx 1 liangyuhang liangyuhang     8 Feb 11 01:17 .gitignore
drwxrwxrwx 1 liangyuhang liangyuhang  4096 Feb 11 11:47 .ralph_logs
-rwxrwxrwx 1 liangyuhang liangyuhang  4307 Feb 11 01:14 CODEX.md
-rwxrwxrwx 1 liangyuhang liangyuhang  7674 Feb 11 09:01 Cargo.lock
-rwxrwxrwx 1 liangyuhang liangyuhang   249 Feb 11 09:00 Cargo.toml
drwxrwxrwx 1 liangyuhang liangyuhang  4096 Feb 11 10:11 examples
-rwxrwxrwx 1 liangyuhang liangyuhang 18676 Feb 11 10:13 prd.json
-rwxrwxrwx 1 liangyuhang liangyuhang 38276 Feb 11 00:28 prd.md
-rwxrwxrwx 1 liangyuhang liangyuhang 21704 Feb 11 10:13 progress.txt
-rwxrwxrwx 1 liangyuhang liangyuhang  4307 Jan 23 10:30 prompt.md
-rwxrwxrwx 1 liangyuhang liangyuhang  3816 Feb 11 01:14 ralph.sh
drwxrwxrwx 1 liangyuhang liangyuhang  4096 Feb 11 01:18 src
drwxrwxrwx 1 liangyuhang liangyuhang  4096 Feb 11 10:12 target
drwxrwxrwx 1 liangyuhang liangyuhang  4096 Feb 11 10:12 tests

thinking
**Planning multi-step read progress**
Plan update
  → Inspect PRD/progress and determine target story + branch
  • Implement highest-priority failing story and add/adjust tests
  • Run quality checks, update docs/logs, commit, and mark PRD pass
exec
/bin/bash -lc "bash -lc 'sed -n \"1,220p\" progress.txt'" in /mnt/e/personal_project/rust_plc succeeded in 51ms:
# Ralph Progress Log
## Codebase Patterns
- TopologyGraph JSON 调试依赖 `petgraph` 的 `serde-1` feature；若缺失会导致 DiGraph 无法序列化。
- In parser-to-AST lowering, unwrap wrapper PEG rules (e.g., `constraint_declaration`, `step_statement`) before matching concrete rule kinds, or valid nodes can be silently skipped.
- Keep public module declarations centralized in `src/lib.rs`; implementation files live at `src/<module>/mod.rs`.
- For early story scaffolding, keep module placeholders compiling so CLI and library can evolve incrementally without breaking builds.
- Model DSL enums with `serde(rename_all = "snake_case")` and tagged enums so serialized AST tokens stay aligned with DSL keywords.
- In pest grammars, define silent `WHITESPACE` and `COMMENT` rules so inline `#` comments and multiline section formatting parse without extra boilerplate.
- For block-style DSL sections, parse optional `reason: "..."` clauses directly in each declaration rule so indented multiline annotations remain valid without separate line handling.
- In nested `parallel`/`race` grammar, require branch bodies to consume concrete statements so step-level directives are not misparsed as branch labels.
- In semantic topology lowering, treat `connected_to` as upstream linkage (`target -> current`) so causality traversals follow physical flow direction.
- Preserve directive line metadata in AST (e.g., `GotoDirective.line`, `TaskDeclaration.on_complete_line`) so semantic passes can report precise line-numbered errors without reparsing source text.
- For constraint semantic validation, seed known device states from device-type defaults plus `sensor.detects` references before checking `safety` state expressions.
- Use `PlcError` constructors (`undefined_reference` / `type_mismatch` / `duplicate_definition`) so diagnostics share unified ERROR blocks with `位置/原因/建议` fields.
- For end-to-end compilation paths (CLI/tests), run all four semantic builders and aggregate their errors so users get complete diagnostics in one run.
Started: Wed Feb 11 01:14:39 CST 2026
---
## [2026-02-11 01:19:50 CST] - US-001
Thread: https://ampcode.com/threads/$AMP_CURRENT_THREAD_ID
- What was implemented

thinking
**Planning PRD inspection**
exec
/bin/bash -lc "bash -lc 'python3 - <<\"PY\"
import json
from pathlib import Path
p=json.loads(Path(\"prd.json\").read_text())
print(\"branch\",p.get(\"branchName\"))
for s in p.get(\"userStories\",[]):
    if not s.get(\"passes\",False):
        print(s.get(\"id\"), s.get(\"title\"), \"priority\", s.get(\"priority\"), \"passes\", s.get(\"passes\"))
PY'" in /mnt/e/personal_project/rust_plc succeeded in 51ms:
branch ralph/phase1-2-parser-and-verification
US-013 实现因果链检查器（Causality Checker） priority 13 passes False
US-014 实现时序检查器（Timing Checker） priority 14 passes False
US-015 实现活性检查器（Liveness Checker） priority 15 passes False
US-016 实现安全性检查器（Safety Checker + Z3） priority 16 passes False
US-017 集成所有验证并进行端到端测试 priority 17 passes False

thinking
**Checking and managing Git branch**
exec
/bin/bash -lc "bash -lc 'git status --short --branch'" in /mnt/e/personal_project/rust_plc succeeded in 138ms:
## ralph/phase1-2-parser-and-verification
 M .ralph_logs/iter_12.log
?? .ralph_logs/iter_13.log
?? .ralph_logs/iter_14.log

thinking
**Prioritizing highest-impact task**
exec
/bin/bash -lc "bash -lc 'python3 - <<\"PY\"
import json
from pathlib import Path
p=json.loads(Path(\"prd.json\").read_text())
for s in p[\"userStories\"]:
    if s[\"id\"]==\"US-013\":
        import pprint
        pprint.pp(s)
PY'" in /mnt/e/personal_project/rust_plc succeeded in 51ms:
{'id': 'US-013',
 'title': '实现因果链检查器（Causality Checker）',
 'description': '作为开发者，我需要因果链验证，检查物理因果链在拓扑图中是否连通。',
 'acceptanceCriteria': ['src/verification/causality.rs 实现因果链验证',
                        '对每条 causality 约束（如 Y0 -> valve_A -> cyl_A -> '
                        'sensor_A_ext），使用 petgraph 可达性验证路径存在',
                        '对 tasks 中的每个 action+wait 对，推断隐式因果链并验证连通性',
                        '失败时：报告断裂的链路、期望链路、实际链路和修复建议（匹配 PRD 3.2.4 节错误格式）',
                        '错误信息为中文，包含行号',
                        '单元测试：验证 PRD 5.4 节示例的因果链通过',
                        '单元测试：验证缺少连接时（如 valve_A 未连接到 cyl_A）因果链失败',
                        '类型检查通过'],
 'priority': 13,
 'passes': False,
 'notes': ''}

thinking
**Inspecting verification module**
exec
/bin/bash -lc "bash -lc 'find src -maxdepth 3 -type f | sort'" in /mnt/e/personal_project/rust_plc succeeded in 51ms:
src/ast/mod.rs
src/error/mod.rs
src/ir/mod.rs
src/lib.rs
src/main.rs
src/parser/mod.rs
src/parser/plc.pest
src/semantic/mod.rs

thinking
**Checking for additional agent docs**
exec
/bin/bash -lc "bash -lc 'find .. -name AGENTS.md -print'" in /mnt/e/personal_project/rust_plc
thinking
**Noting command hang due to parent**

thinking
**Running targeted repository search**
exec
/bin/bash -lc "bash -lc 'find . -name AGENTS.md -print'" in /mnt/e/personal_project/rust_plc succeeded in 919ms:


thinking
**Inspecting core modules for architecture**
exec
/bin/bash -lc "bash -lc 'sed -n \"1,260p\" src/ir/mod.rs'" in /mnt/e/personal_project/rust_plc succeeded in 51ms:
use petgraph::graph::{DiGraph, NodeIndex};
use serde::{Deserialize, Serialize};
use std::collections::BTreeMap;

#[derive(Debug, Clone, Serialize, Deserialize, PartialEq)]
pub struct Device {
    pub name: String,
    pub kind: DeviceKind,
}

#[derive(Debug, Clone, Serialize, Deserialize, PartialEq)]
#[serde(rename_all = "snake_case")]
pub enum DeviceKind {
    DigitalOutput,
    DigitalInput,
    SolenoidValve,
    Cylinder,
    Sensor,
    Motor,
}

thinking
**Identifying need for semantic module**
exec
/bin/bash -lc "bash -lc 'sed -n \"1,420p\" src/semantic/mod.rs'" in /mnt/e/personal_project/rust_plc succeeded in 51ms:
use crate::ast::{
    ActionStatement, BinaryValue as AstBinaryValue, ComparisonOperator, ConditionExpression,
    ConstraintsSection, DeviceType, DurationValue, GotoDirective, LiteralValue,
    OnCompleteDirective, ParallelBlock, PlcProgram, RaceBlock, SafetyRelation as AstSafetyRelation,
    StepStatement, TaskDeclaration, TasksSection, TimeUnit, TimeoutDirective,
    TimingRelation as AstTimingRelation, TimingTarget, TopologySection, WaitStatement,
};
use crate::error::PlcError;
use crate::ir::{
    ActionKind, ActionRef, ActionTiming, BinaryValue as IrBinaryValue, CausalityChain,
    ConnectionType, ConstraintSet, Device, DeviceKind, SafetyRelation as IrSafetyRelation,
    SafetyRule, State, StateExpr, StateMachine, TimeInterval, TimerOperation, TimerOperationKind,
    TimingModel, TimingRelation as IrTimingRelation, TimingRule, TimingScope, TopologyGraph,
    Transition, TransitionAction, TransitionGuard,
};
use petgraph::graph::NodeIndex;
use std::collections::{BTreeMap, HashMap, HashSet};

#[derive(Debug, Clone)]
struct DeviceNode {

thinking
**Considering search strategies for causality**
exec
/bin/bash -lc "bash -lc 'rg -n \"causality|Causality|build_constraint_set_from_ast|collect_task|wait|action\" src/semantic/mod.rs'" in /mnt/e/personal_project/rust_plc succeeded in 51ms:
10:    ActionKind, ActionRef, ActionTiming, BinaryValue as IrBinaryValue, CausalityChain,
34:    build_constraint_set_from_ast(&program.topology, &program.constraints, &program.tasks)
104:pub fn build_constraint_set_from_ast(
114:    let task_steps = collect_task_steps(tasks);
159:    for causality in &constraints.causality {
160:        for node in &causality.chain {
163:                causality.line,
164:                "causality",
170:        constraint_set.causality.push(CausalityChain {
171:            devices: causality
176:            reason: causality.reason.clone(),
197:            let mut actions = Vec::new();
198:            collect_actions(&step.statements, &mut actions);
200:            for action in actions {
201:                if let Some(action_timing) = action_to_timing(
205:                    &action,
209:                    insert_action_timing(&mut intervals, action_timing);
308:                    analyzed.actions.clone(),
323:                    analyzed.actions.clone(),
339:                        analyzed.actions.clone(),

thinking
**Reviewing module declarations**
exec
/bin/bash -lc "bash -lc 'cat src/lib.rs'" in /mnt/e/personal_project/rust_plc succeeded in 51ms:
pub mod ast;
pub mod error;
pub mod ir;
pub mod parser;
pub mod semantic;

thinking
**Planning verification module addition**
exec
/bin/bash -lc "bash -lc 'sed -n \"1,320p\" src/error/mod.rs'" in /mnt/e/personal_project/rust_plc succeeded in 51ms:
use std::error::Error;
use std::fmt;

const DEFAULT_FILE: &str = "<input>";

#[derive(Debug, Clone, PartialEq, Eq)]
pub struct SourceLocation {
    pub file: String,
    pub line: usize,
    pub column: usize,
}

impl SourceLocation {
    pub fn new(file: impl Into<String>, line: usize, column: usize) -> Self {
        Self {
            file: file.into(),
            line,
            column,
        }
    }

thinking
**Inspecting AST module structure**
exec
/bin/bash -lc "bash -lc 'sed -n \"1,420p\" src/ast/mod.rs'" in /mnt/e/personal_project/rust_plc succeeded in 50ms:
use serde::{Deserialize, Serialize};

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct PlcProgram {
    pub topology: TopologySection,
    pub constraints: ConstraintsSection,
    pub tasks: TasksSection,
}

#[derive(Debug, Clone, Serialize, Deserialize, Default)]
pub struct TopologySection {
    pub devices: Vec<DeviceDeclaration>,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct DeviceDeclaration {
    #[serde(default)]
    pub line: usize,
    pub name: String,
    pub device_type: DeviceType,

thinking
**Planning verification tests**
exec
/bin/bash -lc "bash -lc 'python3 - <<\"PY\"
import json
from pathlib import Path
p=json.loads(Path(\"prd.json\").read_text())
print(p.keys())
print(\"stories\",len(p.get(\"userStories\",[])))
for k in [\"projectName\",\"goal\",\"branchName\"]:
    print(k,p.get(k))
PY'" in /mnt/e/personal_project/rust_plc succeeded in 51ms:
dict_keys(['project', 'branchName', 'description', 'userStories'])
stories 17
projectName None
goal None
branchName ralph/phase1-2-parser-and-verification
 succeeded in 1m 35s:
../CCD6检测/AGENTS.md
../codex/AGENTS.md
../codex-main/AGENTS.md
../codex分析/AGENTS.md
../codex分析/codex-rs/tui/src/bottom_pane/AGENTS.md
../codex教学/codex/AGENTS.md
../OPENPLC/OpenPLC_v3-master/AGENTS.md
../ralph/AGENTS.md
../skills/_tmp/Agent-Skills-for-Context-Engineering/examples/digital-brain-skill/agents/AGENTS.md
../spec-kit-main/AGENTS.md
../version_manage/AGENTS.md
../vibe-kanban/AGENTS.md
../vibe-kanban/docs/AGENTS.md
../中铁建表格拆分测试/AGENTS.md
../图像工程与仿真/AGENTS.md

thinking
**Inspecting product description details**
exec
/bin/bash -lc "bash -lc 'python3 - <<\"PY\"
import json
from pathlib import Path
p=json.loads(Path(\"prd.json\").read_text())
print(p[\"description\"][:5000])
PY'" in /mnt/e/personal_project/rust_plc succeeded in 51ms:
Phase 1+2: DSL 解析器、语义分析器与形式化验证引擎 — 解析 .plc 文件生成 AST，构建 IR（TopologyGraph、StateMachine、ConstraintSet、TimingModel），并完成四项形式化验证（Safety、Liveness、Timing、Causality）

thinking
**Inspecting error format in spec**
exec
/bin/bash -lc "bash -lc 'rg -n \"因果|Causality|3\\.2\\.4|验证器|causality\" prd.md'" in /mnt/e/personal_project/rust_plc succeeded in 51ms:
13:用 Rust 替代传统 PLC 编程语言（梯形图/ST/FBD），建立一套 **"程序即结构"** 的工业控制系统。用户用极简的领域专用语言（DSL）描述物理拓扑、控制逻辑和安全约束，系统在编译期自动完成形式化验证（安全性、活性、时序、因果链），验证通过后生成确定性 Rust 执行代码。
136:#### 3.2.4 因果链闭环（Causality）
143:- 编译器发现从 Y0 到 sensor_A_ext 的因果链断裂
148:- 不可达 = 因果链断裂 = 编译失败
153:ERROR [causality] 因果链断裂
187:        --> ConstraintSet  (safety/timing/causality 约束)
196:    [x] Causality: 因果链闭环检查
216:    超时检测 -> 因果回溯 -> 诊断报告
235:    |--- ConstraintSet   (safety/timing/causality 约束)
243:    |-- Causality Checker --> 图可达性: output --*--> sensor
249:    |--- diagnostics.rs   (运行时因果诊断逻辑)
401:# ===== 因果链声明 (Causality) =====
402:causality: Y0 -> valve_A -> cyl_A -> sensor_A_ext
405:causality: Y1 -> valve_B -> cyl_B -> sensor_B_ext
417:| causality | A -> B -> C -> D | 从 A 到 D 的物理因果链必须连通 |
643:causality: Y0 -> valve_A -> cyl_A -> sensor_A_ext
644:causality: Y1 -> valve_B -> cyl_B -> sensor_B_ext
753:      C4. Causality 检查
754:          - 对每条 causality 链
756:          - 对每个 action+wait 对，推断隐式因果链并验证

thinking
**Inspecting error format semantics**
exec
/bin/bash -lc "bash -lc 'sed -n \"120,190p\" prd.md'" in /mnt/e/personal_project/rust_plc succeeded in 51ms:
- 收集每个 step 涉及的所有物理动作的时间参数
- 计算最长完成时间（最坏情况关键路径）
- 与用户声明的时序约束对比
- 最长完成时间 > 约束时间 = 编译失败（最坏情况下无法按时完成）

**错误输出示例**：

```
ERROR [timing] 时序包络违反
  约束: step_1 must_complete_within 100ms (main.plc:30)
  分析: step_1 包含动作 extend cyl_A
        cyl_A.stroke_time = 200ms (main.plc:6)
        最长完成时间 = 200ms > 约束 100ms
  结论: 最坏情况下无法在 100ms 内完成此动作
```

#### 3.2.4 因果链闭环（Causality）

**目标**：验证从输出到传感器反馈的物理路径是否完整连通。


thinking
**Planning pipeline verification section**
exec
/bin/bash -lc "bash -lc 'sed -n \"720,790p\" prd.md'" in /mnt/e/personal_project/rust_plc succeeded in 51ms:
      C1. Safety 检查
          - 遍历所有 conflicts_with / requires 约束
          - 对每条约束生成 Z3 公式
          - 分层验证策略:
            1. 首先尝试 k-induction (归纳证明)，若成立则获得完备证明
            2. 若 k-induction 无法收敛，回退到 BMC 搜索反例，
               展开深度 = 状态节点数 (用户可通过 bmc_max_depth 配置上限，
               含 SCC 时至少展开 SCC 节点数 + 1 层)
            3. 状态空间较小时 (状态数 < 可配置阈值) 直接穷举
          - 验证结论分两级:
            完备证明 (k-induction/穷举): "Safety 已完备证明"
            有界验证 (仅 BMC): "WARNING: 深度 N 内未发现反例，未获完备证明"
      C2. Liveness 检查
          - 遍历所有 wait 语句
          - 无 timeout 且无 allow_indefinite_wait -> 报错
          - 检查状态图是否存在无出边的非终态
            (通过 on_complete: goto 形成的常驻循环是合法的，不算死锁)
          - on_complete: unreachable 的 task 不算"无出边非终态"，
            但编译器必须验证该 task 内所有执行路径均以 goto 结尾；
            若存在未跳转的路径，报错："unreachable 标记无效，

thinking
**Reviewing sample section usage**
exec
/bin/bash -lc "bash -lc 'sed -n \"600,700p\" prd.md'" in /mnt/e/personal_project/rust_plc succeeded in 51ms:
[topology]

device Y0: digital_output
device Y1: digital_output
device X0: digital_input
device X1: digital_input
device X2: digital_input
device X3: digital_input
device X4: digital_input

device start_button: digital_input {
    connected_to: X4
    debounce: 20ms
}

device valve_A: solenoid_valve {
    connected_to: Y0
    response_time: 20ms
}
device valve_B: solenoid_valve {

thinking
**Inspecting wait condition parsing**
exec
/bin/bash -lc "bash -lc 'rg -n \"parse_wait|wait_statement|ConditionExpression|condition\" src/parser/mod.rs'" in /mnt/e/personal_project/rust_plc succeeded in 51ms:
3:    ConditionExpression, ConstraintsSection, DeviceAttributes, DeviceDeclaration, DeviceType,
411:        Rule::wait_statement => Ok(StepStatement::Wait(parse_wait_statement(pair)?)),
416:        Rule::allow_indefinite_wait_statement => Ok(StepStatement::AllowIndefiniteWait(
493:fn parse_wait_statement(pair: Pair<Rule>) -> Result<WaitStatement, PlcError> {
501:            Rule::condition_operand => {
506:            Rule::condition_value => value = Some(parse_condition_value(part)?),
512:        condition: ConditionExpression {
529:fn parse_condition_value(pair: Pair<Rule>) -> Result<LiteralValue, PlcError> {
exec
/bin/bash -lc "bash -lc 'sed -n \"460,560p\" src/parser/mod.rs'" in /mnt/e/personal_project/rust_plc succeeded in 51ms:
            let value_pair = parts
                .next()
                .ok_or_else(|| PlcError::parse(line, "set 缺少 on/off 值"))?;
            let value = parse_binary_value(value_pair)?;
            Ok(ActionStatement::Set { target, value })
        }
        Rule::action_log => {
            let message_pair = action
                .into_inner()
                .next()
                .ok_or_else(|| PlcError::parse(line, "log 缺少消息字符串"))?;
            let message = parse_string_literal(message_pair)?;
            Ok(ActionStatement::Log { message })
        }
        rule => Err(PlcError::parse(
            line,
            format!("不支持的 action 命令: {rule:?}"),
        )),
    }
}

thinking
**Assessing line number sourcing for errors**
exec
/bin/bash -lc "bash -lc 'sed -n \"1,260p\" tests/examples_integration.rs'" in /mnt/e/personal_project/rust_plc succeeded in 51ms:
use rust_plc::error::PlcError;
use rust_plc::parser::parse_plc;
use rust_plc::semantic::{
    build_constraint_set, build_state_machine, build_timing_model, build_topology_graph,
};
use serde_json::{Value, json};
use std::fs;
use std::path::{Path, PathBuf};
use std::process::Command;

fn example_path(file_name: &str) -> PathBuf {
    Path::new(env!("CARGO_MANIFEST_DIR"))
        .join("examples")
        .join(file_name)
}

fn read_example(file_name: &str) -> String {
    let path = example_path(file_name);
    fs::read_to_string(&path)
        .unwrap_or_else(|err| panic!("failed to read example {}: {err}", path.display()))

thinking
**Designing causality verification**
exec
/bin/bash -lc "bash -lc 'rg -n \"verification/causality|Causality Checker|verify_causality|causality.rs|验证\" prd.md'" in /mnt/e/personal_project/rust_plc succeeded in 51ms:
1:# RustPLC — 基于形式化验证的工业控制系统
13:用 Rust 替代传统 PLC 编程语言（梯形图/ST/FBD），建立一套 **"程序即结构"** 的工业控制系统。用户用极简的领域专用语言（DSL）描述物理拓扑、控制逻辑和安全约束，系统在编译期自动完成形式化验证（安全性、活性、时序、因果链），验证通过后生成确定性 Rust 执行代码。
39:| R4 | 编译时自动转成 Rust，自动进行形式化验证 | P0 | Phase 2-3 |
42:### 3.2 形式化验证的四项核心检查
50:- 编译器对所有可达状态进行验证，证明不存在两缸同时伸出的状态
53:**验证方法**：
55:- 采用分层验证策略：
62:  3. 对于状态空间较小的系统（状态数 < 可配置阈值），直接进行穷举验证
65:- 验证结论分两级：
67:  - **有界验证**（仅 BMC 通过）：输出"WARNING: Safety 在深度 N 内未发现反例，但未获得完备证明。建议增大 bmc_max_depth 以提升有界覆盖，或调整模型以帮助 k-induction 收敛"
91:**验证方法**：
94:- 标记为 `on_complete: unreachable` 的 task 视为"所有出边均为内部跳转的已封闭节点"，不算无出边的非终态（前提：该 task 内所有执行路径都以 goto 或 timeout->goto 结尾，编译器会验证这一前提，若存在未跳转的路径则报错）
119:**验证方法**：
138:**目标**：验证从输出到传感器反馈的物理路径是否完整连通。
145:**验证方法**：
191:  Phase C: 形式化验证引擎
195:    [x] Timing:    时序包络验证
197:    验证失败 -> 人类可读的错误报告 + 修复建议
198:    验证通过 -> 继续
240:    |-- Safety Checker    --> Z3: k-induction 或 BMC 验证不存在冲突

thinking
**Planning custom API design**
exec
/bin/bash -lc "bash -lc 'cat CODEX.md'" in /mnt/e/personal_project/rust_plc succeeded in 51ms:
# Ralph Agent Instructions

You are an autonomous coding agent working on a software project.

## Your Task

1. Read the PRD at `prd.json` (in the same directory as this file)
2. Read the progress log at `progress.txt` (check Codebase Patterns section first)
3. Check you're on the correct branch from PRD `branchName`. If not, check it out or create from main.
4. Pick the **highest priority** user story where `passes: false`
5. Implement that single user story
6. Run quality checks (e.g., typecheck, lint, test - use whatever your project requires)
7. Update AGENTS.md files if you discover reusable patterns (see below)
8. If checks pass, commit ALL changes with message: `feat: [Story ID] - [Story Title]`
9. Update the PRD to set `passes: true` for the completed story
10. Append your progress to `progress.txt`

## Progress Report Format

APPEND to progress.txt (never replace, always append):

thinking
**Inspecting semantic tests for samples**
exec
/bin/bash -lc "bash -lc 'sed -n \"1460,1820p\" src/semantic/mod.rs'" in /mnt/e/personal_project/rust_plc succeeded in 51ms:
[tasks]
"#;

        let program = parse_plc(input).expect("测试输入应能解析为 AST");
        let errors = build_topology_graph(&program).expect_err("不兼容连接类型应报错");

        assert_eq!(errors.len(), 1);
        assert_eq!(errors[0].line(), 14);
        assert!(
            errors[0].to_string().contains("sensor") && errors[0].to_string().contains("cylinder"),
            "错误消息应包含不兼容的设备类型"
        );
    }

    #[test]
    fn builds_constraint_set_and_timing_model_from_prd_5_4_example() {
        let input = r#"
[topology]

device Y0: digital_output

thinking
**Planning verification module and tests**
exec
/bin/bash -lc "bash -lc 'cat Cargo.toml'" in /mnt/e/personal_project/rust_plc succeeded in 50ms:
[package]
name = "rust_plc"
version = "0.1.0"
edition = "2024"

[dependencies]
pest = "2.7"
pest_derive = "2.7"
petgraph = { version = "0.6", features = ["serde-1"] }
serde = { version = "1", features = ["derive"] }
serde_json = "1"
thiserror = "1"

thinking
**Inspecting parser for task constraints**
exec
/bin/bash -lc "bash -lc 'rg -n \"line:\" src/parser/mod.rs | head -n 40'" in /mnt/e/personal_project/rust_plc succeeded in 51ms:
844:    line: usize,

thinking
**Inspecting parse device behavior**
exec
/bin/bash -lc "bash -lc 'sed -n \"1,460p\" src/parser/mod.rs'" in /mnt/e/personal_project/rust_plc succeeded in 51ms:
use crate::ast::{
    ActionStatement, BinaryValue, Branch, CausalityConstraint, ComparisonOperator,
    ConditionExpression, ConstraintsSection, DeviceAttributes, DeviceDeclaration, DeviceType,
    DurationValue, GotoDirective, LiteralValue, MeasuredValue, OnCompleteDirective, ParallelBlock,
    PlcProgram, RaceBlock, RaceBranch, SafetyConstraint, SafetyRelation, StateReference,
    StepDeclaration, StepStatement, TaskDeclaration, TasksSection, TimeUnit, TimeoutDirective,
    TimingConstraint, TimingRelation, TimingTarget, TopologySection, WaitStatement,
};
use crate::error::PlcError;
use pest::Parser;
use pest::error::LineColLocation;
use pest::iterators::Pair;

#[derive(pest_derive::Parser)]
#[grammar = "parser/plc.pest"]
pub struct PlcParser;

pub fn parse_topology(input: &str) -> Result<(), pest::error::Error<Rule>> {
    PlcParser::parse(Rule::topology_file, input).map(|_| ())
}

thinking
**Analyzing graph topology limitations**
exec
/bin/bash -lc "bash -lc 'rg -n \"detects|connected_to|add_connection|ConnectionType::Logical|Logical\" src/semantic/mod.rs'" in /mnt/e/personal_project/rust_plc succeeded in 50ms:
57:        let Some(target_name) = device.attributes.connected_to.as_deref() else {
67:                    "设备 {} 的 connected_to 引用了该名称，请先定义后再连接",
84:                format!("设备 {} 的 connected_to", device.name),
93:        // `A connected_to B` means B provides upstream linkage into A.
94:        topology_graph.add_connection(target_node.index, current_node.index, connection_type);
503:        if let Some(detects) = &device.attributes.detects {
505:                .entry(detects.device.clone())
507:                .insert(detects.state.clone());
1278:        | (DeviceKind::DigitalOutput, DeviceKind::DigitalOutput) => Some(ConnectionType::Logical),
1320:    connected_to: X4,
1325:    connected_to: Y2
1331:    connected_to: Y0,
1337:    connected_to: Y1,
1344:    connected_to: valve_A,
1352:    connected_to: valve_B,
1361:    connected_to: X0,
1362:    detects: cyl_A.extended
1367:    connected_to: X1,
1368:    detects: cyl_A.retracted
1373:    connected_to: X2,

thinking
**Assessing topology edge validation**
exec
/bin/bash -lc "bash -lc 'rg -n \"edge_count|node_count|add_connection|topology\" src/semantic/mod.rs | head -n 80'" in /mnt/e/personal_project/rust_plc succeeded in 51ms:
25:pub fn build_topology_graph(program: &PlcProgram) -> Result<TopologyGraph, Vec<PlcError>> {
26:    build_topology_from_ast(&program.topology)
34:    build_constraint_set_from_ast(&program.topology, &program.constraints, &program.tasks)
38:    build_timing_model_from_ast(&program.topology, &program.tasks)
41:pub fn build_topology_from_ast(topology: &TopologySection) -> Result<TopologyGraph, Vec<PlcError>> {
42:    let mut topology_graph = TopologyGraph::new();
46:    for device in &topology.devices {
48:        let index = topology_graph.add_device(Device {
56:    for device in &topology.devices {
94:        topology_graph.add_connection(target_node.index, current_node.index, connection_type);
98:        Ok(topology_graph)
105:    topology: &TopologySection,
112:    let device_kinds = collect_device_kinds(topology);
113:    let known_states = collect_known_states(topology, &device_kinds);
188:    topology: &TopologySection,
191:    let device_profiles = collect_device_timing_profiles(topology);
475:fn collect_device_kinds(topology: &TopologySection) -> HashMap<String, DeviceKind> {
476:    topology
489:    topology: &TopologySection,
502:    for device in &topology.devices {

thinking
**Planning edge overlay approach**
exec
/bin/bash -lc "bash -lc 'sed -n \"1240,1318p\" src/semantic/mod.rs'" in /mnt/e/personal_project/rust_plc succeeded in 51ms:
fn literal_to_expression(literal: &LiteralValue) -> String {
    match literal {
        LiteralValue::Boolean(value) => value.to_string(),
        LiteralValue::Number(value) => value.to_string(),
        LiteralValue::String(value) => format!("\"{}\"", value),
        LiteralValue::State(state) => format!("{}.{}", state.device, state.state),
    }
}

fn duration_to_ms(timeout: &TimeoutDirective) -> u64 {
    duration_value_to_ms(&timeout.duration)
}

fn duration_value_to_ms(duration: &DurationValue) -> u64 {
    match duration.unit {
        TimeUnit::Ms => duration.value,
        TimeUnit::S => duration.value.saturating_mul(1000),
    }
}


thinking
**Associating sensors via inferred edges**
exec
/bin/bash -lc "bash -lc 'cat examples/two_cylinder.plc'" in /mnt/e/personal_project/rust_plc succeeded in 51ms:
[topology]

device Y0: digital_output
device Y1: digital_output
device X0: digital_input
device X1: digital_input
device X2: digital_input
device X3: digital_input
device X4: digital_input

device start_button: digital_input {
    connected_to: X4
    debounce: 20ms
}

device valve_A: solenoid_valve {
    connected_to: Y0
    response_time: 20ms
}


thinking
**Inspecting main compile path**
exec
/bin/bash -lc "bash -lc 'sed -n \"1,260p\" src/main.rs'" in /mnt/e/personal_project/rust_plc succeeded in 51ms:
use rust_plc::error::PlcError;
use rust_plc::ir::{ConstraintSet, StateMachine, TimingModel, TopologyGraph};
use rust_plc::parser::parse_plc;
use rust_plc::semantic::{
    build_constraint_set, build_state_machine, build_timing_model, build_topology_graph,
};
use serde::Serialize;
use std::env;
use std::fs;
use std::path::Path;

#[derive(Debug, Serialize)]
struct IrBundle {
    topology: TopologyGraph,
    state_machine: StateMachine,
    constraints: ConstraintSet,
    timing_model: TimingModel,
}

fn main() {

thinking
**Planning verification and dependency inspection**
exec
/bin/bash -lc "bash -lc 'python3 - <<\"PY\"
import json
from pathlib import Path
p=json.loads(Path(\"prd.json\").read_text())
for s in p[\"userStories\"]:
    if s[\"id\"] in [\"US-013\",\"US-014\",\"US-015\",\"US-016\",\"US-017\"]:
        print(\"\\n\",s[\"id\"],s[\"title\"],\"priority\",s[\"priority\"],\"passes\",s[\"passes\"])
        for ac in s[\"acceptanceCriteria\"]:
            print(\" -\",ac)
PY'" in /mnt/e/personal_project/rust_plc succeeded in 51ms:

 US-013 实现因果链检查器（Causality Checker） priority 13 passes False
 - src/verification/causality.rs 实现因果链验证
 - 对每条 causality 约束（如 Y0 -> valve_A -> cyl_A -> sensor_A_ext），使用 petgraph 可达性验证路径存在
 - 对 tasks 中的每个 action+wait 对，推断隐式因果链并验证连通性
 - 失败时：报告断裂的链路、期望链路、实际链路和修复建议（匹配 PRD 3.2.4 节错误格式）
 - 错误信息为中文，包含行号
 - 单元测试：验证 PRD 5.4 节示例的因果链通过
 - 单元测试：验证缺少连接时（如 valve_A 未连接到 cyl_A）因果链失败
 - 类型检查通过

 US-014 实现时序检查器（Timing Checker） priority 14 passes False
 - src/verification/timing.rs 实现时序包络验证
 - 对每个 must_complete_within 约束，计算作用域（task 或 step）的最坏情况关键路径时间
 - 同一 step 内多条 action 按并行计算（取最大值），顺序 step 累加
 - 因果链中包含设备 response_time：电磁阀 response_time + 气缸 stroke_time
 - 对每个 must_start_after 约束，计算前驱结束到当前开始的最短间隔
 - 若最短间隔不足以保证 must_start_after 要求，报错：'无法保证 X 在 Nms 后才开始，当前最短间隔为 Mms'
 - 失败时：报告约束、分析明细和结论（匹配 PRD 3.2.3 节错误格式）
 - 错误信息为中文，包含行号



thinking
**Designing implicit causality verification**
thinking
**Finalizing explicit and implicit causality checks**
thinking
**Defining action-wait extraction and diagnostics display**
exec
/bin/bash -lc "bash -lc 'mkdir -p src/verification'" in /mnt/e/personal_project/rust_plc succeeded in 51ms:


thinking
**Creating core module files**
exec
/bin/bash -lc "bash -lc 'cat > src/verification/mod.rs <<\"EOF\"
pub mod causality;
EOF'" in /mnt/e/personal_project/rust_plc succeeded in 51ms:


thinking
**Creating core causality module**
exec
/bin/bash -lc "bash -lc 'cat > src/verification/causality.rs <<\"EOF\"
use crate::ast::{
    ActionStatement, BinaryValue, ComparisonOperator, LiteralValue, PlcProgram, StepStatement,
    WaitStatement,
};
use crate::ir::{ConstraintSet, DeviceKind, TopologyGraph};
use petgraph::algo::has_path_connecting;
use petgraph::graph::{DiGraph, NodeIndex};
use petgraph::visit::EdgeRef;
use std::collections::{HashMap, HashSet, VecDeque};
use std::fmt;

#[derive(Debug, Clone, PartialEq, Eq)]
pub struct CausalityDiagnostic {
    pub line: usize,
    pub action: Option<String>,
    pub wait: Option<String>,
    pub broken_link: String,
    pub expected_chain: String,
    pub actual_chain: String,
    pub suggestion: String,
}

impl fmt::Display for CausalityDiagnostic {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        writeln"'!(f, "ERROR [causality] 因果链断裂")?;
        writeln!(f, "  位置: <input>:{}:1", self.line)?;

        if let Some(action) = &self.action {
            writeln!(f, "  动作: {action}")?;
        }
        if let Some(wait) = &self.wait {
            writeln!(f, "  等待: {wait}")?;
        }

        writeln!(f, "  断裂链路: {}", self.broken_link)?;
        writeln!(f, "  期望链路: {}", self.expected_chain)?;
        writeln!(f, "  实际链路: {}", self.actual_chain)?;
        write!(f, "  建议: {}", self.suggestion)
    }
}

pub fn verify_causality(
    program: &PlcProgram,
    topology: &TopologyGraph,
    constraints: &ConstraintSet,
) -> Result<(), Vec<CausalityDiagnostic>> {
    let runtime_graph = RuntimeGraph::from_inputs(program, topology);
    let mut diagnostics = Vec::new();

    let chain_line_map = collect_chain_line_map(program);
    for chain in &constraints.causality {
        if chain.devices.len() < 2 {
            continue;
        }

        if let Some((from, to)) = first_broken_link(&runtime_graph, &chain.devices) {
            let line = chain_line_map
                .get(&chain.devices)
                .copied()
                .unwrap_or(1)
                .max(1);

            diagnostics.push(CausalityDiagnostic {
                line,
                action: None,
                wait: None,
                broken_link: format!("{from} -> {to}"),
                expected_chain: chain.devices.join(" -> "),
                actual_chain: realized_prefix(&runtime_graph, &chain.devices),
                suggestion: suggestion_for_link(&from, &to),
            });
        }
    }

    let sensor_names = collect_sensor_names(program);
    let output_ports = collect_output_ports(topology);
    let declared_chains: Vec<Vec<String>> = constraints
        .causality
        .iter()
        .map(|chain| chain.devices.clone())
        .collect();

    for pair in collect_action_wait_pairs(program, &sensor_names) {
        if let Some(expected_chain) = match_declared_chain(&declared_chains, &pair.action_target, &pair.wait_sensor) {
            if let Some((from, to)) = first_broken_link(&runtime_graph, &expected_chain) {
                diagnostics.push(CausalityDiagnostic {
                    line: pair.line,
                    action: Some(pair.action),
                    wait: Some(pair.wait),
                    broken_link: format!("{from} -> {to}"),
                    expected_chain: expected_chain.join(" -> "),
                    actual_chain: realized_prefix(&runtime_graph, &expected_chain),
                    suggestion: suggestion_for_link(&from, &to),
                });
            }
            continue;
        }

        let source_path = shortest_output_path_to_target(
            &runtime_graph,
            &output_ports,
            &pair.action_target,
        );
        let feedback_path = shortest_path(
            &runtime_graph,
            &pair.action_target,
            &pair.wait_sensor,
        );

        if let (Some(source_path), Some(feedback_path)) = (&source_path, &feedback_path) {
            let full_path = join_paths(source_path, feedback_path);
            if first_broken_link(&runtime_graph, &full_path).is_none() {
                continue;
            }
        }

        let (broken_link, expected_chain, actual_chain, suggestion) =
            build_fallback_details(&pair, &source_path, &feedback_path, &output_ports);

        diagnostics.push(CausalityDiagnostic {
            line: pair.line,
            action: Some(pair.action),
            wait: Some(pair.wait),
            broken_link,
            expected_chain,
            actual_chain,
            suggestion,
        });
    }

    if diagnostics.is_empty() {
        Ok(())
    } else {
        Err(diagnostics)
    }
}

#[derive(Debug, Clone)]
struct ActionWaitPair {
    line: usize,
    action: String,
    action_target: String,
    wait: String,
    wait_sensor: String,
}

#[derive(Debug, Clone)]
struct RuntimeGraph {
    graph: DiGraph<String, ()>,
    nodes: HashMap<String, NodeIndex>,
}

impl RuntimeGraph {
    fn from_inputs(program: &PlcProgram, topology: &TopologyGraph) -> Self {
        let mut graph = DiGraph::<String, ()>::new();
        let mut nodes = HashMap::<String, NodeIndex>::new();

        for node in topology.graph.node_indices() {
            let name = topology.graph[node].name.clone();
            let index = graph.add_node(name.clone());
            nodes.insert(name, index);
        }

        for edge in topology.graph.edge_references() {
            let source_name = topology.graph[edge.source()].name.as_str();
            let target_name = topology.graph[edge.target()].name.as_str();

            if let (Some(source), Some(target)) = (nodes.get(source_name), nodes.get(target_name)) {
                graph.add_edge(*source, *target, ());
            }
        }

        for device in &program.topology.devices {
            let Some(detects) = &device.attributes.detects else {
                continue;
            };

            let Some(source) = nodes.get(&detects.device) else {
                continue;
            };
            let Some(target) = nodes.get(&device.name) else {
                continue;
            };

            graph.add_edge(*source, *target, ());
        }

        Self { graph, nodes }
    }

    fn path_exists(&self, from: &str, to: &str) -> bool {
        let Some(source) = self.nodes.get(from) else {
            return false;
        };
        let Some(target) = self.nodes.get(to) else {
            return false;
        };

        has_path_connecting(&self.graph, *source, *target, None)
    }
}

fn collect_chain_line_map(program: &PlcProgram) -> HashMap<Vec<String>, usize> {
    program
        .constraints
        .causality
        .iter()
        .map(|chain| {
            (
                chain
                    .chain
                    .iter()
                    .map(|node| node.device.clone())
                    .collect::<Vec<_>>(),
                chain.line.max(1),
            )
        })
        .collect()
}

fn first_broken_link(runtime_graph: &RuntimeGraph, chain: &[String]) -> Option<(String, String)> {
    for pair in chain.windows(2) {
        if !runtime_graph.path_exists(&pair[0], &pair[1]) {
            return Some((pair[0].clone(), pair[1].clone()));
        }
    }

    None
}

fn realized_prefix(runtime_graph: &RuntimeGraph, chain: &[String]) -> String {
    if chain.is_empty() {
        return "???".to_string();
    }

    let mut realized = vec![chain[0].clone()];
    for pair in chain.windows(2) {
        let Some(segment_path) = shortest_path(runtime_graph, &pair[0], &pair[1]) else {
            realized.push("???".to_string());
            break;
        };

        for node in segment_path.into_iter().skip(1) {
            if realized.last() != Some(&node) {
                realized.push(node);
            }
        }
    }

    realized.join(" -> ")
}

fn collect_sensor_names(program: &PlcProgram) -> HashSet<String> {
    program
        .topology
        .devices
        .iter()
        .filter(|device| matches!(device.device_type, crate::ast::DeviceType::Sensor))
        .map(|device| device.name.clone())
        .collect()
}

fn collect_output_ports(topology: &TopologyGraph) -> Vec<String> {
    topology
        .graph
        .node_indices()
        .filter(|index| matches!(topology.graph[*index].kind, DeviceKind::DigitalOutput))
        .map(|index| topology.graph[index].name.clone())
        .collect()
}

fn collect_action_wait_pairs(program: &PlcProgram, sensor_names: &HashSet<String>) -> Vec<ActionWaitPair> {
    let mut pairs = Vec::new();

    for task in &program.tasks.tasks {
        for step in &task.steps {
            collect_pairs_from_statements(
                &step.statements,
                step.line.max(1),
                sensor_names,
                &mut pairs,
            );
        }
    }

    pairs
}

fn collect_pairs_from_statements(
    statements: &[StepStatement],
    line: usize,
    sensor_names: &HashSet<String>,
    pairs: &mut Vec<ActionWaitPair>,
) {
    let mut actions = Vec::new();
    let mut waits = Vec::new();

    for statement in statements {
        match statement {
            StepStatement::Action(action) => {
                if let Some((action_text, target)) = action_to_text_and_target(action) {
                    actions.push((action_text, target));
                }
            }
            StepStatement::Wait(wait) => {
                if let Some(sensor) = infer_wait_sensor(wait, sensor_names) {
                    waits.push((wait_to_text(wait), sensor));
                }
            }
            StepStatement::Parallel(block) => {
                for branch in &block.branches {
                    collect_pairs_from_statements(&branch.statements, line, sensor_names, pairs);
                }
            }
            StepStatement::Race(block) => {
                for branch in &block.branches {
                    collect_pairs_from_statements(&branch.statements, line, sensor_names, pairs);
                }
            }
            _ => {}
        }
    }

    for (action_text, action_target) in &actions {
        for (wait_text, wait_sensor) in &waits {
            pairs.push(ActionWaitPair {
                line,
                action: action_text.clone(),
                action_target: action_target.clone(),
                wait: wait_text.clone(),
                wait_sensor: wait_sensor.clone(),
            });
        }
    }
}

fn action_to_text_and_target(action: &ActionStatement) -> Option<(String, String)> {
    match action {
        ActionStatement::Extend { target } => Some((format!("extend {target}"), target.clone())),
        ActionStatement::Retract { target } => Some((format!("retract {target}"), target.clone())),
        ActionStatement::Set { target, value } => {
            Some((format!("set {target} {}", binary_value_text(value)), target.clone()))
        }
        ActionStatement::Log { .. } => None,
    }
}

fn binary_value_text(value: &BinaryValue) -> &'"'static str {
    match value {
        BinaryValue::On => \"on\",
        BinaryValue::Off => \"off\",
    }
}

fn infer_wait_sensor(wait: &WaitStatement, sensor_names: &HashSet<String>) -> Option<String> {
    if sensor_names.contains(&wait.condition.left) {
        return Some(wait.condition.left.clone());
    }

    if let Some(candidate) = wait.condition.left.split('.').next() {
        if sensor_names.contains(candidate) {
            return Some(candidate.to_string());
        }
    }

    if let LiteralValue::State(state) = &wait.condition.right
        && sensor_names.contains(&state.device)
    {
        return Some(state.device.clone());
    }

    None
}

fn wait_to_text(wait: &WaitStatement) -> String {
    format"'!(
        "{} {} {}",
        wait.condition.left,
        comparison_operator_text(&wait.condition.operator),
        literal_to_text(&wait.condition.right)
    )
}

fn comparison_operator_text(operator: &ComparisonOperator) -> &'"'static str {
    match operator {
        ComparisonOperator::Eq => \"==\",
        ComparisonOperator::Neq => \""'!=",
    }
}

fn literal_to_text(literal: &LiteralValue) -> String {
    match literal {
        LiteralValue::Boolean(value) => value.to_string(),
        LiteralValue::Number(value) => value.to_string(),
        LiteralValue::String(value) => format!("'"\\\"{value}\\\"\"),
        LiteralValue::State(state) => format"'!("{}.{}", state.device, state.state),
    }
}

fn match_declared_chain(
    chains: &[Vec<String>],
    action_target: &str,
    wait_sensor: &str,
) -> Option<Vec<String>> {
    let mut best: Option<Vec<String>> = None;

    for chain in chains {
        let Some(wait_index) = chain.iter().position(|node| node == wait_sensor) else {
            continue;
        };

        let Some(action_index) = chain
            .iter()
            .take(wait_index + 1)
            .position(|node| node == action_target)
        else {
            continue;
        };

        if action_index >= wait_index {
            continue;
        }

        let candidate = chain[..=wait_index].to_vec();
        let is_better = best
            .as_ref()
            .map(|existing| candidate.len() < existing.len())
            .unwrap_or(true);

        if is_better {
            best = Some(candidate);
        }
    }

    best
}

fn shortest_output_path_to_target(
    runtime_graph: &RuntimeGraph,
    output_ports: &[String],
    target: &str,
) -> Option<Vec<String>> {
    let mut best: Option<Vec<String>> = None;

    for output in output_ports {
        let Some(path) = shortest_path(runtime_graph, output, target) else {
            continue;
        };

        let is_better = best
            .as_ref()
            .map(|existing| path.len() < existing.len())
            .unwrap_or(true);

        if is_better {
            best = Some(path);
        }
    }

    best
}

fn shortest_path(runtime_graph: &RuntimeGraph, from: &str, to: &str) -> Option<Vec<String>> {
    let source = *runtime_graph.nodes.get(from)?;
    let target = *runtime_graph.nodes.get(to)?;

    let mut queue = VecDeque::new();
    let mut visited = HashSet::new();
    let mut previous = HashMap::<NodeIndex, NodeIndex>::new();

    queue.push_back(source);
    visited.insert(source);

    while let Some(node) = queue.pop_front() {
        if node == target {
            break;
        }

        for neighbor in runtime_graph.graph.neighbors(node) {
            if visited.insert(neighbor) {
                previous.insert(neighbor, node);
                queue.push_back(neighbor);
            }
        }
    }

    if !visited.contains(&target) {
        return None;
    }

    let mut path_indices = vec![target];
    let mut cursor = target;
    while cursor != source {
        let parent = *previous.get(&cursor)?;
        path_indices.push(parent);
        cursor = parent;
    }
    path_indices.reverse();

    Some(
        path_indices
            .into_iter()
            .map(|index| runtime_graph.graph[index].clone())
            .collect(),
    )
}

fn join_paths(left: &[String], right: &[String]) -> Vec<String> {
    let mut joined = left.to_vec();

    for node in right {
        if joined.last() != Some(node) {
            joined.push(node.clone());
        }
    }

    joined
}

fn build_fallback_details(
    pair: &ActionWaitPair,
    source_path: &Option<Vec<String>>,
    feedback_path: &Option<Vec<String>>,
    output_ports: &[String],
) -> (String, String, String, String) {
    if source_path.is_none() {
        let output = output_ports
            .first()
            .cloned()
            .unwrap_or_else(|| "<输出端口>".to_string());
        return (
            format!("{output} -> {}", pair.action_target),
            format!("{output} -> {} -> {}", pair.action_target, pair.wait_sensor),
            format!("{output} -> ???"),
            format!(
                "请检查 {} 的 connected_to 链路，确保它可由输出端口驱动",
                pair.action_target
            ),
        );
    }

    let source_path = source_path.as_ref().expect("source path exists above");

    if feedback_path.is_none() {
        return (
            format!("{} -> {}", pair.action_target, pair.wait_sensor),
            format!("{} -> {}", source_path.join(" -> "), pair.wait_sensor),
            format!("{} -> ???", source_path.join(" -> ")),
            format!(
                "请补充 {} 的 detects/connected_to 声明，确保动作后能反馈到 {}",
                pair.wait_sensor, pair.wait_sensor
            ),
        );
    }

    (
        format!("{} -> {}", pair.action_target, pair.wait_sensor),
        format!("{} -> {}", source_path.join(" -> "), pair.wait_sensor),
        format!("{} -> ???", source_path.join(" -> ")),
        format!(
            "请检查 {} 与 {} 之间的物理连接定义",
            pair.action_target, pair.wait_sensor
        ),
    )
}

fn suggestion_for_link(from: &str, to: &str) -> String {
    format!(
        "请在 [topology] 中检查 {to} 的 connected_to / detects 配置，确保链路 {from} -> {to} 可达"
    )
}

#[cfg(test)]
mod tests {
    use super::verify_causality;
    use crate::parser::parse_plc;
    use crate::semantic::{build_constraint_set, build_topology_graph};

    #[test]
    fn verifies_prd_5_4_causality_chains() {
        let source = r#"
[topology]

device Y0: digital_output
device Y1: digital_output
device X0: digital_input
device X1: digital_input

device valve_A: solenoid_valve {
    connected_to: Y0,
    response_time: 20ms
}

device valve_B: solenoid_valve {
    connected_to: Y1,
    response_time: 20ms
}

device cyl_A: cylinder {
    connected_to: valve_A,
    stroke_time: 300ms,
    retract_time: 300ms
}

device cyl_B: cylinder {
    connected_to: valve_B,
    stroke_time: 300ms,
    retract_time: 300ms
}

device sensor_A_ext: sensor {
    connected_to: X0,
    detects: cyl_A.extended
}

device sensor_B_ext: sensor {
    connected_to: X1,
    detects: cyl_B.extended
}

[constraints]

causality: Y0 -> valve_A -> cyl_A -> sensor_A_ext
causality: Y1 -> valve_B -> cyl_B -> sensor_B_ext

[tasks]

task init:
    step extend_A:
        action: extend cyl_A
        wait: sensor_A_ext == true
    step extend_B:
        action: extend cyl_B
        wait: sensor_B_ext == true
"#;

        let program = parse_plc(source).expect("PRD 5.4 示例应能解析");
        let topology = build_topology_graph(&program).expect("拓扑应能构建");
        let constraints = build_constraint_set(&program).expect("约束应能构建");

        verify_causality(&program, &topology, &constraints)
            .expect("PRD 5.4 示例中的因果链应全部通过");
    }

    #[test]
    fn reports_broken_chain_when_valve_is_not_connected_to_cylinder() {
        let source = r#"
[topology]

device Y0: digital_output
device X0: digital_input

device valve_A: solenoid_valve {
    connected_to: Y0,
    response_time: 20ms
}

device cyl_A: cylinder {
    stroke_time: 300ms,
    retract_time: 300ms
}

device sensor_A_ext: sensor {
    connected_to: X0,
    detects: cyl_A.extended
}

[constraints]

causality: Y0 -> valve_A -> cyl_A -> sensor_A_ext

[tasks]

task init:
    step extend_A:
        action: extend cyl_A
        wait: sensor_A_ext == true
"#;

        let program = parse_plc(source).expect("测试输入应能解析");
        let topology = build_topology_graph(&program).expect("拓扑应能构建");
        let constraints = build_constraint_set(&program).expect("约束应能构建");

        let errors = verify_causality(&program, &topology, &constraints)
            .expect_err("缺失 valve_A -> cyl_A 链路时应报错");

        assert!(
            errors
                .iter()
                .any(|error| error.to_string().contains("ERROR [causality] 因果链断裂")),
            "错误应包含因果链断裂标题"
        );
        assert!(
            errors
                .iter()
                .any(|error| error.to_string().contains("断裂链路: valve_A -> cyl_A")),
            "错误应指出断裂的链路"
        );
        assert!(
            errors
                .iter()
                .any(|error| error.to_string().contains("动作: extend cyl_A")),
            "错误应包含 action+wait 推断得到的动作信息"
        );
        assert!(
            errors
                .iter()
                .all(|error| error.line > 0),
            "所有错误都应包含有效行号"
        );
    }
}
EOF'"'" in /mnt/e/personal_project/rust_plc exited 2 in 51ms:
/bin/bash: -c: line 25: syntax error near unexpected token `)'
/bin/bash: -c: line 25: `    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {'

thinking
**Resolving shell quoting conflicts**
exec
/bin/bash -lc "bash -lc \"cat > src/verification/causality.rs <<'EOF'
use crate::ast::{
    ActionStatement, BinaryValue, ComparisonOperator, LiteralValue, PlcProgram, StepStatement,
    WaitStatement,
};
use crate::ir::{ConstraintSet, DeviceKind, TopologyGraph};
use petgraph::algo::has_path_connecting;
use petgraph::graph::{DiGraph, NodeIndex};
use petgraph::visit::EdgeRef;
use std::collections::{HashMap, HashSet, VecDeque};
use std::fmt;

#[derive(Debug, Clone, PartialEq, Eq)]
pub struct CausalityDiagnostic {
    pub line: usize,
    pub action: Option<String>,
    pub wait: Option<String>,
    pub broken_link: String,
    pub expected_chain: String,
    pub actual_chain: String,
    pub suggestion: String,
}

impl fmt::Display for CausalityDiagnostic {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        writeln"'!(f, '"\\\"ERROR [causality] 因果链断裂\\\")?;
        writeln"'!(f, '"\\\"  位置: <input>:{}:1\\\", self.line)?;

        if let Some(action) = &self.action {
            writeln"'!(f, '"\\\"  动作: {action}\\\")?;
        }
        if let Some(wait) = &self.wait {
            writeln"'!(f, '"\\\"  等待: {wait}\\\")?;
        }

        writeln"'!(f, '"\\\"  断裂链路: {}\\\", self.broken_link)?;
        writeln"'!(f, '"\\\"  期望链路: {}\\\", self.expected_chain)?;
        writeln"'!(f, '"\\\"  实际链路: {}\\\", self.actual_chain)?;
        write"'!(f, '"\\\"  建议: {}\\\", self.suggestion)
    }
}

pub fn verify_causality(
    program: &PlcProgram,
    topology: &TopologyGraph,
    constraints: &ConstraintSet,
) -> Result<(), Vec<CausalityDiagnostic>> {
    let runtime_graph = RuntimeGraph::from_inputs(program, topology);
    let mut diagnostics = Vec::new();

    let chain_line_map = collect_chain_line_map(program);
    for chain in &constraints.causality {
        if chain.devices.len() < 2 {
            continue;
        }

        if let Some((from, to)) = first_broken_link(&runtime_graph, &chain.devices) {
            let line = chain_line_map
                .get(&chain.devices)
                .copied()
                .unwrap_or(1)
                .max(1);

            diagnostics.push(CausalityDiagnostic {
                line,
                action: None,
                wait: None,
                broken_link: format"'!('"\\\"{from} -> {to}\\\"),
                expected_chain: chain.devices.join(\\\" -> \\\"),
                actual_chain: realized_prefix(&runtime_graph, &chain.devices),
                suggestion: suggestion_for_link(&from, &to),
            });
        }
    }

    let sensor_names = collect_sensor_names(program);
    let output_ports = collect_output_ports(topology);
    let declared_chains: Vec<Vec<String>> = constraints
        .causality
        .iter()
        .map(|chain| chain.devices.clone())
        .collect();

    for pair in collect_action_wait_pairs(program, &sensor_names) {
        if let Some(expected_chain) =
            match_declared_chain(&declared_chains, &pair.action_target, &pair.wait_sensor)
        {
            if let Some((from, to)) = first_broken_link(&runtime_graph, &expected_chain) {
                diagnostics.push(CausalityDiagnostic {
                    line: pair.line,
                    action: Some(pair.action),
                    wait: Some(pair.wait),
                    broken_link: format"'!('"\\\"{from} -> {to}\\\"),
                    expected_chain: expected_chain.join(\\\" -> \\\"),
                    actual_chain: realized_prefix(&runtime_graph, &expected_chain),
                    suggestion: suggestion_for_link(&from, &to),
                });
            }
            continue;
        }

        let source_path =
            shortest_output_path_to_target(&runtime_graph, &output_ports, &pair.action_target);
        let feedback_path = shortest_path(&runtime_graph, &pair.action_target, &pair.wait_sensor);

        if let (Some(source_path), Some(feedback_path)) = (&source_path, &feedback_path) {
            let full_path = join_paths(source_path, feedback_path);
            if first_broken_link(&runtime_graph, &full_path).is_none() {
                continue;
            }
        }

        let (broken_link, expected_chain, actual_chain, suggestion) =
            build_fallback_details(&pair, &source_path, &feedback_path, &output_ports);

        diagnostics.push(CausalityDiagnostic {
            line: pair.line,
            action: Some(pair.action),
            wait: Some(pair.wait),
            broken_link,
            expected_chain,
            actual_chain,
            suggestion,
        });
    }

    if diagnostics.is_empty() {
        Ok(())
    } else {
        Err(diagnostics)
    }
}

#[derive(Debug, Clone)]
struct ActionWaitPair {
    line: usize,
    action: String,
    action_target: String,
    wait: String,
    wait_sensor: String,
}

#[derive(Debug, Clone)]
struct RuntimeGraph {
    graph: DiGraph<String, ()>,
    nodes: HashMap<String, NodeIndex>,
}

impl RuntimeGraph {
    fn from_inputs(program: &PlcProgram, topology: &TopologyGraph) -> Self {
        let mut graph = DiGraph::<String, ()>::new();
        let mut nodes = HashMap::<String, NodeIndex>::new();

        for node in topology.graph.node_indices() {
            let name = topology.graph[node].name.clone();
            let index = graph.add_node(name.clone());
            nodes.insert(name, index);
        }

        for edge in topology.graph.edge_references() {
            let source_name = topology.graph[edge.source()].name.as_str();
            let target_name = topology.graph[edge.target()].name.as_str();

            if let (Some(source), Some(target)) = (nodes.get(source_name), nodes.get(target_name)) {
                graph.add_edge(*source, *target, ());
            }
        }

        for device in &program.topology.devices {
            let Some(detects) = &device.attributes.detects else {
                continue;
            };

            let Some(source) = nodes.get(&detects.device) else {
                continue;
            };
            let Some(target) = nodes.get(&device.name) else {
                continue;
            };

            graph.add_edge(*source, *target, ());
        }

        Self { graph, nodes }
    }

    fn path_exists(&self, from: &str, to: &str) -> bool {
        let Some(source) = self.nodes.get(from) else {
            return false;
        };
        let Some(target) = self.nodes.get(to) else {
            return false;
        };

        has_path_connecting(&self.graph, *source, *target, None)
    }
}

fn collect_chain_line_map(program: &PlcProgram) -> HashMap<Vec<String>, usize> {
    program
        .constraints
        .causality
        .iter()
        .map(|chain| {
            (
                chain
                    .chain
                    .iter()
                    .map(|node| node.device.clone())
                    .collect::<Vec<_>>(),
                chain.line.max(1),
            )
        })
        .collect()
}

fn first_broken_link(runtime_graph: &RuntimeGraph, chain: &[String]) -> Option<(String, String)> {
    for pair in chain.windows(2) {
        if "'!runtime_graph.path_exists(&pair[0], &pair[1]) {
            return Some((pair[0].clone(), pair[1].clone()));
        }
    }

    None
}

fn realized_prefix(runtime_graph: &RuntimeGraph, chain: &[String]) -> String {
    if chain.is_empty() {
        return '"\\\"???\\\".to_string();
    }

    let mut realized = vec"'![chain[0].clone()];
    for pair in chain.windows(2) {
        let Some(segment_path) = shortest_path(runtime_graph, &pair[0], &pair[1]) else {
            realized.push('"\\\"???\\\".to_string());
            break;
        };

        for node in segment_path.into_iter().skip(1) {
            if realized.last() "'!= Some(&node) {
                realized.push(node);
            }
        }
    }

    realized.join('"\\\" -> \\\")
}

fn collect_sensor_names(program: &PlcProgram) -> HashSet<String> {
    program
        .topology
        .devices
        .iter()
        .filter(|device| matches"'!(device.device_type, crate::ast::DeviceType::Sensor))
        .map(|device| device.name.clone())
        .collect()
}

fn collect_output_ports(topology: &TopologyGraph) -> Vec<String> {
    topology
        .graph
        .node_indices()
        .filter(|index| matches!(topology.graph[*index].kind, DeviceKind::DigitalOutput))
        .map(|index| topology.graph[index].name.clone())
        .collect()
}

fn collect_action_wait_pairs(
    program: &PlcProgram,
    sensor_names: &HashSet<String>,
) -> Vec<ActionWaitPair> {
    let mut pairs = Vec::new();

    for task in &program.tasks.tasks {
        for step in &task.steps {
            collect_pairs_from_statements(&step.statements, step.line.max(1), sensor_names, &mut pairs);
        }
    }

    pairs
}

fn collect_pairs_from_statements(
    statements: &[StepStatement],
    line: usize,
    sensor_names: &HashSet<String>,
    pairs: &mut Vec<ActionWaitPair>,
) {
    let mut actions = Vec::new();
    let mut waits = Vec::new();

    for statement in statements {
        match statement {
            StepStatement::Action(action) => {
                if let Some((action_text, target)) = action_to_text_and_target(action) {
                    actions.push((action_text, target));
                }
            }
            StepStatement::Wait(wait) => {
                if let Some(sensor) = infer_wait_sensor(wait, sensor_names) {
                    waits.push((wait_to_text(wait), sensor));
                }
            }
            StepStatement::Parallel(block) => {
                for branch in &block.branches {
                    collect_pairs_from_statements(&branch.statements, line, sensor_names, pairs);
                }
            }
            StepStatement::Race(block) => {
                for branch in &block.branches {
                    collect_pairs_from_statements(&branch.statements, line, sensor_names, pairs);
                }
            }
            _ => {}
        }
    }

    for (action_text, action_target) in &actions {
        for (wait_text, wait_sensor) in &waits {
            pairs.push(ActionWaitPair {
                line,
                action: action_text.clone(),
                action_target: action_target.clone(),
                wait: wait_text.clone(),
                wait_sensor: wait_sensor.clone(),
            });
        }
    }
}

fn action_to_text_and_target(action: &ActionStatement) -> Option<(String, String)> {
    match action {
        ActionStatement::Extend { target } => Some((format!('"\\\"extend {target}\\\"), target.clone())),
        ActionStatement::Retract { target } => Some((format"'!('"\\\"retract {target}\\\"), target.clone())),
        ActionStatement::Set { target, value } => {
            Some((format"'!('"\\\"set {target} {}\\\", binary_value_text(value)), target.clone()))
        }
        ActionStatement::Log { .. } => None,
    }
}

fn binary_value_text(value: &BinaryValue) -> &'static str {
    match value {
        BinaryValue::On => \\\"on\\\",
        BinaryValue::Off => \\\"off\\\",
    }
}

fn infer_wait_sensor(wait: &WaitStatement, sensor_names: &HashSet<String>) -> Option<String> {
    if sensor_names.contains(&wait.condition.left) {
        return Some(wait.condition.left.clone());
    }

    if let Some(candidate) = wait.condition.left.split('.').next()
        && sensor_names.contains(candidate)
    {
        return Some(candidate.to_string());
    }

    if let LiteralValue::State(state) = &wait.condition.right
        && sensor_names.contains(&state.device)
    {
        return Some(state.device.clone());
    }

    None
}

fn wait_to_text(wait: &WaitStatement) -> String {
    format"'!(
        '"\\\"{} {} {}\\\",
        wait.condition.left,
        comparison_operator_text(&wait.condition.operator),
        literal_to_text(&wait.condition.right)
    )
}

fn comparison_operator_text(operator: &ComparisonOperator) -> &'static str {
    match operator {
        ComparisonOperator::Eq => \\\"==\\\",
        ComparisonOperator::Neq => \\\""'!='"\\\",
    }
}

fn literal_to_text(literal: &LiteralValue) -> String {
    match literal {
        LiteralValue::Boolean(value) => value.to_string(),
        LiteralValue::Number(value) => value.to_string(),
        LiteralValue::String(value) => format"'!('"\\\"\\\\\\\"{value}\\\\\\\"\\\"),
        LiteralValue::State(state) => format"'!('"\\\"{}.{}\\\", state.device, state.state),
    }
}

fn match_declared_chain(
    chains: &[Vec<String>],
    action_target: &str,
    wait_sensor: &str,
) -> Option<Vec<String>> {
    let mut best: Option<Vec<String>> = None;

    for chain in chains {
        let Some(wait_index) = chain.iter().position(|node| node == wait_sensor) else {
            continue;
        };

        let Some(action_index) = chain
            .iter()
            .take(wait_index + 1)
            .position(|node| node == action_target)
        else {
            continue;
        };

        if action_index >= wait_index {
            continue;
        }

        let candidate = chain[..=wait_index].to_vec();
        let is_better = best
            .as_ref()
            .map(|existing| candidate.len() < existing.len())
            .unwrap_or(true);

        if is_better {
            best = Some(candidate);
        }
    }

    best
}

fn shortest_output_path_to_target(
    runtime_graph: &RuntimeGraph,
    output_ports: &[String],
    target: &str,
) -> Option<Vec<String>> {
    let mut best: Option<Vec<String>> = None;

    for output in output_ports {
        let Some(path) = shortest_path(runtime_graph, output, target) else {
            continue;
        };

        let is_better = best
            .as_ref()
            .map(|existing| path.len() < existing.len())
            .unwrap_or(true);

        if is_better {
            best = Some(path);
        }
    }

    best
}

fn shortest_path(runtime_graph: &RuntimeGraph, from: &str, to: &str) -> Option<Vec<String>> {
    let source = *runtime_graph.nodes.get(from)?;
    let target = *runtime_graph.nodes.get(to)?;

    let mut queue = VecDeque::new();
    let mut visited = HashSet::new();
    let mut previous = HashMap::<NodeIndex, NodeIndex>::new();

    queue.push_back(source);
    visited.insert(source);

    while let Some(node) = queue.pop_front() {
        if node == target {
            break;
        }

        for neighbor in runtime_graph.graph.neighbors(node) {
            if visited.insert(neighbor) {
                previous.insert(neighbor, node);
                queue.push_back(neighbor);
            }
        }
    }

    if "'!visited.contains(&target) {
        return None;
    }

    let mut path_indices = vec![target];
    let mut cursor = target;
    while cursor != source {
        let parent = *previous.get(&cursor)?;
        path_indices.push(parent);
        cursor = parent;
    }
    path_indices.reverse();

    Some(
        path_indices
            .into_iter()
            .map(|index| runtime_graph.graph[index].clone())
            .collect(),
    )
}

fn join_paths(left: &[String], right: &[String]) -> Vec<String> {
    let mut joined = left.to_vec();

    for node in right {
        if joined.last() != Some(node) {
            joined.push(node.clone());
        }
    }

    joined
}

fn build_fallback_details(
    pair: &ActionWaitPair,
    source_path: &Option<Vec<String>>,
    feedback_path: &Option<Vec<String>>,
    output_ports: &[String],
) -> (String, String, String, String) {
    if source_path.is_none() {
        let output = output_ports
            .first()
            .cloned()
            .unwrap_or_else(|| '"\\\"<输出端口>\\\".to_string());
        return (
            format"'!('"\\\"{output} -> {}\\\", pair.action_target),
            format"'!('"\\\"{output} -> {} -> {}\\\", pair.action_target, pair.wait_sensor),
            format"'!('"\\\"{output} -> ???\\\"),
            format"'!(
                '"\\\"请检查 {} 的 connected_to 链路，确保它可由输出端口驱动\\\",
                pair.action_target
            ),
        );
    }

    let source_path = source_path.as_ref().expect(\\\"source path exists above\\\");

    if feedback_path.is_none() {
        return (
            format"'!('"\\\"{} -> {}\\\", pair.action_target, pair.wait_sensor),
            format"'!('"\\\"{} -> {}\\\", source_path.join(\\\" -> \\\"), pair.wait_sensor),
            format"'!('"\\\"{} -> ???\\\", source_path.join(\\\" -> \\\")),
            format"'!(
                '"\\\"请补充 {} 的 detects/connected_to 声明，确保动作后能反馈到 {}\\\",
                pair.wait_sensor, pair.wait_sensor
            ),
        );
    }

    (
        format"'!('"\\\"{} -> {}\\\", pair.action_target, pair.wait_sensor),
        format"'!('"\\\"{} -> {}\\\", source_path.join(\\\" -> \\\"), pair.wait_sensor),
        format"'!('"\\\"{} -> ???\\\", source_path.join(\\\" -> \\\")),
        format"'!(
            '"\\\"请检查 {} 与 {} 之间的物理连接定义\\\",
            pair.action_target, pair.wait_sensor
        ),
    )
}

fn suggestion_for_link(from: &str, to: &str) -> String {
    format"'!(
        '"\\\"请在 [topology] 中检查 {to} 的 connected_to / detects 配置，确保链路 {from} -> {to} 可达\\\"
    )
}

#[cfg(test)]
mod tests {
    use super::verify_causality;
    use crate::parser::parse_plc;
    use crate::semantic::{build_constraint_set, build_topology_graph};

    #[test]
    fn verifies_prd_5_4_causality_chains() {
        let source = r#\\\"
[topology]

device Y0: digital_output
device Y1: digital_output
device X0: digital_input
device X1: digital_input

device valve_A: solenoid_valve {
    connected_to: Y0,
    response_time: 20ms
}

device valve_B: solenoid_valve {
    connected_to: Y1,
    response_time: 20ms
}

device cyl_A: cylinder {
    connected_to: valve_A,
    stroke_time: 300ms,
    retract_time: 300ms
}

device cyl_B: cylinder {
    connected_to: valve_B,
    stroke_time: 300ms,
    retract_time: 300ms
}

device sensor_A_ext: sensor {
    connected_to: X0,
    detects: cyl_A.extended
}

device sensor_B_ext: sensor {
    connected_to: X1,
    detects: cyl_B.extended
}

[constraints]

causality: Y0 -> valve_A -> cyl_A -> sensor_A_ext
causality: Y1 -> valve_B -> cyl_B -> sensor_B_ext

[tasks]

task init:
    step extend_A:
        action: extend cyl_A
        wait: sensor_A_ext == true
    step extend_B:
        action: extend cyl_B
        wait: sensor_B_ext == true
\\\"#;

        let program = parse_plc(source).expect(\\\"PRD 5.4 示例应能解析\\\");
        let topology = build_topology_graph(&program).expect(\\\"拓扑应能构建\\\");
        let constraints = build_constraint_set(&program).expect(\\\"约束应能构建\\\");

        verify_causality(&program, &topology, &constraints)
            .expect(\\\"PRD 5.4 示例中的因果链应全部通过\\\");
    }

    #[test]
    fn reports_broken_chain_when_valve_is_not_connected_to_cylinder() {
        let source = r#\\\"
[topology]

device Y0: digital_output
device X0: digital_input

device valve_A: solenoid_valve {
    connected_to: Y0,
    response_time: 20ms
}

device cyl_A: cylinder {
    stroke_time: 300ms,
    retract_time: 300ms
}

device sensor_A_ext: sensor {
    connected_to: X0,
    detects: cyl_A.extended
}

[constraints]

causality: Y0 -> valve_A -> cyl_A -> sensor_A_ext

[tasks]

task init:
    step extend_A:
        action: extend cyl_A
        wait: sensor_A_ext == true
\\\"#;

        let program = parse_plc(source).expect(\\\"测试输入应能解析\\\");
        let topology = build_topology_graph(&program).expect(\\\"拓扑应能构建\\\");
        let constraints = build_constraint_set(&program).expect(\\\"约束应能构建\\\");

        let errors = verify_causality(&program, &topology, &constraints)
            .expect_err(\\\"缺失 valve_A -> cyl_A 链路时应报错\\\");

        assert"'!(
            errors
                .iter()
                .any(|error| error.to_string().contains('"\\\"ERROR [causality] 因果链断裂\\\")),
            \\\"错误应包含因果链断裂标题\\\"
        );
        assert"'!(
            errors
                .iter()
                .any(|error| error.to_string().contains('"\\\"断裂链路: valve_A -> cyl_A\\\")),
            \\\"错误应指出断裂的链路\\\"
        );
        assert"'!(
            errors
                .iter()
                .any(|error| error.to_string().contains('"\\\"动作: extend cyl_A\\\")),
            \\\"错误应包含 action+wait 推断得到的动作信息\\\"
        );
        assert"'!(
            errors.iter().all(|error| error.line > 0),
            '"\\\"所有错误都应包含有效行号\\\"
        );
    }
}
EOF\"" in /mnt/e/personal_project/rust_plc succeeded in 51ms:


thinking
**Adding verification module**
exec
/bin/bash -lc "bash -lc \"apply_patch <<'PATCH'
*** Begin Patch
*** Update File: src/lib.rs
@@
 pub mod semantic;
+pub mod verification;
*** End Patch
PATCH\"" in /mnt/e/personal_project/rust_plc succeeded in 51ms:
Success. Updated the following files:
M src/lib.rs

thinking
**Running format check**
exec
/bin/bash -lc "bash -lc 'cargo fmt'" in /mnt/e/personal_project/rust_plc succeeded in 154ms:


thinking
**Running full test suite**
exec
/bin/bash -lc "bash -lc 'cargo test'" in /mnt/e/personal_project/rust_plc
thinking
**Planning polling mechanism**
 succeeded in 15.32s:
   Compiling rust_plc v0.1.0 (/mnt/e/personal_project/rust_plc)
    Finished `test` profile [unoptimized + debuginfo] target(s) in 14.70s
     Running unittests src/lib.rs (target/debug/deps/rust_plc-750d18e2a560a5e9)

running 26 tests
test ir::tests::topology_graph_supports_device_nodes_and_connection_edges ... ok
test error::tests::format_parse_error_contains_line_and_chinese_message ... ok
test error::tests::format_undefined_reference_contains_missing_device_name ... ok
test ir::tests::ir_structures_are_serializable_to_pretty_json ... ok
test parser::tests::parses_prd_5_5_2_wait_and_jump_tasks_example ... ok
test parser::tests::parse_plc_reports_line_number_for_syntax_errors ... ok
test parser::tests::parses_prd_5_5_3_fault_handler_tasks_example ... ok
test parser::tests::parses_requires_and_must_start_after_constraints ... ok
test parser::tests::parses_prd_5_4_constraints_example ... ok
test parser::tests::parses_prd_5_5_1_basic_sequence_tasks_example ... ok
test parser::tests::parses_all_topology_device_types_and_property_shapes ... ok
test parser::tests::parses_prd_5_5_4_parallel_tasks_example ... ok
test parser::tests::parses_prd_5_3_topology_example ... ok
test parser::tests::parses_prd_5_5_5_race_tasks_example ... ok
test semantic::tests::reports_error_when_connection_types_are_incompatible ... ok

thinking
**Updating plan after build validation**
Plan update
  ✓ Inspect PRD/progress and determine target story + branch
  ✓ Implement highest-priority failing story and add/adjust tests
  → Run quality checks, update docs/logs, commit, and mark PRD pass

thinking
**Checking git status for changes**
exec
/bin/bash -lc "bash -lc 'git status --short --branch'" in /mnt/e/personal_project/rust_plc succeeded in 268ms:
## ralph/phase1-2-parser-and-verification
 M .ralph_logs/iter_12.log
 M src/lib.rs
?? .ralph_logs/iter_13.log
?? .ralph_logs/iter_14.log
?? src/verification/

thinking
**Reviewing new files for issues**
exec
/bin/bash -lc "bash -lc 'sed -n \"1,260p\" src/verification/causality.rs'" in /mnt/e/personal_project/rust_plc succeeded in 51ms:
use crate::ast::{
    ActionStatement, BinaryValue, ComparisonOperator, LiteralValue, PlcProgram, StepStatement,
    WaitStatement,
};
use crate::ir::{ConstraintSet, DeviceKind, TopologyGraph};
use petgraph::algo::has_path_connecting;
use petgraph::graph::{DiGraph, NodeIndex};
use petgraph::visit::EdgeRef;
use std::collections::{HashMap, HashSet, VecDeque};
use std::fmt;

#[derive(Debug, Clone, PartialEq, Eq)]
pub struct CausalityDiagnostic {
    pub line: usize,
    pub action: Option<String>,
    pub wait: Option<String>,
    pub broken_link: String,
    pub expected_chain: String,
    pub actual_chain: String,
    pub suggestion: String,
exec
/bin/bash -lc "bash -lc 'sed -n \"260,520p\" src/verification/causality.rs'" in /mnt/e/personal_project/rust_plc succeeded in 51ms:
        .graph
        .node_indices()
        .filter(|index| matches!(topology.graph[*index].kind, DeviceKind::DigitalOutput))
        .map(|index| topology.graph[index].name.clone())
        .collect()
}

fn collect_action_wait_pairs(
    program: &PlcProgram,
    sensor_names: &HashSet<String>,
) -> Vec<ActionWaitPair> {
    let mut pairs = Vec::new();

    for task in &program.tasks.tasks {
        for step in &task.steps {
            collect_pairs_from_statements(
                &step.statements,
                step.line.max(1),
                sensor_names,
                &mut pairs,

thinking
**Completing test endings**
exec
/bin/bash -lc "bash -lc 'sed -n \"520,760p\" src/verification/causality.rs'" in /mnt/e/personal_project/rust_plc succeeded in 51ms:
    pair: &ActionWaitPair,
    source_path: &Option<Vec<String>>,
    feedback_path: &Option<Vec<String>>,
    output_ports: &[String],
) -> (String, String, String, String) {
    if source_path.is_none() {
        let output = output_ports
            .first()
            .cloned()
            .unwrap_or_else(|| "<输出端口>".to_string());
        return (
            format!("{output} -> {}", pair.action_target),
            format!("{output} -> {} -> {}", pair.action_target, pair.wait_sensor),
            format!("{output} -> ???"),
            format!(
                "请检查 {} 的 connected_to 链路，确保它可由输出端口驱动",
                pair.action_target
            ),
        );
    }

thinking
**Planning progress and commit updates**
exec
/bin/bash -lc "bash -lc 'date \"+%Y-%m-%d %H:%M:%S %Z\"'" in /mnt/e/personal_project/rust_plc succeeded in 51ms:
2026-02-11 12:00:41 CST

thinking
**Updating JSON flag via script**
exec
/bin/bash -lc "bash -lc 'python3 - <<\"PY\"
import json
from pathlib import Path
path=Path(\"prd.json\")
data=json.loads(path.read_text())
for story in data.get(\"userStories\",[]):
    if story.get(\"id\")==\"US-013\":
        story[\"passes\"]=True
        break
path.write_text(json.dumps(data, ensure_ascii=False, indent=2)+\"\\n\")
PY'" in /mnt/e/personal_project/rust_plc succeeded in 51ms:


thinking
**Planning bullet insertion**
exec
/bin/bash -lc "bash -lc 'sed -n \"1,40p\" progress.txt'" in /mnt/e/personal_project/rust_plc succeeded in 51ms:
# Ralph Progress Log
## Codebase Patterns
- TopologyGraph JSON 调试依赖 `petgraph` 的 `serde-1` feature；若缺失会导致 DiGraph 无法序列化。
- In parser-to-AST lowering, unwrap wrapper PEG rules (e.g., `constraint_declaration`, `step_statement`) before matching concrete rule kinds, or valid nodes can be silently skipped.
- Keep public module declarations centralized in `src/lib.rs`; implementation files live at `src/<module>/mod.rs`.
- For early story scaffolding, keep module placeholders compiling so CLI and library can evolve incrementally without breaking builds.
- Model DSL enums with `serde(rename_all = "snake_case")` and tagged enums so serialized AST tokens stay aligned with DSL keywords.
- In pest grammars, define silent `WHITESPACE` and `COMMENT` rules so inline `#` comments and multiline section formatting parse without extra boilerplate.
- For block-style DSL sections, parse optional `reason: "..."` clauses directly in each declaration rule so indented multiline annotations remain valid without separate line handling.
- In nested `parallel`/`race` grammar, require branch bodies to consume concrete statements so step-level directives are not misparsed as branch labels.
- In semantic topology lowering, treat `connected_to` as upstream linkage (`target -> current`) so causality traversals follow physical flow direction.
- Preserve directive line metadata in AST (e.g., `GotoDirective.line`, `TaskDeclaration.on_complete_line`) so semantic passes can report precise line-numbered errors without reparsing source text.
- For constraint semantic validation, seed known device states from device-type defaults plus `sensor.detects` references before checking `safety` state expressions.
- Use `PlcError` constructors (`undefined_reference` / `type_mismatch` / `duplicate_definition`) so diagnostics share unified ERROR blocks with `位置/原因/建议` fields.
- For end-to-end compilation paths (CLI/tests), run all four semantic builders and aggregate their errors so users get complete diagnostics in one run.
Started: Wed Feb 11 01:14:39 CST 2026
---
## [2026-02-11 01:19:50 CST] - US-001
Thread: https://ampcode.com/threads/$AMP_CURRENT_THREAD_ID
- What was implemented

thinking
**Planning codebase pattern insertion**
exec
/bin/bash -lc "bash -lc 'python3 - <<\"PY\"
from pathlib import Path
path = Path(\"progress.txt\")
text = path.read_text()
pattern = \"- For causality verification, augment TopologyGraph with logical edges from "'`detects.device -> sensor` before running reachability, otherwise output-to-sensor chains may appear disconnected.'"\\n\"
if pattern not in text:
    insert_at = text.find(\"Started:\")
    if insert_at "'!= -1:
        text = text[:insert_at] + pattern + text[insert_at:]
    else:
        text += "'"\\n\" + pattern

entry = \"\"\"
## [2026-02-11 12:00:41 CST] - US-013
Thread: https://ampcode.com/threads/"'$AMP_CURRENT_THREAD_ID
- What was implemented
  - Added causality verification module `src/verification/causality.rs` with `verify_causality`, using petgraph reachability over an augmented runtime graph (topology edges + `detects` logical edges) to validate every declared causality chain.
  - Implemented implicit action+wait causality inference from task steps (including nested `parallel`/`race` branches) and connectivity checks from output ports through action targets to waited sensors.
  - Added Chinese causality diagnostics with line numbers, broken-link details, expected/actual chain output, and repair suggestions matching PRD 3.2.4 style.
  - Added unit tests for PRD 5.4 passing chains and missing `valve_A -> cyl_A` connection failure.
  - Exposed verification module via `src/verification/mod.rs` and `src/lib.rs`.
- Files changed
  - `src/verification/causality.rs`, `src/verification/mod.rs`, `src/lib.rs`, `prd.json`, `progress.txt`
- **Learnings for future iterations:**
  - Patterns discovered (e.g., "this codebase uses X for Y")
    - Causality checks should run on an augmented graph that includes `sensor.detects` logical feedback edges, not only raw `connected_to` edges.
  - Gotchas encountered (e.g., "do not forget to update Z when changing W")
    - `StepStatement` currently does not carry per-action/per-wait line metadata, so implicit causality diagnostics should fall back to `StepDeclaration.line` until finer-grained line fields are added.
  - Useful context (e.g., "the evaluation panel is in component X")
    - `verify_causality` accepts both AST (`PlcProgram`) and IR (`TopologyGraph`/`ConstraintSet`) so future verifier orchestrators can reuse semantic outputs while preserving source-line context.
---
"""

if entry not in text:
    if not text.endswith("'"\\n\"):
        text += \"\\n\"
    text += entry

path.write_text(text)
PY'" in /mnt/e/personal_project/rust_plc succeeded in 51ms:


thinking
**Planning insertion verification**
exec
/bin/bash -lc "bash -lc 'sed -n \"1,28p\" progress.txt && tail -n 60 progress.txt'" in /mnt/e/personal_project/rust_plc succeeded in 51ms:
# Ralph Progress Log
## Codebase Patterns
- TopologyGraph JSON 调试依赖 `petgraph` 的 `serde-1` feature；若缺失会导致 DiGraph 无法序列化。
- In parser-to-AST lowering, unwrap wrapper PEG rules (e.g., `constraint_declaration`, `step_statement`) before matching concrete rule kinds, or valid nodes can be silently skipped.
- Keep public module declarations centralized in `src/lib.rs`; implementation files live at `src/<module>/mod.rs`.
- For early story scaffolding, keep module placeholders compiling so CLI and library can evolve incrementally without breaking builds.
- Model DSL enums with `serde(rename_all = "snake_case")` and tagged enums so serialized AST tokens stay aligned with DSL keywords.
- In pest grammars, define silent `WHITESPACE` and `COMMENT` rules so inline `#` comments and multiline section formatting parse without extra boilerplate.
- For block-style DSL sections, parse optional `reason: "..."` clauses directly in each declaration rule so indented multiline annotations remain valid without separate line handling.
- In nested `parallel`/`race` grammar, require branch bodies to consume concrete statements so step-level directives are not misparsed as branch labels.
- In semantic topology lowering, treat `connected_to` as upstream linkage (`target -> current`) so causality traversals follow physical flow direction.
- Preserve directive line metadata in AST (e.g., `GotoDirective.line`, `TaskDeclaration.on_complete_line`) so semantic passes can report precise line-numbered errors without reparsing source text.
- For constraint semantic validation, seed known device states from device-type defaults plus `sensor.detects` references before checking `safety` state expressions.
- Use `PlcError` constructors (`undefined_reference` / `type_mismatch` / `duplicate_definition`) so diagnostics share unified ERROR blocks with `位置/原因/建议` fields.
- For end-to-end compilation paths (CLI/tests), run all four semantic builders and aggregate their errors so users get complete diagnostics in one run.
- For causality verification, augment TopologyGraph with logical edges from `detects.device -> sensor` before running reachability, otherwise output-to-sensor chains may appear disconnected.
Started: Wed Feb 11 01:14:39 CST 2026
---
## [2026-02-11 01:19:50 CST] - US-001
Thread: https://ampcode.com/threads/$AMP_CURRENT_THREAD_ID

thinking
**Verifying progress append behavior**
exec
/bin/bash -lc "bash -lc 'python3 - <<\"PY\"
import json
from pathlib import Path
p=json.loads(Path(\"prd.json\").read_text())
for s in p[\"userStories\"]:
    if s[\"id\"] in [\"US-013\",\"US-014\",\"US-015\",\"US-016\",\"US-017\"]:
        print(s[\"id\"], s[\"passes\"])
PY'" in /mnt/e/personal_project/rust_plc succeeded in 51ms:
US-013 True
US-014 False
US-015 False
US-016 False
US-017 False

thinking
**Verifying no agent changes**
exec
/bin/bash -lc "bash -lc 'git status --short'" in /mnt/e/personal_project/rust_plc succeeded in 125ms:
 M .ralph_logs/iter_12.log
 M prd.json
 M progress.txt
 M src/lib.rs
?? .ralph_logs/iter_13.log
?? .ralph_logs/iter_14.log
?? src/verification/

thinking
**Including logs in commit**
exec
/bin/bash -lc "bash -lc 'git add -A && git commit -m \"feat: [US-013] - [实现因果链检查器（Causality Checker）]\"'" in /mnt/e/personal_project/rust_plc succeeded in 607ms:
[ralph/phase1-2-parser-and-verification cba644f] feat: [US-013] - [实现因果链检查器（Causality Checker）]
 8 files changed, 4304 insertions(+), 4 deletions(-)
 create mode 100644 .ralph_logs/iter_13.log
 create mode 100644 .ralph_logs/iter_14.log
 create mode 100644 src/verification/causality.rs
 create mode 100644 src/verification/mod.rs

thinking
**Verifying large JSON diff**
exec
/bin/bash -lc "bash -lc 'git status --short --branch'" in /mnt/e/personal_project/rust_plc succeeded in 143ms:
## ralph/phase1-2-parser-and-verification
 M .ralph_logs/iter_14.log

thinking
**Assessing leftover uncommitted log changes**
exec
/bin/bash -lc "bash -lc 'git diff -- .ralph_logs/iter_14.log | sed -n \"1,120p\"'" in /mnt/e/personal_project/rust_plc succeeded in 51ms:
diff --git a/.ralph_logs/iter_14.log b/.ralph_logs/iter_14.log
index b7fa624..3e30ca7 100644
--- a/.ralph_logs/iter_14.log
+++ b/.ralph_logs/iter_14.log
@@ -2616,4 +2616,20 @@ exec
 thinking
 **Including logs in commit**
 exec
-/bin/bash -lc "bash -lc 'git add -A && git commit -m \"feat: [US-013] - [实现因果链检查器（Causality Checker）]\"'" in /mnt/e/personal_project/rust_plc
\ No newline at end of file
+/bin/bash -lc "bash -lc 'git add -A && git commit -m \"feat: [US-013] - [实现因果链检查器（Causality Checker）]\"'" in /mnt/e/personal_project/rust_plc succeeded in 607ms:
+[ralph/phase1-2-parser-and-verification cba644f] feat: [US-013] - [实现因果链检查器（Causality Checker）]
+ 8 files changed, 4304 insertions(+), 4 deletions(-)
+ create mode 100644 .ralph_logs/iter_13.log
+ create mode 100644 .ralph_logs/iter_14.log
+ create mode 100644 src/verification/causality.rs
+ create mode 100644 src/verification/mod.rs
+
+thinking
+**Verifying large JSON diff**

thinking
**Planning final commit amend**
exec
/bin/bash -lc "bash -lc 'git add -A && git commit --amend --no-edit'" in /mnt/e/personal_project/rust_plc succeeded in 792ms:
[ralph/phase1-2-parser-and-verification 8fa97c6] feat: [US-013] - [实现因果链检查器（Causality Checker）]
 Date: Wed Feb 11 12:02:10 2026 +0800
 8 files changed, 4347 insertions(+), 4 deletions(-)
 create mode 100644 .ralph_logs/iter_13.log
 create mode 100644 .ralph_logs/iter_14.log
 create mode 100644 src/verification/causality.rs
 create mode 100644 src/verification/mod.rs

thinking
**Confirming no further shell runs**
Plan update
  ✓ Inspect PRD/progress and determine target story + branch
  ✓ Implement highest-priority failing story and add/adjust tests
  ✓ Run quality checks, update docs/logs, commit, and mark PRD pass

thinking
**Preparing file references with line numbers**
codex
Implemented **US-013** on `ralph/phase1-2-parser-and-verification` and committed it.

- Added a new causality verifier in `src/verification/causality.rs:1`:
  - Validates declared `causality` chains via petgraph reachability.
  - Builds an augmented runtime graph (topology edges + `detects.device -> sensor` logical edges).
  - Infers implicit action+wait causality pairs from tasks (including nested `parallel`/`race`) and checks connectivity.
  - Emits Chinese diagnostics with line numbers, broken link, expected chain, actual chain, and suggestion.
- Exposed the module via `src/verification/mod.rs:1` and `src/lib.rs:6`.
- Added/updated unit tests in `src/verification/causality.rs:571` (PRD 5.4 pass case + missing `valve_A -> cyl_A` fail case).
- Updated story status in `prd.json:1` (`US-013` set to `passes: true`).
- Updated progress and codebase patterns in `progress.txt:1` and appended the US-013 iteration entry.

Quality checks:
- Ran `cargo test` (all tests passed: unit + integration + doc tests).

Commit:
- `8fa97c6`
- Message: `feat: [US-013] - [实现因果链检查器（Causality Checker）]`

There are still stories with `passes: false` (`US-014` to `US-017`), so this iteration stops here.
tokens used
1,954,161
Implemented **US-013** on `ralph/phase1-2-parser-and-verification` and committed it.

- Added a new causality verifier in `src/verification/causality.rs:1`:
  - Validates declared `causality` chains via petgraph reachability.
  - Builds an augmented runtime graph (topology edges + `detects.device -> sensor` logical edges).
  - Infers implicit action+wait causality pairs from tasks (including nested `parallel`/`race`) and checks connectivity.
  - Emits Chinese diagnostics with line numbers, broken link, expected chain, actual chain, and suggestion.
- Exposed the module via `src/verification/mod.rs:1` and `src/lib.rs:6`.
- Added/updated unit tests in `src/verification/causality.rs:571` (PRD 5.4 pass case + missing `valve_A -> cyl_A` fail case).
- Updated story status in `prd.json:1` (`US-013` set to `passes: true`).
- Updated progress and codebase patterns in `progress.txt:1` and appended the US-013 iteration entry.

Quality checks:
- Ran `cargo test` (all tests passed: unit + integration + doc tests).

Commit:
- `8fa97c6`
- Message: `feat: [US-013] - [实现因果链检查器（Causality Checker）]`

There are still stories with `passes: false` (`US-014` to `US-017`), so this iteration stops here.
