OpenAI Codex v0.98.0 (research preview)
--------
workdir: /mnt/e/personal_project/rust_plc
model: gpt-5.3-codex
provider: codex
approval: never
sandbox: danger-full-access
reasoning effort: high
reasoning summaries: auto
session id: 019c4b18-1be2-7c43-9ce0-9264601d69b0
--------
user
# Ralph Agent Instructions

You are an autonomous coding agent working on a software project.

## Your Task

1. Read the PRD at `prd.json` (in the same directory as this file)
2. Read the progress log at `progress.txt` (check Codebase Patterns section first)
3. Check you're on the correct branch from PRD `branchName`. If not, check it out or create from main.
4. Pick the **highest priority** user story where `passes: false`
5. Implement that single user story
6. Run quality checks (e.g., typecheck, lint, test - use whatever your project requires)
7. Update AGENTS.md files if you discover reusable patterns (see below)
8. If checks pass, commit ALL changes with message: `feat: [Story ID] - [Story Title]`
9. Update the PRD to set `passes: true` for the completed story
10. Append your progress to `progress.txt`

## Progress Report Format

APPEND to progress.txt (never replace, always append):
```
## [Date/Time] - [Story ID]
Thread: https://ampcode.com/threads/$AMP_CURRENT_THREAD_ID
- What was implemented
- Files changed
- **Learnings for future iterations:**
  - Patterns discovered (e.g., "this codebase uses X for Y")
  - Gotchas encountered (e.g., "don't forget to update Z when changing W")
  - Useful context (e.g., "the evaluation panel is in component X")
---
```

Include the thread URL so future iterations can use the `read_thread` tool to reference previous work if needed.

The learnings section is critical - it helps future iterations avoid repeating mistakes and understand the codebase better.

## Consolidate Patterns

If you discover a **reusable pattern** that future iterations should know, add it to the `## Codebase Patterns` section at the TOP of progress.txt (create it if it doesn't exist). This section should consolidate the most important learnings:

```
## Codebase Patterns
- Example: Use `sql<number>` template for aggregations
- Example: Always use `IF NOT EXISTS` for migrations
- Example: Export types from actions.ts for UI components
```

Only add patterns that are **general and reusable**, not story-specific details.

## Update AGENTS.md Files

Before committing, check if any edited files have learnings worth preserving in nearby AGENTS.md files:

1. **Identify directories with edited files** - Look at which directories you modified
2. **Check for existing AGENTS.md** - Look for AGENTS.md in those directories or parent directories
3. **Add valuable learnings** - If you discovered something future developers/agents should know:
   - API patterns or conventions specific to that module
   - Gotchas or non-obvious requirements
   - Dependencies between files
   - Testing approaches for that area
   - Configuration or environment requirements

**Examples of good AGENTS.md additions:**
- "When modifying X, also update Y to keep them in sync"
- "This module uses pattern Z for all API calls"
- "Tests require the dev server running on PORT 3000"
- "Field names must match the template exactly"

**Do NOT add:**
- Story-specific implementation details
- Temporary debugging notes
- Information already in progress.txt

Only update AGENTS.md if you have **genuinely reusable knowledge** that would help future work in that directory.

## Quality Requirements

- ALL commits must pass your project's quality checks (typecheck, lint, test)
- Do NOT commit broken code
- Keep changes focused and minimal
- Follow existing code patterns

## Browser Testing (Required for Frontend Stories)

For any story that changes UI, you MUST verify it works in the browser:

1. Load the `dev-browser` skill
2. Navigate to the relevant page
3. Verify the UI changes work as expected
4. Take a screenshot if helpful for the progress log

A frontend story is NOT complete until browser verification passes.

## Stop Condition

After completing a user story, check if ALL stories have `passes: true`.

If ALL stories are complete and passing, reply with:
<promise>COMPLETE</promise>

If there are still stories with `passes: false`, end your response normally (another iteration will pick up the next story).

## Important

- Work on ONE story per iteration
- Commit frequently
- Keep CI green
- Read the Codebase Patterns section in progress.txt before starting

mcp startup: no servers

thinking
**Reviewing repo and agent setup**
exec
/bin/bash -lc "bash -lc 'ls -la'" in /mnt/e/personal_project/rust_plc succeeded in 51ms:
total 116
drwxrwxrwx 1 liangyuhang liangyuhang  4096 Feb 11 10:12 .
drwxrwxrwx 1 liangyuhang liangyuhang  4096 Feb 10 20:47 ..
drwxrwxrwx 1 liangyuhang liangyuhang  4096 Feb 11 00:34 .claude
drwxrwxrwx 1 liangyuhang liangyuhang  4096 Feb 11 01:09 .codex
drwxrwxrwx 1 liangyuhang liangyuhang  4096 Feb 11 13:06 .git
-rwxrwxrwx 1 liangyuhang liangyuhang     8 Feb 11 01:17 .gitignore
drwxrwxrwx 1 liangyuhang liangyuhang  4096 Feb 11 13:06 .ralph_logs
-rwxrwxrwx 1 liangyuhang liangyuhang  4307 Feb 11 01:14 CODEX.md
-rwxrwxrwx 1 liangyuhang liangyuhang  7674 Feb 11 09:01 Cargo.lock
-rwxrwxrwx 1 liangyuhang liangyuhang   249 Feb 11 09:00 Cargo.toml
drwxrwxrwx 1 liangyuhang liangyuhang  4096 Feb 11 10:11 examples
-rwxrwxrwx 1 liangyuhang liangyuhang 18673 Feb 11 12:34 prd.json
-rwxrwxrwx 1 liangyuhang liangyuhang 38276 Feb 11 00:28 prd.md
-rwxrwxrwx 1 liangyuhang liangyuhang 27594 Feb 11 12:34 progress.txt
-rwxrwxrwx 1 liangyuhang liangyuhang  4307 Jan 23 10:30 prompt.md
-rwxrwxrwx 1 liangyuhang liangyuhang  3816 Feb 11 01:14 ralph.sh
drwxrwxrwx 1 liangyuhang liangyuhang  4096 Feb 11 11:55 src
drwxrwxrwx 1 liangyuhang liangyuhang  4096 Feb 11 10:12 target
drwxrwxrwx 1 liangyuhang liangyuhang  4096 Feb 11 10:12 tests

thinking
**Planning recursive AGENTS.md read**
exec
/bin/bash -lc "bash -lc 'rg --files -g \"AGENTS.md\"'" in /mnt/e/personal_project/rust_plc exited 1 in 51ms:


thinking
**Planning to parse PRD file**
exec
/bin/bash -lc "bash -lc 'cat prd.json'" in /mnt/e/personal_project/rust_plc succeeded in 51ms:
{
  "project": "RustPLC",
  "branchName": "ralph/phase1-2-parser-and-verification",
  "description": "Phase 1+2: DSL 解析器、语义分析器与形式化验证引擎 — 解析 .plc 文件生成 AST，构建 IR（TopologyGraph、StateMachine、ConstraintSet、TimingModel），并完成四项形式化验证（Safety、Liveness、Timing、Causality）",
  "userStories": [
    {
      "id": "US-001",
      "title": "初始化 Rust 项目与依赖",
      "description": "作为开发者，我需要搭建 Rust 项目脚手架并配置所有必要依赖，以便后续故事可以在此基础上构建。",
      "acceptanceCriteria": [
        "Cargo.toml 存在，项目名为 'rust_plc'",
        "依赖包含：pest、pest_derive、petgraph、serde、serde_json、thiserror",
        "src/main.rs 存在，实现基本 CLI，接受 .plc 文件路径参数",
        "src/lib.rs 存在，声明模块：parser、ast、ir、semantic、error",
        "每个模块有占位文件（如 src/parser/mod.rs）",
        "cargo build 成功",
        "类型检查通过"
      ],
      "priority": 1,
      "passes": true,

thinking
**Inspecting codebase head**
exec
/bin/bash -lc "bash -lc 'sed -n \"1,220p\" progress.txt'" in /mnt/e/personal_project/rust_plc succeeded in 51ms:
# Ralph Progress Log
## Codebase Patterns
- For timing envelopes, include upstream `response_time` along `connected_to` chains and treat incoming `StateMachine` guards as must_start_after lower bounds (`timeout` contributes delay, `always/condition` = 0ms).
- TopologyGraph JSON 调试依赖 `petgraph` 的 `serde-1` feature；若缺失会导致 DiGraph 无法序列化。
- In parser-to-AST lowering, unwrap wrapper PEG rules (e.g., `constraint_declaration`, `step_statement`) before matching concrete rule kinds, or valid nodes can be silently skipped.
- Keep public module declarations centralized in `src/lib.rs`; implementation files live at `src/<module>/mod.rs`.
- For early story scaffolding, keep module placeholders compiling so CLI and library can evolve incrementally without breaking builds.
- Model DSL enums with `serde(rename_all = "snake_case")` and tagged enums so serialized AST tokens stay aligned with DSL keywords.
- In pest grammars, define silent `WHITESPACE` and `COMMENT` rules so inline `#` comments and multiline section formatting parse without extra boilerplate.
- For block-style DSL sections, parse optional `reason: "..."` clauses directly in each declaration rule so indented multiline annotations remain valid without separate line handling.
- In nested `parallel`/`race` grammar, require branch bodies to consume concrete statements so step-level directives are not misparsed as branch labels.
- In semantic topology lowering, treat `connected_to` as upstream linkage (`target -> current`) so causality traversals follow physical flow direction.
- Preserve directive line metadata in AST (e.g., `GotoDirective.line`, `TaskDeclaration.on_complete_line`) so semantic passes can report precise line-numbered errors without reparsing source text.
- For constraint semantic validation, seed known device states from device-type defaults plus `sensor.detects` references before checking `safety` state expressions.
- Use `PlcError` constructors (`undefined_reference` / `type_mismatch` / `duplicate_definition`) so diagnostics share unified ERROR blocks with `位置/原因/建议` fields.
- For end-to-end compilation paths (CLI/tests), run all four semantic builders and aggregate their errors so users get complete diagnostics in one run.
- For causality verification, augment TopologyGraph with logical edges from `detects.device -> sensor` before running reachability, otherwise output-to-sensor chains may appear disconnected.
- Liveness checks should combine AST metadata (`allow_indefinite_wait`, `on_complete`) with StateMachine transitions; IR guards alone cannot reconstruct all wait exemptions.
Started: Wed Feb 11 01:14:39 CST 2026
---

thinking
**Planning priority story implementation**
exec
/bin/bash -lc "bash -lc 'find src -maxdepth 3 -type f | sort'" in /mnt/e/personal_project/rust_plc succeeded in 51ms:
src/ast/mod.rs
src/error/mod.rs
src/ir/mod.rs
src/lib.rs
src/main.rs
src/parser/mod.rs
src/parser/plc.pest
src/semantic/mod.rs
src/verification/causality.rs
src/verification/liveness.rs
src/verification/mod.rs
src/verification/timing.rs

thinking
**Identifying missing safety module**
exec
/bin/bash -lc "bash -lc 'sed -n \"1,260p\" src/verification/mod.rs'" in /mnt/e/personal_project/rust_plc succeeded in 50ms:
pub mod causality;
pub mod liveness;
pub mod timing;

thinking
**Reviewing existing verifiers**
exec
/bin/bash -lc "bash -lc 'sed -n \"1,320p\" src/verification/liveness.rs'" in /mnt/e/personal_project/rust_plc succeeded in 51ms:
use crate::ast::{
    ComparisonOperator, LiteralValue, OnCompleteDirective, PlcProgram, StepStatement, WaitStatement,
};
use crate::ir::{StateMachine, TransitionGuard};
use petgraph::algo::kosaraju_scc;
use petgraph::graph::DiGraph;
use petgraph::visit::EdgeRef;
use std::collections::{HashMap, HashSet};
use std::fmt;

#[derive(Debug, Clone, PartialEq, Eq)]
pub struct LivenessDiagnostic {
    pub line: usize,
    pub reason: String,
    pub physical_analysis: String,
    pub suggestion: String,
}

impl fmt::Display for LivenessDiagnostic {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
exec
/bin/bash -lc "bash -lc 'sed -n \"320,640p\" src/verification/liveness.rs'" in /mnt/e/personal_project/rust_plc succeeded in 50ms:
                    let branch_completion_is_jump =
                        branch.then_goto.is_some() || completion_is_jump;
                    summary.merge(summarize_statements(
                        &branch.statements,
                        branch_completion_is_jump,
                    ));
                }
            }
            StepStatement::Action(_) | StepStatement::AllowIndefiniteWait(_) => {}
        }
    }

    if !has_control_flow {
        if completion_is_jump {
            summary.has_jump_path = true;
        } else {
            summary.has_non_jump_path = true;
        }
    }


thinking
**Extending test coverage**
exec
/bin/bash -lc "bash -lc 'sed -n \"640,920p\" src/verification/liveness.rs'" in /mnt/e/personal_project/rust_plc succeeded in 50ms:
        action: log "spin"
    on_complete: goto init
"#;

        let program = parse_plc(source).expect("测试程序应能解析");
        let state_machine = build_state_machine(&program).expect("状态机应构建成功");

        let errors = verify_liveness(&program, &state_machine)
            .expect_err("无 timeout/allow_indefinite_wait 的循环 SCC 应报错");

        assert!(
            errors
                .iter()
                .any(|error| error.to_string().contains("强连通分量")),
            "错误应包含 SCC 死锁风险说明"
        );
    }

    #[test]
    fn allows_unreachable_when_all_race_paths_jump_away() {

thinking
**Considering timing and verification approach**
exec
/bin/bash -lc "bash -lc 'sed -n \"1,360p\" src/verification/timing.rs'" in /mnt/e/personal_project/rust_plc succeeded in 51ms:
use crate::ast::{ActionStatement, PlcProgram, StepStatement};
use crate::ir::{
    ConstraintSet, StateMachine, TimingRelation, TimingScope, TopologyGraph, TransitionGuard,
};
use petgraph::visit::EdgeRef;
use std::collections::{HashMap, HashSet};
use std::fmt;

#[derive(Debug, Clone, PartialEq, Eq)]
pub struct TimingDiagnostic {
    pub line: usize,
    pub constraint: String,
    pub analysis: String,
    pub conclusion: String,
}

impl fmt::Display for TimingDiagnostic {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        writeln!(f, "ERROR [timing] 时序包络违反")?;
        writeln!(f, "  位置: <input>:{}:1", self.line)?;

thinking
**Preparing IR inspection for safety encoding**
exec
/bin/bash -lc "bash -lc 'sed -n \"1,420p\" src/ir/mod.rs'" in /mnt/e/personal_project/rust_plc succeeded in 51ms:
use petgraph::graph::{DiGraph, NodeIndex};
use serde::{Deserialize, Serialize};
use std::collections::BTreeMap;

#[derive(Debug, Clone, Serialize, Deserialize, PartialEq)]
pub struct Device {
    pub name: String,
    pub kind: DeviceKind,
}

#[derive(Debug, Clone, Serialize, Deserialize, PartialEq)]
#[serde(rename_all = "snake_case")]
pub enum DeviceKind {
    DigitalOutput,
    DigitalInput,
    SolenoidValve,
    Cylinder,
    Sensor,
    Motor,
}

thinking
**Inspecting semantic state transitions**
exec
/bin/bash -lc "bash -lc 'rg -n \"pub fn build_state_machine|struct|TransitionGuard|ActionStatement|parallel|race|on_complete|allow_indefinite_wait\" src/semantic/mod.rs'" in /mnt/e/personal_project/rust_plc succeeded in 51ms:
2:    ActionStatement, BinaryValue as AstBinaryValue, ComparisonOperator, ConditionExpression,
14:    Transition, TransitionAction, TransitionGuard,
20:struct DeviceNode {
29:pub fn build_state_machine(program: &PlcProgram) -> Result<StateMachine, Vec<PlcError>> {
222:pub fn build_state_machine_from_ast(tasks: &TasksSection) -> Result<StateMachine, Vec<PlcError>> {
274:    let mut task_on_complete_targets = HashMap::<String, Option<State>>::new();
276:        let on_complete_target = match &task.on_complete {
278:                let line = task.on_complete_line.unwrap_or(task.line);
279:                resolve_task_target(step, line, &task_initial_states, &mut errors, "on_complete")
283:        task_on_complete_targets.insert(task.name.clone(), on_complete_target);
293:                completion_target_for_step(task, step_index, &task_on_complete_targets);
297:            for (block_index, block) in analyzed.parallel_blocks.iter().enumerate() {
298:                build_parallel_block(
312:            for (block_index, block) in analyzed.race_blocks.iter().enumerate() {
313:                build_race_block(
338:                        TransitionGuard::Always,
357:                        TransitionGuard::Timeout { duration_ms },
378:                        TransitionGuard::Condition {
389:                || !analyzed.parallel_blocks.is_empty()
390:                || !analyzed.race_blocks.is_empty();

thinking
**Planning comprehensive build overview**
exec
/bin/bash -lc "bash -lc 'sed -n \"1,280p\" src/semantic/mod.rs'" in /mnt/e/personal_project/rust_plc succeeded in 51ms:
use crate::ast::{
    ActionStatement, BinaryValue as AstBinaryValue, ComparisonOperator, ConditionExpression,
    ConstraintsSection, DeviceType, DurationValue, GotoDirective, LiteralValue,
    OnCompleteDirective, ParallelBlock, PlcProgram, RaceBlock, SafetyRelation as AstSafetyRelation,
    StepStatement, TaskDeclaration, TasksSection, TimeUnit, TimeoutDirective,
    TimingRelation as AstTimingRelation, TimingTarget, TopologySection, WaitStatement,
};
use crate::error::PlcError;
use crate::ir::{
    ActionKind, ActionRef, ActionTiming, BinaryValue as IrBinaryValue, CausalityChain,
    ConnectionType, ConstraintSet, Device, DeviceKind, SafetyRelation as IrSafetyRelation,
    SafetyRule, State, StateExpr, StateMachine, TimeInterval, TimerOperation, TimerOperationKind,
    TimingModel, TimingRelation as IrTimingRelation, TimingRule, TimingScope, TopologyGraph,
    Transition, TransitionAction, TransitionGuard,
};
use petgraph::graph::NodeIndex;
use std::collections::{BTreeMap, HashMap, HashSet};

#[derive(Debug, Clone)]
struct DeviceNode {

thinking
**Continuing state machine build**
exec
/bin/bash -lc "bash -lc 'sed -n \"280,560p\" src/semantic/mod.rs'" in /mnt/e/personal_project/rust_plc succeeded in 51ms:
            }
            _ => None,
        };
        task_on_complete_targets.insert(task.name.clone(), on_complete_target);
    }

    for task in &tasks.tasks {
        for (step_index, step) in task.steps.iter().enumerate() {
            let from_state = State {
                task_name: task.name.clone(),
                step_name: step.name.clone(),
            };
            let completion_target =
                completion_target_for_step(task, step_index, &task_on_complete_targets);

            let analyzed = analyze_statements(&step.statements);

            for (block_index, block) in analyzed.parallel_blocks.iter().enumerate() {
                build_parallel_block(
                    &mut builder,

thinking
**Planning parser inspection and state constraints**
exec
/bin/bash -lc "bash -lc 'cat src/lib.rs'" in /mnt/e/personal_project/rust_plc succeeded in 51ms:
pub mod ast;
pub mod error;
pub mod ir;
pub mod parser;
pub mod semantic;
pub mod verification;

thinking
**Inspecting main pipeline for checks**
exec
/bin/bash -lc "bash -lc 'sed -n \"1,340p\" src/main.rs'" in /mnt/e/personal_project/rust_plc succeeded in 51ms:
use rust_plc::error::PlcError;
use rust_plc::ir::{ConstraintSet, StateMachine, TimingModel, TopologyGraph};
use rust_plc::parser::parse_plc;
use rust_plc::semantic::{
    build_constraint_set, build_state_machine, build_timing_model, build_topology_graph,
};
use serde::Serialize;
use std::env;
use std::fs;
use std::path::Path;

#[derive(Debug, Serialize)]
struct IrBundle {
    topology: TopologyGraph,
    state_machine: StateMachine,
    constraints: ConstraintSet,
    timing_model: TimingModel,
}

fn main() {

thinking
**Reviewing existing verification tests**
exec
/bin/bash -lc "bash -lc 'find tests -maxdepth 2 -type f -print -exec sed -n \"1,260p\" {} \\;'" in /mnt/e/personal_project/rust_plc succeeded in 51ms:
tests/examples_integration.rs
use rust_plc::error::PlcError;
use rust_plc::parser::parse_plc;
use rust_plc::semantic::{
    build_constraint_set, build_state_machine, build_timing_model, build_topology_graph,
};
use serde_json::{Value, json};
use std::fs;
use std::path::{Path, PathBuf};
use std::process::Command;

fn example_path(file_name: &str) -> PathBuf {
    Path::new(env!("CARGO_MANIFEST_DIR"))
        .join("examples")
        .join(file_name)
}

fn read_example(file_name: &str) -> String {
    let path = example_path(file_name);
    fs::read_to_string(&path)

thinking
**Checking Cargo.toml dependencies**
exec
/bin/bash -lc "bash -lc 'cat Cargo.toml'" in /mnt/e/personal_project/rust_plc succeeded in 51ms:
[package]
name = "rust_plc"
version = "0.1.0"
edition = "2024"

[dependencies]
pest = "2.7"
pest_derive = "2.7"
petgraph = { version = "0.6", features = ["serde-1"] }
serde = { version = "1", features = ["derive"] }
serde_json = "1"
thiserror = "1"

thinking
**Checking current branch**
exec
/bin/bash -lc "bash -lc 'git branch --show-current && git status --short'" in /mnt/e/personal_project/rust_plc succeeded in 227ms:
 M .ralph_logs/iter_16.log
?? .ralph_logs/iter_17.log
?? .ralph_logs/iter_18.log
?? .ralph_logs/iter_19.log

thinking
**Deciding commit scope for logs**
exec
/bin/bash -lc "bash -lc 'tail -n 200 progress.txt'" in /mnt/e/personal_project/rust_plc succeeded in 51ms:
    - `timing` scopes are intentionally constrained to `task.<name>` or `task.<name>.<step>`; broad identifier chains would over-accept invalid DSL forms.
  - Useful context (e.g., "the evaluation panel is in component X")
    - Constraint parsing is still syntax-only; semantic validation for device/task existence and chain connectivity is deferred to later semantic/verification stories.
---
## [2026-02-11 07:26:44 CST] - US-005
Thread: https://ampcode.com/threads/$AMP_CURRENT_THREAD_ID
- What was implemented
  - Extended `src/parser/plc.pest` with `[tasks]` grammar for task/step declarations, action/wait/timeout/goto statements, `on_complete`, and `allow_indefinite_wait`.
  - Added nested control-flow grammar support for `parallel` and `race` blocks, including branch parsing and `then: goto` handling in race branches.
  - Added `parse_tasks` in `src/parser/mod.rs` plus parser unit tests covering PRD sections 5.5.1 through 5.5.5.
- Files changed
  - `src/parser/plc.pest`, `src/parser/mod.rs`, `prd.json`, `progress.txt`
- **Learnings for future iterations:**
  - Patterns discovered (e.g., "this codebase uses X for Y")
    - Task grammar entrypoints follow the same section-scoped API pattern as existing parser functions (`parse_topology`/`parse_constraints`), which keeps parser stories independently testable.
  - Gotchas encountered (e.g., "do not forget to update Z when changing W")
    - In PEG branch grammars, letting branch bodies be empty can cause tokens like `timeout:` to be accidentally treated as new branch labels; require concrete branch content to avoid this.
  - Useful context (e.g., "the evaluation panel is in component X")
    - Current task parsing remains syntax-only; AST lowering for task statements is still pending the dedicated parser-to-AST story.
---

thinking
**Planning remaining implementation steps**
Plan update
Implementing US-016 requires adding a new verifier module, wiring dependencies, and validating with tests before committing.
  → Inspect current verification/state-machine data paths and identify insertion points for Safety checker + Z3
  • Implement `src/verification/safety.rs` with k-induction/BMC behavior and warnings, then wire module/dependencies
  • Add/adjust tests for required safety scenarios and run quality checks
  • Update `prd.json` + `progress.txt`, then commit changes with required message

thinking
**Inspecting parser state mappings**
exec
/bin/bash -lc "bash -lc 'rg -n \"default_states_for_kind|state|extended|retracted|on|off|running\" src/semantic/mod.rs src/ast/mod.rs src/parser/mod.rs'" in /mnt/e/personal_project/rust_plc succeeded in 51ms:
Total output lines: 1007

src/ast/mod.rs:3:#[derive(Debug, Clone, Serialize, Deserialize)]
src/ast/mod.rs:5:    pub topology: TopologySection,
src/ast/mod.rs:6:    pub constraints: ConstraintsSection,
src/ast/mod.rs:7:    pub tasks: TasksSection,
src/ast/mod.rs:10:#[derive(Debug, Clone, Serialize, Deserialize, Default)]
src/ast/mod.rs:11:pub struct TopologySection {
src/ast/mod.rs:12:    pub devices: Vec<DeviceDeclaration>,
src/ast/mod.rs:15:#[derive(Debug, Clone, Serialize, Deserialize)]
src/ast/mod.rs:16:pub struct DeviceDeclaration {
src/ast/mod.rs:24:#[derive(Debug, Clone, Serialize, Deserialize)]
src/ast/mod.rs:35:#[derive(Debug, Clone, Serialize, Deserialize, Default)]
src/ast/mod.rs:37:    pub connected_to: Option<String>,
src/ast/mod.rs:38:    pub response_time: Option<DurationValue>,
src/ast/mod.rs:39:    pub stroke_time: Option<DurationValue>,
src/ast/mod.rs:40:    pub retract_time: Option<DurationValue>,
src/ast/mod.rs:41:    pub stroke: Option<MeasuredValue>,
src/ast/mod.rs:43:    pub r#type: Option<String>,
src/ast/mod.rs:44:    pub detects: Option<StateReference>,

thinking
**Focusing on specific function states**
exec
/bin/bash -lc "bash -lc 'rg -n \"fn default_states_for_kind|default_states_for_kind\\(\" src/semantic/mod.rs'" in /mnt/e/personal_project/rust_plc succeeded in 51ms:
496:        for state in default_states_for_kind(kind) {
796:fn default_states_for_kind(kind: &DeviceKind) -> &'static [&'static str] {
exec
/bin/bash -lc "bash -lc 'sed -n \"760,860p\" src/semantic/mod.rs'" in /mnt/e/personal_project/rust_plc succeeded in 51ms:
    })
}

fn insert_action_timing(intervals: &mut BTreeMap<String, ActionTiming>, timing: ActionTiming) {
    let action_name = action_kind_name(&timing.action.action_kind);
    let target = timing.action.target.as_deref().unwrap_or("_");
    let base_key = format!(
        "{}.{}.{}.{}",
        timing.action.task_name, timing.action.step_name, action_name, target
    );

    if !intervals.contains_key(&base_key) {
        intervals.insert(base_key, timing);
        return;
    }

    let mut duplicate_index = 2usize;
    loop {
        let key = format!("{base_key}.{duplicate_index}");
        if !intervals.contains_key(&key) {

thinking
**Considering diagnostic level design**
exec
/bin/bash -lc "bash -lc 'sed -n \"1,300p\" src/verification/causality.rs'" in /mnt/e/personal_project/rust_plc succeeded in 51ms:
use crate::ast::{
    ActionStatement, BinaryValue, ComparisonOperator, LiteralValue, PlcProgram, StepStatement,
    WaitStatement,
};
use crate::ir::{ConstraintSet, DeviceKind, TopologyGraph};
use petgraph::algo::has_path_connecting;
use petgraph::graph::{DiGraph, NodeIndex};
use petgraph::visit::EdgeRef;
use std::collections::{HashMap, HashSet, VecDeque};
use std::fmt;

#[derive(Debug, Clone, PartialEq, Eq)]
pub struct CausalityDiagnostic {
    pub line: usize,
    pub action: Option<String>,
    pub wait: Option<String>,
    pub broken_link: String,
    pub expected_chain: String,
    pub actual_chain: String,
    pub suggestion: String,

thinking
**Searching for verification tests**
exec
/bin/bash -lc "bash -lc 'rg -n \"verify_(liveness|timing|causality|safety)|Verification|WARNING|k-induction|bmc\" src tests'" in /mnt/e/personal_project/rust_plc succeeded in 51ms:
src/verification/liveness.rs:59:pub fn verify_liveness(
src/verification/liveness.rs:466:    use super::verify_liveness;
src/verification/liveness.rs:521:        verify_liveness(&program, &state_machine)
src/verification/liveness.rs:547:        let errors = verify_liveness(&program, &state_machine)
src/verification/liveness.rs:586:        verify_liveness(&program, &state_machine)
src/verification/liveness.rs:613:        let errors = verify_liveness(&program, &state_machine)
src/verification/liveness.rs:647:        let errors = verify_liveness(&program, &state_machine)
src/verification/liveness.rs:695:        verify_liveness(&program, &state_machine)
src/verification/timing.rs:50:pub fn verify_timing(
src/verification/timing.rs:486:    use super::verify_timing;
src/verification/timing.rs:524:        verify_timing(&program, &topology, &constraints, &state_machine)
src/verification/timing.rs:562:        let errors = verify_timing(&program, &topology, &constraints, &state_machine)
src/verification/timing.rs:610:        verify_timing(&program, &topology, &constraints, &state_machine)
src/verification/timing.rs:639:        let errors = verify_timing(&program, &topology, &constraints, &state_machine)
src/verification/causality.rs:42:pub fn verify_causality(
src/verification/causality.rs:574:    use super::verify_causality;
src/verification/causality.rs:640:        verify_causality(&program, &topology, &constraints)
src/verification/causality.rs:683:        let errors = verify_causality(&program, &topology, &constraints)

thinking
**Inspecting production user story details**
exec
/bin/bash -lc "bash -lc 'rg -n \"3\\.2\\.1|Safety|k-induction|BMC|bmc_max_depth|SCC|WARNING|双气缸|parallel\" prd.md'" in /mnt/e/personal_project/rust_plc succeeded in 50ms:
44:#### 3.2.1 状态互斥（Safety）
56:  1. 首先尝试 k-induction（归纳证明）：若归纳步成立，则性质对所有深度成立，获得完备证明
57:  2. 若 k-induction 无法收敛（存在归纳反例），回退到 BMC（有界模型检查）搜索反例。展开深度按以下策略确定：
59:     - 用户可通过配置项 `bmc_max_depth` 手动指定上限
60:     - 若状态机包含 SCC（强连通分量），对每个 SCC 至少展开其节点数 + 1 层以覆盖完整循环
66:  - **完备证明**（k-induction 或穷举通过）：输出"Safety 已完备证明：性质对所有可达状态成立"
67:  - **有界验证**（仅 BMC 通过）：输出"WARNING: Safety 在深度 N 内未发现反例，但未获得完备证明。建议增大 bmc_max_depth 以提升有界覆盖，或调整模型以帮助 k-induction 收敛"
193:    [x] Safety:    状态互斥检查
240:    |-- Safety Checker    --> Z3: k-induction 或 BMC 验证不存在冲突
387:# ===== 状态互斥 (Safety) =====
428:- **Safety 检查**：同一 step 内的多条 action 会被视为同时生效，编译器会检查它们是否违反 conflicts_with 约束
512:task parallel_demo:
514:        parallel:
558:| parallel | 并行执行多个分支 | parallel: ... |
720:      C1. Safety 检查
724:            1. 首先尝试 k-induction (归纳证明)，若成立则获得完备证明
725:            2. 若 k-induction 无法收敛，回退到 BMC 搜索反例，
726:               展开深度 = 状态节点数 (用户可通过 bmc_max_depth 配置上限，
727:               含 SCC 时至少展开 SCC 节点数 + 1 层)
730:            完备证明 (k-induction/穷举): "Safety 已完备证明"

thinking
**Identifying error format code**
exec
/bin/bash -lc "bash -lc 'sed -n \"36,90p\" prd.md'" in /mnt/e/personal_project/rust_plc succeeded in 51ms:
| R1b | 自然语言 AI 翻译为 DSL | P1 | Phase 5 |
| R2 | 用简单方式定义 IO、电磁阀、气缸之间的物理关系 | P0 | Phase 1 |
| R3 | 用简单语言输入安全约束和限制条件 | P0 | Phase 1 |
| R4 | 编译时自动转成 Rust，自动进行形式化验证 | P0 | Phase 2-3 |
| R5 | 运行时确定性执行 + 实时故障诊断 | P1 | Phase 4-5 |

### 3.2 形式化验证的四项核心检查

#### 3.2.1 状态互斥（Safety）

**目标**：证明在所有可达状态下，不会出现违反互斥约束的状态。

**场景示例**：
- 用户声明 `cyl_A.extended conflicts_with cyl_B.extended`
- 编译器对所有可达状态进行验证，证明不存在两缸同时伸出的状态
- 如果逻辑中存在并行路径可能导致两缸同时伸出，编译报错并给出反例路径

**验证方法**：
- 将状态机转为 SMT 布尔公式
- 采用分层验证策略：

thinking
**Considering safety constraint examples**
exec
/bin/bash -lc "bash -lc 'sed -n \"360,460p\" prd.md'" in /mnt/e/personal_project/rust_plc succeeded in 51ms:
device sensor_B_ret: sensor {
    type: magnetic
    connected_to: X3
    detects: cyl_B.retracted
}
```

**设备类型关键词**：

| 类型 | 关键词 | 必填属性 | 可选属性 |
|------|--------|---------|---------|
| 数字输出 | digital_output | 无 | inverted, connected_to |
| 数字输入 | digital_input | 无 | inverted, debounce, connected_to |
| 电磁阀 | solenoid_valve | connected_to, response_time | type |
| 气缸 | cylinder | connected_to, stroke_time, retract_time | type, stroke |
| 传感器 | sensor | connected_to, detects | type |
| 电机 | motor | connected_to | rated_speed, ramp_time |

说明：`digital_input` 和 `digital_output` 有两种用法：
- **裸端口声明**：`device Y0: digital_output` — 仅声明物理端口，无额外属性

thinking
**Considering large test sample**
exec
/bin/bash -lc "bash -lc 'sed -n \"492,560p\" prd.md'" in /mnt/e/personal_project/rust_plc succeeded in 51ms:
```

#### 5.5.3 故障处理

```plc
task fault_handler:
    step safe_position:
        action: retract cyl_A
        action: retract cyl_B
    step alarm:
        action: set alarm_light on
        action: log "动作超时，已执行安全复位"
    on_complete: goto ready
```

#### 5.5.4 并行执行

两个动作同时开始，全部完成后继续：

```plc

thinking
**Inspecting error handling and AST structures**
exec
/bin/bash -lc "bash -lc 'sed -n \"1,340p\" src/ast/mod.rs'" in /mnt/e/personal_project/rust_plc succeeded in 51ms:
use serde::{Deserialize, Serialize};

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct PlcProgram {
    pub topology: TopologySection,
    pub constraints: ConstraintsSection,
    pub tasks: TasksSection,
}

#[derive(Debug, Clone, Serialize, Deserialize, Default)]
pub struct TopologySection {
    pub devices: Vec<DeviceDeclaration>,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct DeviceDeclaration {
    #[serde(default)]
    pub line: usize,
    pub name: String,
    pub device_type: DeviceType,


thinking
**Designing SMT-based safety verification**
thinking
**Modeling device states with SMT and k-induction flow**
exec
/bin/bash -lc "bash -lc 'sed -n \"840,1045p\" src/semantic/mod.rs'" in /mnt/e/personal_project/rust_plc succeeded in 50ms:
            StepStatement::AllowIndefiniteWait(_) => {}
        }
    }

    analyzed
}

fn build_parallel_block(
    builder: &mut StateMachineBuilder,
    task: &TaskDeclaration,
    step_name: &str,
    source_state: &State,
    block_index: usize,
    block: &ParallelBlock,
    completion_target: Option<State>,
    task_initial_states: &HashMap<String, State>,
    errors: &mut Vec<PlcError>,
    parent_actions: Vec<TransitionAction>,
) {
    let fork_state_name = format!("{step_name}__parallel_{}_fork", block_index + 1);

thinking
**Designing SMT encoding and induction**
Plan update
  ✓ Inspect current verification/state-machine data paths and identify insertion points for Safety checker + Z3
  → Implement `src/verification/safety.rs` with k-induction/BMC behavior and warnings, then wire module/dependencies
  • Add/adjust tests for required safety scenarios and run quality checks
  • Update `prd.json` + `progress.txt`, then commit changes with required message

thinking
**Designing comprehensive safety module**
exec
/bin/bash -lc "bash -lc 'sed -n \"1,260p\" examples/two_cylinder.plc'" in /mnt/e/personal_project/rust_plc succeeded in 51ms:
[topology]

device Y0: digital_output
device Y1: digital_output
device X0: digital_input
device X1: digital_input
device X2: digital_input
device X3: digital_input
device X4: digital_input

device start_button: digital_input {
    connected_to: X4
    debounce: 20ms
}

device valve_A: solenoid_valve {
    connected_to: Y0
    response_time: 20ms
}


thinking
**Designing parallel and SCC verification tests**
exec
/bin/bash -lc "bash -lc 'cat > src/verification/safety.rs <<\"EOF\"
use crate::ast::{DeviceType, PlcProgram};
use crate::ir::{
    ConstraintSet, SafetyRelation, State, StateMachine, Transition, TransitionAction, TransitionGuard,
};
use petgraph::algo::kosaraju_scc;
use petgraph::graph::DiGraph;
use std::collections::HashMap;
use std::fmt;
use z3::ast::{Ast, Bool};
use z3::{Config, Context, Model, SatResult, Solver};

#[derive(Debug, Clone, Default)]
pub struct SafetyConfig {
    pub bmc_max_depth: Option<usize>,
}

#[derive(Debug, Clone, PartialEq, Eq)]
pub enum SafetyProofLevel {
    Complete,
    Bounded,
}

#[derive(Debug, Clone, PartialEq, Eq)]
pub struct SafetyReport {
    pub level: SafetyProofLevel,
    pub explored_depth: usize,
    pub warnings: Vec<String>,
}

#[derive(Debug, Clone, PartialEq, Eq)]
pub struct SafetyDiagnostic {
    pub line: usize,
    pub constraint: String,
    pub violation_path: Vec<String>,
    pub suggestion: String,
}

impl fmt::Display for SafetyDiagnostic {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        writeln"'!(f, "ERROR [safety] 状态互斥违反")?;
        writeln!(f, "  位置: <input>:{}:1", self.line)?;
        writeln!(f, "  约束: {}", self.constraint)?;
        writeln!(f, "  违反路径:")?;
        for (index, step) in self.violation_path.iter().enumerate() {
            writeln!(f, "    {}. {step}", index + 1)?;
        }
        write!(f, "  建议: {}", self.suggestion)
    }
}

#[derive(Debug, Clone)]
struct DeviceDomain {
    name: String,
    states: Vec<String>,
    default_state: usize,
}

#[derive(Debug, Clone)]
struct ModelEdge {
    from: usize,
    to: usize,
    effects: HashMap<usize, usize>,
    label: String,
}

#[derive(Debug, Clone)]
struct SafetyModel {
    states: Vec<State>,
    initial_state: usize,
    edges: Vec<ModelEdge>,
    outgoing: Vec<Vec<usize>>,
    devices: Vec<DeviceDomain>,
    device_index: HashMap<String, usize>,
    device_state_index: Vec<HashMap<String, usize>>,
    suggested_depth: usize,
    max_scc_depth: usize,
}

#[derive(Debug, Clone, Copy)]
struct RuleBinding {
    left_device: usize,
    left_state: usize,
    right_device: usize,
    right_state: usize,
}

#[derive(Debug, Clone)]
struct DepthPlan {
    effective_depth: usize,
    warnings: Vec<String>,
}

#[derive(Debug, Clone)]
struct PathVars<'"'ctx> {
    state: Vec<Vec<Bool<'ctx>>>,
    edge: Vec<Vec<Bool<'ctx>>>,
    device: Vec<Vec<Vec<Bool<'ctx>>>>,
}

#[derive(Debug, Clone)]
struct Counterexample {
    violation_step: usize,
    path: Vec<String>,
}

#[derive(Debug, Clone, Copy, PartialEq, Eq)]
enum RuleOutcome {
    Complete,
    Bounded,
}

pub fn verify_safety(
    program: &PlcProgram,
    constraints: &ConstraintSet,
    state_machine: &StateMachine,
) -> Result<SafetyReport, Vec<SafetyDiagnostic>> {
    verify_safety_with_config(program, constraints, state_machine, SafetyConfig::default())
}

pub fn verify_safety_with_config(
    program: &PlcProgram,
    constraints: &ConstraintSet,
    state_machine: &StateMachine,
    config: SafetyConfig,
) -> Result<SafetyReport, Vec<SafetyDiagnostic>> {
    let model = SafetyModel::from_inputs(program, constraints, state_machine);
    let depth_plan = build_depth_plan(&model, &config);

    let mut diagnostics = Vec::new();
    let mut all_complete = true;
    let mut checked_rules = 0usize;

    for (index, rule) in constraints.safety.iter().enumerate() {
        if "'!matches!(rule.relation, SafetyRelation::ConflictsWith) {
            continue;
        }

        let Some(binding) = bind_rule(&model, &rule.left.device, &rule.left.state, &rule.right.device, &rule.right.state) else {
            continue;
        };

        checked_rules += 1;
        let rule_text = format!(
            "{}.{} conflicts_with {}.{}",
            rule.left.device, rule.left.state, rule.right.device, rule.right.state
        );

        let line = program
            .constraints
            .safety
            .get(index)
            .map(|node| node.line.max(1))
            .unwrap_or(1);

        if let Some(counterexample) = find_counterexample(&model, binding, depth_plan.effective_depth) {
            diagnostics.push(SafetyDiagnostic {
                line,
                constraint: rule_text,
                violation_path: counterexample.path,
                suggestion: format!(
                    "请在触发 {} 之前确保 {} 已复位，或调整并行/跳转逻辑避免两者同时成立",
                    state_expr_text(&rule.right.device, &rule.right.state),
                    state_expr_text(&rule.left.device, &rule.left.state)
                ),
            });
            continue;
        }

        let outcome = verify_rule_by_k_induction(&model, binding, depth_plan.effective_depth);
        if outcome == RuleOutcome::Bounded {
            all_complete = false;
        }
    }

    if !diagnostics.is_empty() {
        return Err(diagnostics);
    }

    let mut warnings = depth_plan.warnings;
    let level = if checked_rules == 0 || all_complete {
        SafetyProofLevel::Complete
    } else {
        warnings.push(format!(
            "WARNING: Safety 在深度 {} 内未发现反例，但未获得完备证明。建议增大 bmc_max_depth 以提升有界覆盖，或调整模型以帮助 k-induction 收敛",
            depth_plan.effective_depth
        ));
        SafetyProofLevel::Bounded
    };

    Ok(SafetyReport {
        level,
        explored_depth: depth_plan.effective_depth,
        warnings,
    })
}

impl SafetyModel {
    fn from_inputs(
        program: &PlcProgram,
        constraints: &ConstraintSet,
        state_machine: &StateMachine,
    ) -> Self {
        let mut states = state_machine.states.clone();
        if states.is_empty() {
            states.push(state_machine.initial.clone());
        }

        let mut state_index = HashMap::<(String, String), usize>::new();
        for (index, state) in states.iter().enumerate() {
            state_index.insert(
                (state.task_name.clone(), state.step_name.clone()),
                index,
            );
        }

        let initial_state = state_index
            .get(&(
                state_machine.initial.task_name.clone(),
                state_machine.initial.step_name.clone(),
            ))
            .copied()
            .unwrap_or(0);

        let (devices, device_index, device_state_index) =
            collect_device_domains(program, constraints);

        let mut edges = Vec::new();
        let mut outgoing = vec![Vec::new(); states.len()];

        for transition in &state_machine.transitions {
            let Some(from) = state_index
                .get(&(transition.from.task_name.clone(), transition.from.step_name.clone()))
                .copied()
            else {
                continue;
            };
            let Some(to) = state_index
                .get(&(transition.to.task_name.clone(), transition.to.step_name.clone()))
                .copied()
            else {
                continue;
            };

            let effects = transition_effects(transition, &device_index, &device_state_index);
            let edge_index = edges.len();
            edges.push(ModelEdge {
                from,
                to,
                effects,
                label: transition_label(transition),
            });
            outgoing[from].push(edge_index);
        }

        for state_id in 0..states.len() {
            if !outgoing[state_id].is_empty() {
                continue;
            }

            let edge_index = edges.len();
            edges.push(ModelEdge {
                from: state_id,
                to: state_id,
                effects: HashMap::new(),
                label: "无出边，保持当前状态".to_string(),
            });
            outgoing[state_id].push(edge_index);
        }

        let max_scc_depth = scc_minimum_depth(states.len(), &edges);
        let suggested_depth = states.len().max(max_scc_depth).max(1);

        Self {
            states,
            initial_state,
            edges,
            outgoing,
            devices,
            device_index,
            device_state_index,
            suggested_depth,
            max_scc_depth,
        }
    }
}

fn collect_device_domains(
    program: &PlcProgram,
    constraints: &ConstraintSet,
) -> (
    Vec<DeviceDomain>,
    HashMap<String, usize>,
    Vec<HashMap<String, usize>>,
) {
    let mut devices = Vec::<DeviceDomain>::new();
    let mut device_index = HashMap::<String, usize>::new();

    for device in &program.topology.devices {
        let states = match device.device_type {
            DeviceType::Cylinder => vec!["extended".to_string(), "retracted".to_string()],
            DeviceType::DigitalOutput
            | DeviceType::DigitalInput
            | DeviceType::SolenoidValve
            | DeviceType::Sensor
            | DeviceType::Motor => vec!["on".to_string(), "off".to_string()],
        };

        let default_state_name = match device.device_type {
            DeviceType::Cylinder => "retracted",
            _ => "off",
        };

        let default_state = states
            .iter()
            .position(|state| state == default_state_name)
            .unwrap_or(0);

        let index = devices.len();
        devices.push(DeviceDomain {
            name: device.name.clone(),
            states,
            default_state,
        });
        device_index.insert(device.name.clone(), index);
    }

    for rule in &constraints.safety {
        let Some(left_device) = device_index.get(&rule.left.device).copied() else {
            continue;
        };
        ensure_device_state(&mut devices[left_device], &rule.left.state);

        let Some(right_device) = device_index.get(&rule.right.device).copied() else {
            continue;
        };
        ensure_device_state(&mut devices[right_device], &rule.right.state);
    }

    let mut state_index = Vec::with_capacity(devices.len());
    for domain in &devices {
        let mut map = HashMap::new();
        for (idx, state) in domain.states.iter().enumerate() {
            map.insert(state.clone(), idx);
        }
        state_index.push(map);
    }

    (devices, device_index, state_index)
}

fn ensure_device_state(domain: &mut DeviceDomain, state_name: &str) {
    if domain.states.iter().any(|state| state == state_name) {
        return;
    }

    domain.states.push(state_name.to_string());
}

fn transition_effects(
    transition: &Transition,
    device_index: &HashMap<String, usize>,
    device_state_index: &[HashMap<String, usize>],
) -> HashMap<usize, usize> {
    let mut effects = HashMap::<usize, usize>::new();

    for action in &transition.actions {
        let Some((target_device, target_state)) = action_effect(action) else {
            continue;
        };

        let Some(device_id) = device_index.get(target_device).copied() else {
            continue;
        };

        let Some(state_id) = device_state_index[device_id].get(target_state).copied() else {
            continue;
        };

        effects.insert(device_id, state_id);
    }

    effects
}

fn action_effect(action: &TransitionAction) -> Option<(&str, &str)> {
    match action {
        TransitionAction::Extend { target } => Some((target.as_str(), "extended")),
        TransitionAction::Retract { target } => Some((target.as_str(), "retracted")),
        TransitionAction::Set { target, value } => {
            let state = match value {
                crate::ir::BinaryValue::On => "on",
                crate::ir::BinaryValue::Off => "off",
            };
            Some((target.as_str(), state))
        }
        TransitionAction::Log { .. } => None,
    }
}

fn transition_label(transition: &Transition) -> String {
    let guard = guard_name(&transition.guard);
    let action_text = transition
        .actions
        .iter()
        .filter_map(action_name)
        .collect::<Vec<_>>();

    if action_text.is_empty() {
        guard.to_string()
    } else {
        format!("{}；动作: {}", guard, action_text.join(", "))
    }
}

fn guard_name(guard: &TransitionGuard) -> &'"'static str {
    match guard {
        TransitionGuard::Always => \"always\",
        TransitionGuard::Condition { .. } => \"condition\",
        TransitionGuard::Timeout { .. } => \"timeout\",
    }
}

fn action_name(action: &TransitionAction) -> Option<String> {
    match action {
        TransitionAction::Extend { target } => Some(format"'!("extend {target}")),
        TransitionAction::Retract { target } => Some(format!("retract {target}")),
        TransitionAction::Set { target, value } => Some(format!(
            "set {} {}",
            target,
            match value {
                crate::ir::BinaryValue::On => "on",
                crate::ir::BinaryValue::Off => "off",
            }
        )),
        TransitionAction::Log { message } => Some(format!("log '"\\\"{message}\\\"\")),
    }
}

fn scc_minimum_depth(state_count: usize, edges: &[ModelEdge]) -> usize {
    if state_count == 0 {
        return 1;
    }

    let mut graph = DiGraph::<usize, ()>::new();
    let mut nodes = Vec::with_capacity(state_count);
    for index in 0..state_count {
        nodes.push(graph.add_node(index));
    }

    for edge in edges {
        if edge.from >= state_count || edge.to >= state_count {
            continue;
        }
        graph.add_edge(nodes[edge.from], nodes[edge.to], ());
    }

    let mut depth_requirement = 0usize;
    for component in kosaraju_scc(&graph) {
        if component.is_empty() {
            continue;
        }

        let has_cycle = component.len() > 1
            || graph
                .edges(component[0])
                .any(|edge| edge.target() == component[0]);

        if "'!has_cycle {
            continue;
        }

        depth_requirement = depth_requirement.max(component.len() + 1);
    }

    depth_requirement
}

fn build_depth_plan(model: &SafetyModel, config: &SafetyConfig) -> DepthPlan {
    let target_depth = model.suggested_depth;
    let mut warnings = Vec::new();

    let effective_depth = if let Some(user_limit) = config.bmc_max_depth {
        if user_limit < target_depth {
            let reason = if model.max_scc_depth > 0 && user_limit < model.max_scc_depth {
                format!(
                    "WARNING: bmc_max_depth={} 小于 SCC 建议深度 {}，Safety 搜索将截断至 {}（有界验证）",
                    user_limit, model.max_scc_depth, user_limit
                )
            } else {
                format!(
                    "WARNING: bmc_max_depth={} 小于建议展开深度 {}，Safety 搜索将截断至 {}（有界验证）",
                    user_limit, target_depth, user_limit
                )
            };
            warnings.push(reason);
            user_limit
        } else {
            user_limit
        }
    } else {
        target_depth
    };

    DepthPlan {
        effective_depth: effective_depth.max(1),
        warnings,
    }
}

fn bind_rule(
    model: &SafetyModel,
    left_device: &str,
    left_state: &str,
    right_device: &str,
    right_state: &str,
) -> Option<RuleBinding> {
    let left_device_id = model.device_index.get(left_device).copied()?;
    let right_device_id = model.device_index.get(right_device).copied()?;

    let left_state_id = model.device_state_index[left_device_id]
        .get(left_state)
        .copied()?;
    let right_state_id = model.device_state_index[right_device_id]
        .get(right_state)
        .copied()?;

    Some(RuleBinding {
        left_device: left_device_id,
        left_state: left_state_id,
        right_device: right_device_id,
        right_state: right_state_id,
    })
}

fn verify_rule_by_k_induction(model: &SafetyModel, rule: RuleBinding, max_depth: usize) -> RuleOutcome {
    for k in 0..=max_depth {
        if k_induction_step_holds(model, rule, k) {
            return RuleOutcome::Complete;
        }
    }

    RuleOutcome::Bounded
}

fn find_counterexample(
    model: &SafetyModel,
    rule: RuleBinding,
    max_depth: usize,
) -> Option<Counterexample> {
    let mut cfg = Config::new();
    cfg.set_model_generation(true);
    let ctx = Context::new(&cfg);
    let solver = Solver::new(&ctx);

    let vars = create_path_vars(&ctx, model, max_depth);
    assert_path_constraints(&ctx, &solver, model, &vars, max_depth, true);

    let violation = (0..=max_depth)
        .map(|step| conflict_at_step(&ctx, &vars, step, rule))
        .collect::<Vec<_>>();
    solver.assert(&or_all(&ctx, &violation));

    if solver.check() != SatResult::Sat {
        return None;
    }

    let model_ast = solver.get_model()?;
    let mut violation_step = 0usize;
    for step in 0..=max_depth {
        if evaluate_conflict(&model_ast, &vars, step, rule) {
            violation_step = step;
            break;
        }
    }

    let path = render_path(model, &vars, &model_ast, rule, violation_step);

    Some(Counterexample {
        violation_step,
        path,
    })
}

fn k_induction_step_holds(model: &SafetyModel, rule: RuleBinding, k: usize) -> bool {
    let mut cfg = Config::new();
    cfg.set_model_generation(false);
    let ctx = Context::new(&cfg);
    let solver = Solver::new(&ctx);

    let depth = k + 1;
    let vars = create_path_vars(&ctx, model, depth);
    assert_path_constraints(&ctx, &solver, model, &vars, depth, false);

    for step in 0..=k {
        solver.assert(&conflict_at_step(&ctx, &vars, step, rule).not());
    }
    solver.assert(&conflict_at_step(&ctx, &vars, k + 1, rule));

    solver.check() == SatResult::Unsat
}

fn create_path_vars<'"'ctx>(ctx: &'ctx Context, model: &SafetyModel, depth: usize) -> PathVars<'ctx> {
    let mut state = Vec::with_capacity(depth + 1);
    for step in 0..=depth {
        let row = (0..model.states.len())
            .map(|state_id| Bool::new_const(ctx, format"'!("s_{}_{}", step, state_id)))
            .collect::<Vec<_>>();
        state.push(row);
    }

    let mut edge = Vec::with_capacity(depth);
    for step in 0..depth {
        let row = (0..model.edges.len())
            .map(|edge_id| Bool::new_const(ctx, format!("e_{}_{}", step, edge_id)))
            .collect::<Vec<_>>();
        edge.push(row);
    }

    let mut device = Vec::with_capacity(depth + 1);
    for step in 0..=depth {
        let mut device_row = Vec::with_capacity(model.devices.len());
        for (device_id, domain) in model.devices.iter().enumerate() {
            let state_row = (0..domain.states.len())
                .map(|state_id| {
                    Bool::new_const(
                        ctx,
                        format!("d_{}_{}_{}", step, device_id, state_id),
                    )
                })
                .collect::<Vec<_>>();
            device_row.push(state_row);
        }
        device.push(device_row);
    }

    PathVars {
        state,
        edge,
        device,
    }
}

fn assert_path_constraints<'"'ctx>(
    ctx: &'ctx Context,
    solver: &Solver<'ctx>,
    model: &SafetyModel,
    vars: &PathVars<'ctx>,
    depth: usize,
    anchor_initial: bool,
) {
    for step in 0..=depth {
        assert_exactly_one(ctx, solver, &vars.state[step]);
        for device_states in &vars.device[step] {
            assert_exactly_one(ctx, solver, device_states);
        }
    }

    if anchor_initial {
        solver.assert(&vars.state[0][model.initial_state]);
        for (device_id, domain) in model.devices.iter().enumerate() {
            solver.assert(&vars.device[0][device_id][domain.default_state]);
        }
    }

    for step in 0..depth {
        assert_exactly_one(ctx, solver, &vars.edge[step]);

        for (edge_id, edge_model) in model.edges.iter().enumerate() {
            let edge_var = &vars.edge[step][edge_id];
            solver.assert(&edge_var.implies(&vars.state[step][edge_model.from]));
            solver.assert(&edge_var.implies(&vars.state[step + 1][edge_model.to]));

            for device_id in 0..model.devices.len() {
                if let Some(&next_state_id) = edge_model.effects.get(&device_id) {
                    solver.assert(&edge_var.implies(&vars.device[step + 1][device_id][next_state_id]));
                    continue;
                }

                for state_id in 0..model.devices[device_id].states.len() {
                    solver.assert(&edge_var.implies(
                        &vars.device[step + 1][device_id][state_id]
                            ._eq(&vars.device[step][device_id][state_id]),
                    ));
                }
            }
        }

        for state_id in 0..model.states.len() {
            let outgoing = model.outgoing[state_id]
                .iter()
                .map(|&edge_id| vars.edge[step][edge_id].clone())
                .collect::<Vec<_>>();
            solver.assert(&vars.state[step][state_id].implies(&or_all(ctx, &outgoing)));
        }
    }
}

fn assert_exactly_one<'ctx>(ctx: &'ctx Context, solver: &Solver<'ctx>, vars: &[Bool<'ctx>]) {
    if vars.is_empty() {
        return;
    }

    solver.assert(&or_all(ctx, vars));
    for i in 0..vars.len() {
        for j in (i + 1)..vars.len() {
            solver.assert(&vars[i].implies(&vars[j].not()));
        }
    }
}

fn or_all<'ctx>(ctx: &'ctx Context, vars: &[Bool<'ctx>]) -> Bool<'ctx> {
    if vars.is_empty() {
        return Bool::from_bool(ctx, false);
    }

    let refs = vars.iter().collect::<Vec<_>>();
    Bool::or(ctx, &refs)
}

fn conflict_at_step<'ctx>(ctx: &'ctx Context, vars: &PathVars<'ctx>, step: usize, rule: RuleBinding) -> Bool<'ctx> {
    Bool::and(
        ctx,
        &[
            &vars.device[step][rule.left_device][rule.left_state],
            &vars.device[step][rule.right_device][rule.right_state],
        ],
    )
}

fn evaluate_conflict(
    model: &Model<'_>,
    vars: &PathVars<'_>,
    step: usize,
    rule: RuleBinding,
) -> bool {
    evaluate_bool(model, &vars.device[step][rule.left_device][rule.left_state])
        && evaluate_bool(model, &vars.device[step][rule.right_device][rule.right_state])
}

fn render_path(
    model: &SafetyModel,
    vars: &PathVars<'_>,
    z3_model: &Model<'_>,
    rule: RuleBinding,
    violation_step: usize,
) -> Vec<String> {
    let mut lines = Vec::new();

    let initial_state = active_state(model, vars, z3_model, 0).unwrap_or(model.initial_state);
    lines.push(format"'!("初始状态 {}", state_name(&model.states[initial_state])));

    for step in 0..violation_step {
        let edge_id = active_edge(model, vars, z3_model, step).unwrap_or_else(|| {
            model.outgoing[active_state(model, vars, z3_model, step).unwrap_or(model.initial_state)]
                .first()
                .copied()
                .unwrap_or(0)
        });

        let edge = &model.edges[edge_id];
        let from = state_name(&model.states[edge.from]);
        let to = state_name(&model.states[edge.to]);
        lines.push(format!("{from} --[{}]--> {to}", edge.label));
    }

    let conflict_state = active_state(model, vars, z3_model, violation_step)
        .and_then(|state_id| model.states.get(state_id))
        .map(state_name)
        .unwrap_or_else(|| "未知状态".to_string());

    lines.push(format!(
        "在 {} 检测到冲突：{}.{} 与 {}.{} 同时为真",
        conflict_state,
        model.devices[rule.left_device].name,
        model.devices[rule.left_device].states[rule.left_state],
        model.devices[rule.right_device].name,
        model.devices[rule.right_device].states[rule.right_state],
    ));

    lines
}

fn active_state(
    model: &SafetyModel,
    vars: &PathVars<'"'_>,
    z3_model: &Model<'_>,
    step: usize,
) -> Option<usize> {
    (0..model.states.len())
        .find(|&state_id| evaluate_bool(z3_model, &vars.state[step][state_id]))
}

fn active_edge(
    model: &SafetyModel,
    vars: &PathVars<'_>,
    z3_model: &Model<'_>,
    step: usize,
) -> Option<usize> {
    if step >= vars.edge.len() {
        return None;
    }

    (0..model.edges.len()).find(|&edge_id| evaluate_bool(z3_model, &vars.edge[step][edge_id]))
}

fn evaluate_bool(model: &Model<'_>, value: &Bool<'_>) -> bool {
    model
        .eval(value, true)
        .and_then(|eval| eval.as_bool())
        .unwrap_or(false)
}

fn state_name(state: &State) -> String {
    format"'!("{}.{}", state.task_name, state.step_name)
}

fn state_expr_text(device: &str, state: &str) -> String {
    format!("{device}.{state}")
}

#[cfg(test)]
mod tests {
    use super::{verify_safety, verify_safety_with_config, SafetyConfig, SafetyProofLevel};
    use crate::parser::parse_plc;
    use crate::semantic::{build_constraint_set, build_state_machine};

    #[test]
    fn proves_two_cylinder_sequence_without_parallel_conflict() {
        let source = r#"
[topology]

device Y0: digital_output
device Y1: digital_output

device valve_A: solenoid_valve {
    connected_to: Y0
    response_time: 20ms
}

device valve_B: solenoid_valve {
    connected_to: Y1
    response_time: 20ms
}

device cyl_A: cylinder {
    connected_to: valve_A
    stroke_time: 300ms
    retract_time: 300ms
}

device cyl_B: cylinder {
    connected_to: valve_B
    stroke_time: 300ms
    retract_time: 300ms
}

[constraints]

safety: cyl_A.extended conflicts_with cyl_B.extended

[tasks]

task init:
    step extend_A:
        action: extend cyl_A
    step retract_A:
        action: retract cyl_A
    step extend_B:
        action: extend cyl_B
    step retract_B:
        action: retract cyl_B
"#;

        let program = parse_plc(source).expect("测试程序应能解析");
        let constraints = build_constraint_set(&program).expect("约束应能构建");
        let state_machine = build_state_machine(&program).expect("状态机应能构建");

        let report = verify_safety(&program, &constraints, &state_machine)
            .expect("顺序双气缸逻辑不应违反互斥约束");

        assert!(
            matches!(report.level, SafetyProofLevel::Complete | SafetyProofLevel::Bounded),
            "验证结果应返回有效级别"
        );
        assert!(report.explored_depth >= state_machine.states.len());
    }

    #[test]
    fn reports_conflict_for_parallel_extend_actions() {
        let source = r#"
[topology]

device Y0: digital_output
device Y1: digital_output

device valve_A: solenoid_valve {
    connected_to: Y0
}

device valve_B: solenoid_valve {
    connected_to: Y1
}

device cyl_A: cylinder {
    connected_to: valve_A
    stroke_time: 200ms
    retract_time: 200ms
}

device cyl_B: cylinder {
    connected_to: valve_B
    stroke_time: 200ms
    retract_time: 200ms
}

[constraints]

safety: cyl_A.extended conflicts_with cyl_B.extended

[tasks]

task parallel_demo:
    step move_together:
        parallel:
            branch_A:
                action: extend cyl_A
            branch_B:
                action: extend cyl_B
"#;

        let program = parse_plc(source).expect("测试程序应能解析");
        let constraints = build_constraint_set(&program).expect("约束应能构建");
        let state_machine = build_state_machine(&program).expect("状态机应能构建");

        let errors = verify_safety(&program, &constraints, &state_machine)
            .expect_err("并行伸出冲突气缸时应触发 safety 错误");

        assert!(
            errors
                .iter()
                .any(|error| error.to_string().contains("conflicts_with")),
            "错误应包含冲突约束说明"
        );
        assert!(
            errors.iter().all(|error| error.line > 0),
            "错误应携带行号"
        );
    }

    #[test]
    fn uses_scc_size_plus_one_as_default_depth_floor() {
        let source = r#"
[topology]

device Y0: digital_output
device valve_A: solenoid_valve {
    connected_to: Y0
}
device cyl_A: cylinder {
    connected_to: valve_A
    stroke_time: 100ms
    retract_time: 100ms
}

device Y1: digital_output
device valve_B: solenoid_valve {
    connected_to: Y1
}
device cyl_B: cylinder {
    connected_to: valve_B
    stroke_time: 100ms
    retract_time: 100ms
}

[constraints]

safety: cyl_A.extended conflicts_with cyl_B.extended

[tasks]

task init:
    step a:
        action: retract cyl_A
    on_complete: goto loop

task loop:
    step b:
        action: retract cyl_B
    on_complete: goto init
"#;

        let program = parse_plc(source).expect("测试程序应能解析");
        let constraints = build_constraint_set(&program).expect("约束应能构建");
        let state_machine = build_state_machine(&program).expect("状态机应能构建");

        let report = verify_safety(&program, &constraints, &state_machine)
            .expect("不含冲突动作时 safety 应通过");

        assert!(
            report.explored_depth >= 3,
            "SCC(2节点) 场景默认深度应至少为 |SCC|+1=3"
        );
    }

    #[test]
    fn warns_when_bmc_max_depth_caps_default_search_depth() {
        let source = r#"
[topology]

device Y0: digital_output
device valve_A: solenoid_valve {
    connected_to: Y0
}
device cyl_A: cylinder {
    connected_to: valve_A
    stroke_time: 100ms
    retract_time: 100ms
}

device Y1: digital_output
device valve_B: solenoid_valve {
    connected_to: Y1
}
device cyl_B: cylinder {
    connected_to: valve_B
    stroke_time: 100ms
    retract_time: 100ms
}

[constraints]

safety: cyl_A.extended conflicts_with cyl_B.extended

[tasks]

task init:
    step one:
        action: retract cyl_A
    step two:
        action: retract cyl_B
"#;

        let program = parse_plc(source).expect("测试程序应能解析");
        let constraints = build_constraint_set(&program).expect("约束应能构建");
        let state_machine = build_state_machine(&program).expect("状态机应能构建");

        let report = verify_safety_with_config(
            &program,
            &constraints,
            &state_machine,
            SafetyConfig {
                bmc_max_depth: Some(1),
            },
        )
        .expect("应返回有界验证结果");

        assert_eq!(report.explored_depth, 1);
        assert!(
            report
                .warnings
                .iter()
                .any(|warning| warning.contains("bmc_max_depth=1")),
            "当用户上限截断默认展开深度时应输出警告"
        );
    }

    #[test]
    fn warns_when_bmc_limit_is_lower_than_scc_requirement() {
        let source = r#"
[topology]

device Y0: digital_output
device valve_A: solenoid_valve {
    connected_to: Y0
}
device cyl_A: cylinder {
    connected_to: valve_A
    stroke_time: 100ms
    retract_time: 100ms
}

device Y1: digital_output
device valve_B: solenoid_valve {
    connected_to: Y1
}
device cyl_B: cylinder {
    connected_to: valve_B
    stroke_time: 100ms
    retract_time: 100ms
}

[constraints]

safety: cyl_A.extended conflicts_with cyl_B.extended

[tasks]

task init:
    step a:
        action: retract cyl_A
    on_complete: goto loop

task loop:
    step b:
        action: retract cyl_B
    on_complete: goto init
"#;

        let program = parse_plc(source).expect("测试程序应能解析");
        let constraints = build_constraint_set(&program).expect("约束应能构建");
        let state_machine = build_state_machine(&program).expect("状态机应能构建");

        let report = verify_safety_with_config(
            &program,
            &constraints,
            &state_machine,
            SafetyConfig {
                bmc_max_depth: Some(2),
            },
        )
        .expect("应返回有界验证结果");

        assert_eq!(report.explored_depth, 2);
        assert!(
            report
                .warnings
                .iter()
                .any(|warning| warning.contains("SCC")),
            "bmc_max_depth 小于 |SCC|+1 时应输出 SCC 截断警告"
        );
        assert!(
            report
                .warnings
                .iter()
                .any(|warning| warning.contains("WARNING: Safety 在深度 2 内未发现反例")),
            "截断后应输出有界验证警告"
        );
    }
}
EOF'"'" in /mnt/e/personal_project/rust_plc exited 2 in 51ms:
/bin/bash: -c: line 40: syntax error near unexpected token `)'
/bin/bash: -c: line 40: `    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {'

thinking
**Fixing heredoc quoting conflicts**
exec
/bin/bash -lc "cat > src/verification/safety.rs <<'EOF'
use crate::ast::{DeviceType, PlcProgram};
use crate::ir::{
    ConstraintSet, SafetyRelation, State, StateMachine, Transition, TransitionAction, TransitionGuard,
};
use petgraph::algo::kosaraju_scc;
use petgraph::graph::DiGraph;
use petgraph::visit::EdgeRef;
use std::collections::HashMap;
use std::fmt;
use z3::ast::{Ast, Bool};
use z3::{Config, Context, Model, SatResult, Solver};

#[derive(Debug, Clone, Default)]
pub struct SafetyConfig {
    pub bmc_max_depth: Option<usize>,
}

#[derive(Debug, Clone, PartialEq, Eq)]
pub enum SafetyProofLevel {
    Complete,
    Bounded,
}

#[derive(Debug, Clone, PartialEq, Eq)]
pub struct SafetyReport {
    pub level: SafetyProofLevel,
    pub explored_depth: usize,
    pub warnings: Vec<String>,
}

#[derive(Debug, Clone, PartialEq, Eq)]
pub struct SafetyDiagnostic {
    pub line: usize,
    pub constraint: String,
    pub violation_path: Vec<String>,
    pub suggestion: String,
}

impl fmt::Display for SafetyDiagnostic {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        writeln"'!(f, "ERROR [safety] 状态互斥违反")?;
        writeln!(f, "  位置: <input>:{}:1", self.line)?;
        writeln!(f, "  约束: {}", self.constraint)?;
        writeln!(f, "  违反路径:")?;
        for (index, step) in self.violation_path.iter().enumerate() {
            writeln!(f, "    {}. {step}", index + 1)?;
        }
        write!(f, "  建议: {}", self.suggestion)
    }
}

#[derive(Debug, Clone)]
struct DeviceDomain {
    name: String,
    states: Vec<String>,
    default_state: usize,
}

#[derive(Debug, Clone)]
struct ModelEdge {
    from: usize,
    to: usize,
    effects: HashMap<usize, usize>,
    label: String,
}

#[derive(Debug, Clone)]
struct SafetyModel {
    states: Vec<State>,
    initial_state: usize,
    edges: Vec<ModelEdge>,
    outgoing: Vec<Vec<usize>>,
    devices: Vec<DeviceDomain>,
    device_index: HashMap<String, usize>,
    device_state_index: Vec<HashMap<String, usize>>,
    suggested_depth: usize,
    max_scc_depth: usize,
}

#[derive(Debug, Clone, Copy)]
struct RuleBinding {
    left_device: usize,
    left_state: usize,
    right_device: usize,
    right_state: usize,
}

#[derive(Debug, Clone)]
struct DepthPlan {
    effective_depth: usize,
    warnings: Vec<String>,
}

#[derive(Debug, Clone)]
struct PathVars<'"'ctx> {
    state: Vec<Vec<Bool<'ctx>>>,
    edge: Vec<Vec<Bool<'ctx>>>,
    device: Vec<Vec<Vec<Bool<'ctx>>>>,
}

#[derive(Debug, Clone)]
struct Counterexample {
    path: Vec<String>,
}

#[derive(Debug, Clone, Copy, PartialEq, Eq)]
enum RuleOutcome {
    Complete,
    Bounded,
}

pub fn verify_safety(
    program: &PlcProgram,
    constraints: &ConstraintSet,
    state_machine: &StateMachine,
) -> Result<SafetyReport, Vec<SafetyDiagnostic>> {
    verify_safety_with_config(program, constraints, state_machine, SafetyConfig::default())
}

pub fn verify_safety_with_config(
    program: &PlcProgram,
    constraints: &ConstraintSet,
    state_machine: &StateMachine,
    config: SafetyConfig,
) -> Result<SafetyReport, Vec<SafetyDiagnostic>> {
    let model = SafetyModel::from_inputs(program, constraints, state_machine);
    let depth_plan = build_depth_plan(&model, &config);

    let mut diagnostics = Vec::new();
    let mut all_complete = true;
    let mut checked_rules = 0usize;

    for (index, rule) in constraints.safety.iter().enumerate() {
        if "'!matches!(rule.relation, SafetyRelation::ConflictsWith) {
            continue;
        }

        let Some(binding) = bind_rule(
            &model,
            &rule.left.device,
            &rule.left.state,
            &rule.right.device,
            &rule.right.state,
        ) else {
            continue;
        };

        checked_rules += 1;
        let rule_text = format!(
            "{}.{} conflicts_with {}.{}",
            rule.left.device, rule.left.state, rule.right.device, rule.right.state
        );

        let line = program
            .constraints
            .safety
            .get(index)
            .map(|node| node.line.max(1))
            .unwrap_or(1);

        if let Some(counterexample) = find_counterexample(&model, binding, depth_plan.effective_depth)
        {
            diagnostics.push(SafetyDiagnostic {
                line,
                constraint: rule_text,
                violation_path: counterexample.path,
                suggestion: format!(
                    "请在触发 {} 之前确保 {} 已复位，或调整并行/跳转逻辑避免两者同时成立",
                    state_expr_text(&rule.right.device, &rule.right.state),
                    state_expr_text(&rule.left.device, &rule.left.state)
                ),
            });
            continue;
        }

        let outcome = verify_rule_by_k_induction(&model, binding, depth_plan.effective_depth);
        if outcome == RuleOutcome::Bounded {
            all_complete = false;
        }
    }

    if !diagnostics.is_empty() {
        return Err(diagnostics);
    }

    let mut warnings = depth_plan.warnings;
    let level = if checked_rules == 0 || all_complete {
        SafetyProofLevel::Complete
    } else {
        warnings.push(format!(
            "WARNING: Safety 在深度 {} 内未发现反例，但未获得完备证明。建议增大 bmc_max_depth 以提升有界覆盖，或调整模型以帮助 k-induction 收敛",
            depth_plan.effective_depth
        ));
        SafetyProofLevel::Bounded
    };

    Ok(SafetyReport {
        level,
        explored_depth: depth_plan.effective_depth,
        warnings,
    })
}

impl SafetyModel {
    fn from_inputs(
        program: &PlcProgram,
        constraints: &ConstraintSet,
        state_machine: &StateMachine,
    ) -> Self {
        let mut states = state_machine.states.clone();
        if states.is_empty() {
            states.push(state_machine.initial.clone());
        }

        let mut state_index = HashMap::<(String, String), usize>::new();
        for (index, state) in states.iter().enumerate() {
            state_index.insert((state.task_name.clone(), state.step_name.clone()), index);
        }

        let initial_state = state_index
            .get(&(
                state_machine.initial.task_name.clone(),
                state_machine.initial.step_name.clone(),
            ))
            .copied()
            .unwrap_or(0);

        let (devices, device_index, device_state_index) = collect_device_domains(program, constraints);

        let mut edges = Vec::new();
        let mut outgoing = vec![Vec::new(); states.len()];

        for transition in &state_machine.transitions {
            let Some(from) = state_index
                .get(&(transition.from.task_name.clone(), transition.from.step_name.clone()))
                .copied()
            else {
                continue;
            };
            let Some(to) = state_index
                .get(&(transition.to.task_name.clone(), transition.to.step_name.clone()))
                .copied()
            else {
                continue;
            };

            let effects = transition_effects(transition, &device_index, &device_state_index);
            let edge_index = edges.len();
            edges.push(ModelEdge {
                from,
                to,
                effects,
                label: transition_label(transition),
            });
            outgoing[from].push(edge_index);
        }

        for state_id in 0..states.len() {
            if !outgoing[state_id].is_empty() {
                continue;
            }

            let edge_index = edges.len();
            edges.push(ModelEdge {
                from: state_id,
                to: state_id,
                effects: HashMap::new(),
                label: "无出边，保持当前状态".to_string(),
            });
            outgoing[state_id].push(edge_index);
        }

        let max_scc_depth = scc_minimum_depth(states.len(), &edges);
        let suggested_depth = states.len().max(max_scc_depth).max(1);

        Self {
            states,
            initial_state,
            edges,
            outgoing,
            devices,
            device_index,
            device_state_index,
            suggested_depth,
            max_scc_depth,
        }
    }
}

fn collect_device_domains(
    program: &PlcProgram,
    constraints: &ConstraintSet,
) -> (
    Vec<DeviceDomain>,
    HashMap<String, usize>,
    Vec<HashMap<String, usize>>,
) {
    let mut devices = Vec::<DeviceDomain>::new();
    let mut device_index = HashMap::<String, usize>::new();

    for device in &program.topology.devices {
        let states = match device.device_type {
            DeviceType::Cylinder => vec!["extended".to_string(), "retracted".to_string()],
            DeviceType::DigitalOutput
            | DeviceType::DigitalInput
            | DeviceType::SolenoidValve
            | DeviceType::Sensor
            | DeviceType::Motor => vec!["on".to_string(), "off".to_string()],
        };

        let default_state_name = match device.device_type {
            DeviceType::Cylinder => "retracted",
            _ => "off",
        };

        let default_state = states
            .iter()
            .position(|state| state == default_state_name)
            .unwrap_or(0);

        let index = devices.len();
        devices.push(DeviceDomain {
            name: device.name.clone(),
            states,
            default_state,
        });
        device_index.insert(device.name.clone(), index);
    }

    for rule in &constraints.safety {
        let Some(left_device) = device_index.get(&rule.left.device).copied() else {
            continue;
        };
        ensure_device_state(&mut devices[left_device], &rule.left.state);

        let Some(right_device) = device_index.get(&rule.right.device).copied() else {
            continue;
        };
        ensure_device_state(&mut devices[right_device], &rule.right.state);
    }

    let mut state_index = Vec::with_capacity(devices.len());
    for domain in &devices {
        let mut map = HashMap::new();
        for (idx, state) in domain.states.iter().enumerate() {
            map.insert(state.clone(), idx);
        }
        state_index.push(map);
    }

    (devices, device_index, state_index)
}

fn ensure_device_state(domain: &mut DeviceDomain, state_name: &str) {
    if domain.states.iter().any(|state| state == state_name) {
        return;
    }

    domain.states.push(state_name.to_string());
}

fn transition_effects(
    transition: &Transition,
    device_index: &HashMap<String, usize>,
    device_state_index: &[HashMap<String, usize>],
) -> HashMap<usize, usize> {
    let mut effects = HashMap::<usize, usize>::new();

    for action in &transition.actions {
        let Some((target_device, target_state)) = action_effect(action) else {
            continue;
        };

        let Some(device_id) = device_index.get(target_device).copied() else {
            continue;
        };

        let Some(state_id) = device_state_index[device_id].get(target_state).copied() else {
            continue;
        };

        effects.insert(device_id, state_id);
    }

    effects
}

fn action_effect(action: &TransitionAction) -> Option<(&str, &str)> {
    match action {
        TransitionAction::Extend { target } => Some((target.as_str(), "extended")),
        TransitionAction::Retract { target } => Some((target.as_str(), "retracted")),
        TransitionAction::Set { target, value } => {
            let state = match value {
                crate::ir::BinaryValue::On => "on",
                crate::ir::BinaryValue::Off => "off",
            };
            Some((target.as_str(), state))
        }
        TransitionAction::Log { .. } => None,
    }
}

fn transition_label(transition: &Transition) -> String {
    let guard = guard_name(&transition.guard);
    let action_text = transition
        .actions
        .iter()
        .filter_map(action_name)
        .collect::<Vec<_>>();

    if action_text.is_empty() {
        guard.to_string()
    } else {
        format!("{}；动作: {}", guard, action_text.join(", "))
    }
}

fn guard_name(guard: &TransitionGuard) -> &'"'static str {
    match guard {
        TransitionGuard::Always => \"always\",
        TransitionGuard::Condition { .. } => \"condition\",
        TransitionGuard::Timeout { .. } => \"timeout\",
    }
}

fn action_name(action: &TransitionAction) -> Option<String> {
    match action {
        TransitionAction::Extend { target } => Some(format"'!("extend {target}")),
        TransitionAction::Retract { target } => Some(format!("retract {target}")),
        TransitionAction::Set { target, value } => Some(format!(
            "set {} {}",
            target,
            match value {
                crate::ir::BinaryValue::On => "on",
                crate::ir::BinaryValue::Off => "off",
            }
        )),
        TransitionAction::Log { message } => Some(format!("log '"\\\"{message}\\\"\")),
    }
}

fn scc_minimum_depth(state_count: usize, edges: &[ModelEdge]) -> usize {
    if state_count == 0 {
        return 1;
    }

    let mut graph = DiGraph::<usize, ()>::new();
    let mut nodes = Vec::with_capacity(state_count);
    for index in 0..state_count {
        nodes.push(graph.add_node(index));
    }

    for edge in edges {
        if edge.from >= state_count || edge.to >= state_count {
            continue;
        }
        graph.add_edge(nodes[edge.from], nodes[edge.to], ());
    }

    let mut depth_requirement = 0usize;
    for component in kosaraju_scc(&graph) {
        if component.is_empty() {
            continue;
        }

        let has_cycle = component.len() > 1
            || graph
                .edges(component[0])
                .any(|edge| edge.target() == component[0]);

        if "'!has_cycle {
            continue;
        }

        depth_requirement = depth_requirement.max(component.len() + 1);
    }

    depth_requirement
}

fn build_depth_plan(model: &SafetyModel, config: &SafetyConfig) -> DepthPlan {
    let target_depth = model.suggested_depth;
    let mut warnings = Vec::new();

    let effective_depth = if let Some(user_limit) = config.bmc_max_depth {
        if user_limit < target_depth {
            let reason = if model.max_scc_depth > 0 && user_limit < model.max_scc_depth {
                format!(
                    "WARNING: bmc_max_depth={} 小于 SCC 建议深度 {}，Safety 搜索将截断至 {}（有界验证）",
                    user_limit, model.max_scc_depth, user_limit
                )
            } else {
                format!(
                    "WARNING: bmc_max_depth={} 小于建议展开深度 {}，Safety 搜索将截断至 {}（有界验证）",
                    user_limit, target_depth, user_limit
                )
            };
            warnings.push(reason);
            user_limit
        } else {
            user_limit
        }
    } else {
        target_depth
    };

    DepthPlan {
        effective_depth: effective_depth.max(1),
        warnings,
    }
}

fn bind_rule(
    model: &SafetyModel,
    left_device: &str,
    left_state: &str,
    right_device: &str,
    right_state: &str,
) -> Option<RuleBinding> {
    let left_device_id = model.device_index.get(left_device).copied()?;
    let right_device_id = model.device_index.get(right_device).copied()?;

    let left_state_id = model.device_state_index[left_device_id]
        .get(left_state)
        .copied()?;
    let right_state_id = model.device_state_index[right_device_id]
        .get(right_state)
        .copied()?;

    Some(RuleBinding {
        left_device: left_device_id,
        left_state: left_state_id,
        right_device: right_device_id,
        right_state: right_state_id,
    })
}

fn verify_rule_by_k_induction(model: &SafetyModel, rule: RuleBinding, max_depth: usize) -> RuleOutcome {
    for k in 0..=max_depth {
        if k_induction_step_holds(model, rule, k) {
            return RuleOutcome::Complete;
        }
    }

    RuleOutcome::Bounded
}

fn find_counterexample(
    model: &SafetyModel,
    rule: RuleBinding,
    max_depth: usize,
) -> Option<Counterexample> {
    let mut cfg = Config::new();
    cfg.set_model_generation(true);
    let ctx = Context::new(&cfg);
    let solver = Solver::new(&ctx);

    let vars = create_path_vars(&ctx, model, max_depth);
    assert_path_constraints(&ctx, &solver, model, &vars, max_depth, true);

    let violation = (0..=max_depth)
        .map(|step| conflict_at_step(&ctx, &vars, step, rule))
        .collect::<Vec<_>>();
    solver.assert(&or_all(&ctx, &violation));

    if solver.check() != SatResult::Sat {
        return None;
    }

    let model_ast = solver.get_model()?;
    let mut violation_step = 0usize;
    for step in 0..=max_depth {
        if evaluate_conflict(&model_ast, &vars, step, rule) {
            violation_step = step;
            break;
        }
    }

    let path = render_path(model, &vars, &model_ast, rule, violation_step);

    Some(Counterexample { path })
}

fn k_induction_step_holds(model: &SafetyModel, rule: RuleBinding, k: usize) -> bool {
    let mut cfg = Config::new();
    cfg.set_model_generation(false);
    let ctx = Context::new(&cfg);
    let solver = Solver::new(&ctx);

    let depth = k + 1;
    let vars = create_path_vars(&ctx, model, depth);
    assert_path_constraints(&ctx, &solver, model, &vars, depth, false);

    for step in 0..=k {
        solver.assert(&conflict_at_step(&ctx, &vars, step, rule).not());
    }
    solver.assert(&conflict_at_step(&ctx, &vars, k + 1, rule));

    solver.check() == SatResult::Unsat
}

fn create_path_vars<'"'ctx>(ctx: &'ctx Context, model: &SafetyModel, depth: usize) -> PathVars<'ctx> {
    let mut state = Vec::with_capacity(depth + 1);
    for step in 0..=depth {
        let row = (0..model.states.len())
            .map(|state_id| Bool::new_const(ctx, format"'!("s_{}_{}", step, state_id)))
            .collect::<Vec<_>>();
        state.push(row);
    }

    let mut edge = Vec::with_capacity(depth);
    for step in 0..depth {
        let row = (0..model.edges.len())
            .map(|edge_id| Bool::new_const(ctx, format!("e_{}_{}", step, edge_id)))
            .collect::<Vec<_>>();
        edge.push(row);
    }

    let mut device = Vec::with_capacity(depth + 1);
    for step in 0..=depth {
        let mut device_row = Vec::with_capacity(model.devices.len());
        for (device_id, domain) in model.devices.iter().enumerate() {
            let state_row = (0..domain.states.len())
                .map(|state_id| Bool::new_const(ctx, format!("d_{}_{}_{}", step, device_id, state_id)))
                .collect::<Vec<_>>();
            device_row.push(state_row);
        }
        device.push(device_row);
    }

    PathVars {
        state,
        edge,
        device,
    }
}

fn assert_path_constraints<'"'ctx>(
    ctx: &'ctx Context,
    solver: &Solver<'ctx>,
    model: &SafetyModel,
    vars: &PathVars<'ctx>,
    depth: usize,
    anchor_initial: bool,
) {
    for step in 0..=depth {
        assert_exactly_one(ctx, solver, &vars.state[step]);
        for device_states in &vars.device[step] {
            assert_exactly_one(ctx, solver, device_states);
        }
    }

    if anchor_initial {
        solver.assert(&vars.state[0][model.initial_state]);
        for (device_id, domain) in model.devices.iter().enumerate() {
            solver.assert(&vars.device[0][device_id][domain.default_state]);
        }
    }

    for step in 0..depth {
        assert_exactly_one(ctx, solver, &vars.edge[step]);

        for (edge_id, edge_model) in model.edges.iter().enumerate() {
            let edge_var = &vars.edge[step][edge_id];
            solver.assert(&edge_var.implies(&vars.state[step][edge_model.from]));
            solver.assert(&edge_var.implies(&vars.state[step + 1][edge_model.to]));

            for device_id in 0..model.devices.len() {
                if let Some(&next_state_id) = edge_model.effects.get(&device_id) {
                    solver.assert(&edge_var.implies(&vars.device[step + 1][device_id][next_state_id]));
                    continue;
                }

                for state_id in 0..model.devices[device_id].states.len() {
                    solver.assert(&edge_var.implies(
                        &vars.device[step + 1][device_id][state_id]
                            ._eq(&vars.device[step][device_id][state_id]),
                    ));
                }
            }
        }

        for state_id in 0..model.states.len() {
            let outgoing = model.outgoing[state_id]
                .iter()
                .map(|&edge_id| vars.edge[step][edge_id].clone())
                .collect::<Vec<_>>();
            solver.assert(&vars.state[step][state_id].implies(&or_all(ctx, &outgoing)));
        }
    }
}

fn assert_exactly_one<'ctx>(ctx: &'ctx Context, solver: &Solver<'ctx>, vars: &[Bool<'ctx>]) {
    if vars.is_empty() {
        return;
    }

    solver.assert(&or_all(ctx, vars));
    for i in 0..vars.len() {
        for j in (i + 1)..vars.len() {
            solver.assert(&vars[i].implies(&vars[j].not()));
        }
    }
}

fn or_all<'ctx>(ctx: &'ctx Context, vars: &[Bool<'ctx>]) -> Bool<'ctx> {
    if vars.is_empty() {
        return Bool::from_bool(ctx, false);
    }

    let refs = vars.iter().collect::<Vec<_>>();
    Bool::or(ctx, &refs)
}

fn conflict_at_step<'ctx>(ctx: &'ctx Context, vars: &PathVars<'ctx>, step: usize, rule: RuleBinding) -> Bool<'ctx> {
    Bool::and(
        ctx,
        &[
            &vars.device[step][rule.left_device][rule.left_state],
            &vars.device[step][rule.right_device][rule.right_state],
        ],
    )
}

fn evaluate_conflict(model: &Model<'_>, vars: &PathVars<'_>, step: usize, rule: RuleBinding) -> bool {
    evaluate_bool(model, &vars.device[step][rule.left_device][rule.left_state])
        && evaluate_bool(model, &vars.device[step][rule.right_device][rule.right_state])
}

fn render_path(
    model: &SafetyModel,
    vars: &PathVars<'_>,
    z3_model: &Model<'_>,
    rule: RuleBinding,
    violation_step: usize,
) -> Vec<String> {
    let mut lines = Vec::new();

    let initial_state = active_state(model, vars, z3_model, 0).unwrap_or(model.initial_state);
    lines.push(format"'!("初始状态 {}", state_name(&model.states[initial_state])));

    for step in 0..violation_step {
        let edge_id = active_edge(model, vars, z3_model, step).unwrap_or_else(|| {
            model.outgoing[active_state(model, vars, z3_model, step).unwrap_or(model.initial_state)]
                .first()
                .copied()
                .unwrap_or(0)
        });

        let edge = &model.edges[edge_id];
        let from = state_name(&model.states[edge.from]);
        let to = state_name(&model.states[edge.to]);
        lines.push(format!("{from} --[{}]--> {to}", edge.label));
    }

    let conflict_state = active_state(model, vars, z3_model, violation_step)
        .and_then(|state_id| model.states.get(state_id))
        .map(state_name)
        .unwrap_or_else(|| "未知状态".to_string());

    lines.push(format!(
        "在 {} 检测到冲突：{}.{} 与 {}.{} 同时为真",
        conflict_state,
        model.devices[rule.left_device].name,
        model.devices[rule.left_device].states[rule.left_state],
        model.devices[rule.right_device].name,
        model.devices[rule.right_device].states[rule.right_state],
    ));

    lines
}

fn active_state(
    model: &SafetyModel,
    vars: &PathVars<'"'_>,
    z3_model: &Model<'_>,
    step: usize,
) -> Option<usize> {
    (0..model.states.len()).find(|&state_id| evaluate_bool(z3_model, &vars.state[step][state_id]))
}

fn active_edge(
    model: &SafetyModel,
    vars: &PathVars<'_>,
    z3_model: &Model<'_>,
    step: usize,
) -> Option<usize> {
    if step >= vars.edge.len() {
        return None;
    }

    (0..model.edges.len()).find(|&edge_id| evaluate_bool(z3_model, &vars.edge[step][edge_id]))
}

fn evaluate_bool(model: &Model<'_>, value: &Bool<'_>) -> bool {
    model
        .eval(value, true)
        .and_then(|eval| eval.as_bool())
        .unwrap_or(false)
}

fn state_name(state: &State) -> String {
    format"'!("{}.{}", state.task_name, state.step_name)
}

fn state_expr_text(device: &str, state: &str) -> String {
    format!("{device}.{state}")
}

#[cfg(test)]
mod tests {
    use super::{verify_safety, verify_safety_with_config, SafetyConfig, SafetyProofLevel};
    use crate::parser::parse_plc;
    use crate::semantic::{build_constraint_set, build_state_machine};

    #[test]
    fn proves_two_cylinder_sequence_without_parallel_conflict() {
        let source = r#"
[topology]

device Y0: digital_output
device Y1: digital_output

device valve_A: solenoid_valve {
    connected_to: Y0
    response_time: 20ms
}

device valve_B: solenoid_valve {
    connected_to: Y1
    response_time: 20ms
}

device cyl_A: cylinder {
    connected_to: valve_A
    stroke_time: 300ms
    retract_time: 300ms
}

device cyl_B: cylinder {
    connected_to: valve_B
    stroke_time: 300ms
    retract_time: 300ms
}

[constraints]

safety: cyl_A.extended conflicts_with cyl_B.extended

[tasks]

task init:
    step extend_A:
        action: extend cyl_A
    step retract_A:
        action: retract cyl_A
    step extend_B:
        action: extend cyl_B
    step retract_B:
        action: retract cyl_B
"#;

        let program = parse_plc(source).expect("测试程序应能解析");
        let constraints = build_constraint_set(&program).expect("约束应能构建");
        let state_machine = build_state_machine(&program).expect("状态机应能构建");

        let report = verify_safety(&program, &constraints, &state_machine)
            .expect("顺序双气缸逻辑不应违反互斥约束");

        assert!(
            matches!(report.level, SafetyProofLevel::Complete | SafetyProofLevel::Bounded),
            "验证结果应返回有效级别"
        );
        assert!(report.explored_depth >= state_machine.states.len());
    }

    #[test]
    fn reports_conflict_for_parallel_extend_actions() {
        let source = r#"
[topology]

device Y0: digital_output
device Y1: digital_output

device valve_A: solenoid_valve {
    connected_to: Y0
}

device valve_B: solenoid_valve {
    connected_to: Y1
}

device cyl_A: cylinder {
    connected_to: valve_A
    stroke_time: 200ms
    retract_time: 200ms
}

device cyl_B: cylinder {
    connected_to: valve_B
    stroke_time: 200ms
    retract_time: 200ms
}

[constraints]

safety: cyl_A.extended conflicts_with cyl_B.extended

[tasks]

task parallel_demo:
    step move_together:
        parallel:
            branch_A:
                action: extend cyl_A
            branch_B:
                action: extend cyl_B
"#;

        let program = parse_plc(source).expect("测试程序应能解析");
        let constraints = build_constraint_set(&program).expect("约束应能构建");
        let state_machine = build_state_machine(&program).expect("状态机应能构建");

        let errors = verify_safety(&program, &constraints, &state_machine)
            .expect_err("并行伸出冲突气缸时应触发 safety 错误");

        assert!(
            errors
                .iter()
                .any(|error| error.to_string().contains("conflicts_with")),
            "错误应包含冲突约束说明"
        );
        assert!(errors.iter().all(|error| error.line > 0), "错误应携带行号");
    }

    #[test]
    fn uses_scc_size_plus_one_as_default_depth_floor() {
        let source = r#"
[topology]

device Y0: digital_output
device valve_A: solenoid_valve {
    connected_to: Y0
}
device cyl_A: cylinder {
    connected_to: valve_A
    stroke_time: 100ms
    retract_time: 100ms
}

device Y1: digital_output
device valve_B: solenoid_valve {
    connected_to: Y1
}
device cyl_B: cylinder {
    connected_to: valve_B
    stroke_time: 100ms
    retract_time: 100ms
}

[constraints]

safety: cyl_A.extended conflicts_with cyl_B.extended

[tasks]

task init:
    step a:
        action: retract cyl_A
    on_complete: goto loop

task loop:
    step b:
        action: retract cyl_B
    on_complete: goto init
"#;

        let program = parse_plc(source).expect("测试程序应能解析");
        let constraints = build_constraint_set(&program).expect("约束应能构建");
        let state_machine = build_state_machine(&program).expect("状态机应能构建");

        let report = verify_safety(&program, &constraints, &state_machine)
            .expect("不含冲突动作时 safety 应通过");

        assert!(
            report.explored_depth >= 3,
            "SCC(2节点) 场景默认深度应至少为 |SCC|+1=3"
        );
    }

    #[test]
    fn warns_when_bmc_max_depth_caps_default_search_depth() {
        let source = r#"
[topology]

device Y0: digital_output
device valve_A: solenoid_valve {
    connected_to: Y0
}
device cyl_A: cylinder {
    connected_to: valve_A
    stroke_time: 100ms
    retract_time: 100ms
}

device Y1: digital_output
device valve_B: solenoid_valve {
    connected_to: Y1
}
device cyl_B: cylinder {
    connected_to: valve_B
    stroke_time: 100ms
    retract_time: 100ms
}

[constraints]

safety: cyl_A.extended conflicts_with cyl_B.extended

[tasks]

task init:
    step one:
        action: retract cyl_A
    step two:
        action: retract cyl_B
"#;

        let program = parse_plc(source).expect("测试程序应能解析");
        let constraints = build_constraint_set(&program).expect("约束应能构建");
        let state_machine = build_state_machine(&program).expect("状态机应能构建");

        let report = verify_safety_with_config(
            &program,
            &constraints,
            &state_machine,
            SafetyConfig {
                bmc_max_depth: Some(1),
            },
        )
        .expect("应返回有界验证结果");

        assert_eq!(report.explored_depth, 1);
        assert!(
            report
                .warnings
                .iter()
                .any(|warning| warning.contains("bmc_max_depth=1")),
            "当用户上限截断默认展开深度时应输出警告"
        );
    }

    #[test]
    fn warns_when_bmc_limit_is_lower_than_scc_requirement() {
        let source = r#"
[topology]

device Y0: digital_output
device valve_A: solenoid_valve {
    connected_to: Y0
}
device cyl_A: cylinder {
    connected_to: valve_A
    stroke_time: 100ms
    retract_time: 100ms
}

device Y1: digital_output
device valve_B: solenoid_valve {
    connected_to: Y1
}
device cyl_B: cylinder {
    connected_to: valve_B
    stroke_time: 100ms
    retract_time: 100ms
}

[constraints]

safety: cyl_A.extended conflicts_with cyl_B.extended

[tasks]

task init:
    step a:
        action: retract cyl_A
    on_complete: goto loop

task loop:
    step b:
        action: retract cyl_B
    on_complete: goto init
"#;

        let program = parse_plc(source).expect("测试程序应能解析");
        let constraints = build_constraint_set(&program).expect("约束应能构建");
        let state_machine = build_state_machine(&program).expect("状态机应能构建");

        let report = verify_safety_with_config(
            &program,
            &constraints,
            &state_machine,
            SafetyConfig {
                bmc_max_depth: Some(2),
            },
        )
        .expect("应返回有界验证结果");

        assert_eq!(report.explored_depth, 2);
        assert!(
            report
                .warnings
                .iter()
                .any(|warning| warning.contains("SCC")),
            "bmc_max_depth 小于 |SCC|+1 时应输出 SCC 截断警告"
        );
        assert!(
            report
                .warnings
                .iter()
                .any(|warning| warning.contains("WARNING: Safety 在深度 2 内未发现反例")),
            "截断后应输出有界验证警告"
        );
    }
}
EOF' in /mnt/e/personal_project/rust_plc succeeded in 51ms:


thinking
**Adding module export and dependency**
exec
/bin/bash -lc "python3 - <<'PY'
from pathlib import Path
path = Path('/mnt/e/personal_project/rust_plc/src/verification/mod.rs')
text = path.read_text()
if 'pub mod safety;' not in text:
    text += '\\npub mod safety;\\n'
path.write_text(text)
PY" in /mnt/e/personal_project/rust_plc succeeded in 51ms:


thinking
**Adding z3 dependency**
exec
/bin/bash -lc "python3 - <<'PY'
from pathlib import Path
path = Path('/mnt/e/personal_project/rust_plc/Cargo.toml')
text = path.read_text()
if 'z3 =' not in text:
    text = text.rstrip() + '\\nz3 = { version = \"0.12\", features = [\"static-link-z3\"] }\\n'
path.write_text(text)
PY" in /mnt/e/personal_project/rust_plc succeeded in 51ms:


thinking
**Planning formatting and compilation**
exec
/bin/bash -lc 'cargo fmt' in /mnt/e/personal_project/rust_plc succeeded in 246ms:


thinking
**Running tests with extended timeout**
exec
/bin/bash -lc 'cargo test' in /mnt/e/personal_project/rust_plc
thinking
**Noticing command lacks polling**

thinking
**Observing prolonged build time**

thinking
**Planning extended polling**
 exited 101 in 41.58s:
     Locking 24 packages to latest Rust 1.89.0 compatible versions
      Adding aho-corasick v1.1.4
      Adding bindgen v0.66.1
      Adding bitflags v2.10.0
      Adding cc v1.2.55
      Adding cexpr v0.6.0
      Adding clang-sys v1.8.1
      Adding cmake v0.1.57
      Adding find-msvc-tools v0.1.9
      Adding glob v0.3.3
      Adding lazy_static v1.5.0
      Adding lazycell v1.3.0
      Adding libloading v0.8.9
      Adding log v0.4.29
      Adding minimal-lexical v0.2.1
      Adding nom v7.1.3
      Adding peeking_take_while v0.1.2
      Adding regex v1.12.3
      Adding regex-automata v0.4.14
      Adding regex-syntax v0.8.9

thinking
**Adjusting polling interval**

thinking
**Exploring z3 crate features for cmake-free build**
exec
/bin/bash -lc "python3 - <<'PY'
from pathlib import Path
root = Path('/home/liangyuhang/.cargo/registry/src')
for path in root.glob('*/*z3-0.12.1/Cargo.toml'):
    print(path)
    print(path.read_text())
    break
PY" in /mnt/e/personal_project/rust_plc succeeded in 51ms:
/home/liangyuhang/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/z3-0.12.1/Cargo.toml
# THIS FILE IS AUTOMATICALLY GENERATED BY CARGO
#
# When uploading crates to the registry Cargo will automatically
# "normalize" Cargo.toml files for maximal compatibility
# with all versions of Cargo and also rewrite `path` dependencies
# to registry (e.g., crates.io) dependencies.
#
# If you are reading this file be aware that the original Cargo.toml
# will likely look very different (and much more reasonable).
# See Cargo.toml.orig for the original contents.

[package]
name = "z3"
version = "0.12.1"
authors = [
    "Graydon Hoare <graydon@pobox.com>",
    "Bruce Mitchener <bruce.mitchener@gmail.com>",
    "Nick Fitzgerald <fitzgen@gmail.com>",
]

thinking
**Inspecting z3 crate features**
exec
/bin/bash -lc 'cargo info z3' in /mnt/e/personal_project/rust_plc succeeded in 51ms:
note: to see how you depend on z3, run `cargo tree --invert --package z3@0.12.1`
z3 #FFI #SMT #satisfiability #solver
High-level rust bindings for the Z3 SMT solver from Microsoft Research
version: 0.12.1 (latest 0.19.7)
license: MIT
rust-version: unknown
documentation: https://docs.rs/z3/
homepage: https://github.com/prove-rs/z3.rs
repository: https://github.com/prove-rs/z3.rs.git
crates.io: https://crates.io/crates/z3/0.12.1
features:
 +default                = []
  arbitrary-size-numeral = [num]
  num                    = [dep:num]
  static-link-z3         = [z3-sys/static-link-z3]

thinking
**Clarifying dependency version querying**
exec
/bin/bash -lc 'cargo info z3@0.19.7' in /mnt/e/personal_project/rust_plc succeeded in 1.89s:
    Updating crates.io index
z3 #FFI #SMT #satisfiability #solver
High-level rust bindings for the Z3 SMT solver from Microsoft Research
version: 0.19.7
license: MIT
rust-version: 1.85.0
documentation: https://docs.rs/z3/
homepage: https://github.com/prove-rs/z3.rs
repository: https://github.com/prove-rs/z3.rs.git
crates.io: https://crates.io/crates/z3/0.19.7
features:
 +default        = [z3_4_8_15]
  z3_4_8_13      = []
  z3_4_8_14      = [z3_4_8_13]
  z3_4_8_15      = [z3_4_8_14]
  bundled        = [z3-sys/bundled]
  gh-release     = [z3-sys/gh-release]
  static-link-z3 = [z3-sys/bundled, z3-sys/deprecated-static-link-z3]
  vcpkg          = [z3-sys/vcpkg]

thinking
**Assessing updated Z3 release integration**
exec
/bin/bash -lc "python3 - <<'PY'
from pathlib import Path
root = Path('/home/liangyuhang/.cargo/registry/src')
for path in root.glob('*/*z3-0.19.7/Cargo.toml'):
    print(path)
    print(path.read_text()[:1200])
    break
PY" in /mnt/e/personal_project/rust_plc succeeded in 51ms:
/home/liangyuhang/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/z3-0.19.7/Cargo.toml
# THIS FILE IS AUTOMATICALLY GENERATED BY CARGO
#
# When uploading crates to the registry Cargo will automatically
# "normalize" Cargo.toml files for maximal compatibility
# with all versions of Cargo and also rewrite `path` dependencies
# to registry (e.g., crates.io) dependencies.
#
# If you are reading this file be aware that the original Cargo.toml
# will likely look very different (and much more reasonable).
# See Cargo.toml.orig for the original contents.

[package]
edition = "2024"
rust-version = "1.85.0"
name = "z3"
version = "0.19.7"
authors = [
    "Graydon Hoare <graydon@pobox.com>",
    "Bruce Mitchener <bruce.mitchener@gmail.com>",

thinking
**Reviewing API docs source**
exec
/bin/bash -lc "python3 - <<'PY'
from pathlib import Path
path = Path('/home/liangyuhang/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/z3-0.19.7/src/lib.rs')
text = path.read_text()
print(text[:2200])
PY" in /mnt/e/personal_project/rust_plc succeeded in 51ms:
//! # Z3
//!
//! Z3 is a theorem prover [from Microsoft Research](https://github.com/Z3Prover/z3/).
//!
//! This library aims to provide an idiomatic Rust wrapper around Z3.
//!
//! # Basic Usage
//!
//! The simplest way to use Z3 is to build a formula (also known as an [`Ast`](ast::Ast))
//! and use Z3's [`Solver`] to find solutions to it.
//!
//! This example walks through the process of expressing a simple math problem in the language of
//! SMT, asserting it into a Solver, and extracting answers from it. Z3 can encode much more varied
//! and complex problems than this example shows (and some of these features are supported by
//! the Rust bindings), but this covers the absolute basics.
//!
//! Consider the following problem:
//!
//! > Three friends, named Alice, Bob, and Charlie, wish to divide 30 apples amongst themselves,
//! > subject to the following constraints:

thinking
**Evaluating Z3 library integration**
exec
/bin/bash -lc 'ldconfig -p | rg libz3 || true' in /mnt/e/personal_project/rust_plc succeeded in 51ms:


thinking
**Planning Z3 API adaptation**
exec
/bin/bash -lc "python3 - <<'PY'
from pathlib import Path
path = Path('/home/liangyuhang/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/z3-0.19.7/src/ast/bool.rs')
print(path.exists())
if path.exists():
    text = path.read_text()
    for pat in ['pub fn new_const', 'pub fn fresh_const', 'pub fn and', 'pub fn or', 'pub fn implies', 'pub fn not', 'pub fn as_bool']:
        i = text.find(pat)
        if i"'!=-1:
            print('"'\\n',pat,'\\n',text[i:i+240])
PY" in /mnt/e/personal_project/rust_plc succeeded in 51ms:
True

 pub fn new_const 
 pub fn new_const<S: Into<Symbol>>(name: S) -> Bool {
        let ctx = &Context::thread_local();
        let sort = Sort::bool();
        unsafe {
            Self::wrap(ctx, {
                Z3_mk_const(ctx.z3_ctx.0, name.into().as_z3_sym

 pub fn fresh_const 
 pub fn fresh_const(prefix: &str) -> Bool {
        let ctx = &Context::thread_local();
        let sort = Sort::bool();
        unsafe {
            Self::wrap(ctx, {
                let pp = CString::new(prefix).unwrap();
                l

 pub fn as_bool 

thinking
**Inspecting pattern locations**
exec
/bin/bash -lc "python3 - <<'PY'
from pathlib import Path
p = Path('/home/liangyuhang/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/z3-0.19.7/src/ast.rs')
text = p.read_text()
for pat in ['pub fn and', 'pub fn or', 'pub fn implies', 'pub fn eq(', 'fn not(']:
    idx = text.find(pat)
    print(pat, idx)
    if idx"'!=-1:
        print(text[idx:idx+220])
PY' in /mnt/e/personal_project/rust_plc exited 1 in 65ms:
Traceback (most recent call last):
  File "<stdin>", line 3, in <module>
  File "/usr/lib/python3.12/pathlib.py", line 1029, in read_text
    with self.open(mode='r', encoding=encoding, errors=errors) as f:
         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/usr/lib/python3.12/pathlib.py", line 1015, in open
    return io.open(self, mode, buffering, encoding, errors, newline)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
FileNotFoundError: [Errno 2] No such file or directory: '/home/liangyuhang/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/z3-0.19.7/src/ast.rs'

thinking
**Inspecting module structure**
exec
/bin/bash -lc 'ls /home/liangyuhang/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/z3-0.19.7/src' in /mnt/e/personal_project/rust_plc succeeded in 51ms:
ast
config.rs
context.rs
datatype_builder.rs
func_decl.rs
func_entry.rs
func_interp.rs
goal.rs
lib.rs
model.rs
ops.rs
optimize.rs
params.rs
pattern.rs
probe.rs
rec_func_decl.rs
solver.rs
sort.rs
statistics.rs
symbol.rs

thinking
**Inspecting module methods**
exec
/bin/bash -lc "python3 - <<'PY'
from pathlib import Path
p = Path('/home/liangyuhang/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/z3-0.19.7/src/ast/mod.rs')
text = p.read_text()
for pat in ['pub fn and', 'pub fn or', 'pub fn implies', 'pub fn not', 'pub fn eq', 'trait Ast']:
    idx=text.find(pat)
    print('\\n',pat,idx)
    if idx"'!=-1:
        print(text[idx:idx+260])
PY' in /mnt/e/personal_project/rust_plc succeeded in 51ms:

 pub fn and -1

 pub fn or -1

 pub fn implies -1

 pub fn not -1

 pub fn eq 13268
pub fn eq<T: IntoAst<Self>>(&self, other: T) -> Bool
            where
                Self: Sized,
            {
                self.safe_eq(other).unwrap()
            }

            #[deprecated = "Please use safe_eq instead"]
            pub fn _safe_eq<T


thinking
**Checking boolean utilities**
exec
/bin/bash -lc "python3 - <<'PY'
from pathlib import Path
p = Path('/home/liangyuhang/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/z3-0.19.7/src/ast/bool.rs')
text = p.read_text()
print(text[:2500])
PY" in /mnt/e/personal_project/rust_plc succeeded in 51ms:
use crate::ast::{Ast, binop, unop, varop};
use crate::{Context, Sort, Symbol};
use std::ffi::CString;
use z3_sys::*;

/// [`Ast`] node representing a boolean value.
pub struct Bool {
    pub(crate) ctx: Context,
    pub(crate) z3_ast: Z3_ast,
}
impl Bool {
    pub fn new_const<S: Into<Symbol>>(name: S) -> Bool {
        let ctx = &Context::thread_local();
        let sort = Sort::bool();
        unsafe {
            Self::wrap(ctx, {
                Z3_mk_const(ctx.z3_ctx.0, name.into().as_z3_symbol(), sort.z3_sort).unwrap()
            })
        }
    }

thinking
**Identifying solver API necessity**
exec
/bin/bash -lc "python3 - <<'PY'
from pathlib import Path
p=Path('/home/liangyuhang/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/z3-0.19.7/src/solver.rs')
text=p.read_text()
for pat in ['pub fn new', 'pub fn assert', 'pub fn check', 'pub fn get_model']:
    i=text.find(pat)
    print('\\n',pat,i)
    if i"'!=-1:
        print(text[i:i+220])
PY' in /mnt/e/personal_project/rust_plc succeeded in 51ms:

 pub fn new 1808
pub fn new() -> Solver {
        let ctx = &Context::thread_local();
        unsafe { Self::wrap(ctx, Z3_mk_solver(ctx.z3_ctx.0).unwrap()) }
    }

    /// Parse an SMT-LIB2 string with assertions, soft constraints and o

 pub fn assert 3535
pub fn assert<T: Borrow<Bool>>(&self, ast: T) {
        let ast = ast.borrow();
        debug!("assert: {ast:?}");
        unsafe { Z3_solver_assert(self.ctx.z3_ctx.0, self.z3_slv, ast.z3_ast) };
    }

    /// Assert a 

 pub fn check 5865
pub fn check(&self) -> SatResult {

thinking
**Reviewing context config usage**
exec
/bin/bash -lc "python3 - <<'PY'
from pathlib import Path
p=Path('/home/liangyuhang/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/z3-0.19.7/src/context.rs')
text=p.read_text()
for pat in ['thread_local', 'with_z3_config', 'Context::thread_local', 'set_global_param']:
    i=text.find(pat)
    if i"'!=-1:
        print('"'\\n',pat, i)
        print(text[i:i+320])
PY" in /mnt/e/personal_project/rust_plc succeeded in 50ms:

 thread_local 2266
thread_local() -> Context {
        DEFAULT_CONTEXT.with(|f| f.borrow().clone())
    }

    /// _Replaces_ the thread-local [`Context`] with a new one created from the given [`Config`].
    /// This is useful if you want to use a specific configuration, but also want
    /// to use the default thread-local context. Not

 with_z3_config 1262
with_z3_config`](crate::with_z3_config).
///
/// Advanced users (e.g. those performing FFI with other Z3 bindings) can unsafely create their
/// own contexts using [`Context::from_raw`], and then use them with [`with_z3_context`](crate::with_z3_context).
///
/// # See also:
///
/// - [`Config`]
/// - [`with_z3_config`]

thinking
**Reviewing configuration helper function**
exec
/bin/bash -lc "python3 - <<'PY'
from pathlib import Path
p=Path('/home/liangyuhang/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/z3-0.19.7/src/lib.rs')
text=p.read_text()
for pat in ['pub fn with_z3_config', 'pub fn with_z3_context']:
    i=text.find(pat)
    print('\\n',pat,i)
    if i"'!=-1:
        print(text[i:i+420])
PY' in /mnt/e/personal_project/rust_plc succeeded in 51ms:

 pub fn with_z3_config 13334
pub fn with_z3_config<T: FnOnce() -> R + Send + Sync, R: Send + Sync>(
    cfg: &Config,
    callback: T,
) -> R {
    with_z3_context(&Context::new(cfg), callback)
}


 pub fn with_z3_context 12217
pub fn with_z3_context<T: FnOnce() -> R + Send + Sync, R: Send + Sync>(
    ctx: &Context,
    callback: T,
) -> R {
    let old = Context::thread_local();
    Context::set_thread_local(ctx);
    let res = callback();
    Context::set_thread_local(&old);
    res

thinking
**Checking solver config for model generation**
exec
/bin/bash -lc "python3 - <<'PY'
from pathlib import Path
p=Path('/home/liangyuhang/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/z3-0.19.7/src/config.rs')
text=p.read_text()
for pat in ['set_model_generation', 'set_timeout_msec', 'new()']:
    i=text.find(pat)
    print('\\n',pat,i)
    if i"'!=-1:
        print(text[i:i+260])
PY' in /mnt/e/personal_project/rust_plc succeeded in 51ms:

 set_model_generation 2143
set_model_generation(&mut self, b: bool) {
        self.set_bool_param_value("model", b);
    }

    pub fn set_debug_ref_count(&mut self, b: bool) {
        self.set_bool_param_value("debug_ref_count", b);
    }

    pub fn set_timeout_msec(&mut self, ms: u64

 set_timeout_msec 2368
set_timeout_msec(&mut self, ms: u64) {
        self.set_param_value("timeout", &format!("{ms}"));
    }
}

impl Default for Config {
    fn default() -> Self {

thinking
**Reviewing model evaluation approach**
exec
/bin/bash -lc "python3 - <<'PY'
from pathlib import Path
p=Path('/home/liangyuhang/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/z3-0.19.7/src/model.rs')
text=p.read_text()
for pat in ['pub fn eval', 'pub fn of_solver']:
    i=text.find(pat)
    print('\\n',pat,i)
    if i"'!=-1:
        print(text[i:i+260])
PY' in /mnt/e/personal_project/rust_plc succeeded in 50ms:

 pub fn eval 2638
pub fn eval<T>(&self, ast: &T, model_completion: bool) -> Option<T>
    where
        T: Ast,
    {
        let mut tmp: Z3_ast = ast.get_z3_ast();
        let res = {
            unsafe {
                Z3_model_eval(
                    self.ctx.z3_ctx.0,
 

 pub fn of_solver 383
pub fn of_solver(slv: &Solver) -> Option<Model> {
        unsafe {
            let m = Z3_solver_get_model(slv.ctx.z3_ctx.0, slv.z3_slv);
            Some(Self::wrap(&slv.ctx, m?))
        }
    }

thinking
**Refactoring for newer API without lifetimes**
