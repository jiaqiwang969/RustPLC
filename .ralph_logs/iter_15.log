OpenAI Codex v0.98.0 (research preview)
--------
workdir: /mnt/e/personal_project/rust_plc
model: gpt-5.3-codex
provider: codex
approval: never
sandbox: danger-full-access
reasoning effort: high
reasoning summaries: auto
session id: 019c4ade-7c27-7752-b3d6-be5d04f160b5
--------
user
# Ralph Agent Instructions

You are an autonomous coding agent working on a software project.

## Your Task

1. Read the PRD at `prd.json` (in the same directory as this file)
2. Read the progress log at `progress.txt` (check Codebase Patterns section first)
3. Check you're on the correct branch from PRD `branchName`. If not, check it out or create from main.
4. Pick the **highest priority** user story where `passes: false`
5. Implement that single user story
6. Run quality checks (e.g., typecheck, lint, test - use whatever your project requires)
7. Update AGENTS.md files if you discover reusable patterns (see below)
8. If checks pass, commit ALL changes with message: `feat: [Story ID] - [Story Title]`
9. Update the PRD to set `passes: true` for the completed story
10. Append your progress to `progress.txt`

## Progress Report Format

APPEND to progress.txt (never replace, always append):
```
## [Date/Time] - [Story ID]
Thread: https://ampcode.com/threads/$AMP_CURRENT_THREAD_ID
- What was implemented
- Files changed
- **Learnings for future iterations:**
  - Patterns discovered (e.g., "this codebase uses X for Y")
  - Gotchas encountered (e.g., "don't forget to update Z when changing W")
  - Useful context (e.g., "the evaluation panel is in component X")
---
```

Include the thread URL so future iterations can use the `read_thread` tool to reference previous work if needed.

The learnings section is critical - it helps future iterations avoid repeating mistakes and understand the codebase better.

## Consolidate Patterns

If you discover a **reusable pattern** that future iterations should know, add it to the `## Codebase Patterns` section at the TOP of progress.txt (create it if it doesn't exist). This section should consolidate the most important learnings:

```
## Codebase Patterns
- Example: Use `sql<number>` template for aggregations
- Example: Always use `IF NOT EXISTS` for migrations
- Example: Export types from actions.ts for UI components
```

Only add patterns that are **general and reusable**, not story-specific details.

## Update AGENTS.md Files

Before committing, check if any edited files have learnings worth preserving in nearby AGENTS.md files:

1. **Identify directories with edited files** - Look at which directories you modified
2. **Check for existing AGENTS.md** - Look for AGENTS.md in those directories or parent directories
3. **Add valuable learnings** - If you discovered something future developers/agents should know:
   - API patterns or conventions specific to that module
   - Gotchas or non-obvious requirements
   - Dependencies between files
   - Testing approaches for that area
   - Configuration or environment requirements

**Examples of good AGENTS.md additions:**
- "When modifying X, also update Y to keep them in sync"
- "This module uses pattern Z for all API calls"
- "Tests require the dev server running on PORT 3000"
- "Field names must match the template exactly"

**Do NOT add:**
- Story-specific implementation details
- Temporary debugging notes
- Information already in progress.txt

Only update AGENTS.md if you have **genuinely reusable knowledge** that would help future work in that directory.

## Quality Requirements

- ALL commits must pass your project's quality checks (typecheck, lint, test)
- Do NOT commit broken code
- Keep changes focused and minimal
- Follow existing code patterns

## Browser Testing (Required for Frontend Stories)

For any story that changes UI, you MUST verify it works in the browser:

1. Load the `dev-browser` skill
2. Navigate to the relevant page
3. Verify the UI changes work as expected
4. Take a screenshot if helpful for the progress log

A frontend story is NOT complete until browser verification passes.

## Stop Condition

After completing a user story, check if ALL stories have `passes: true`.

If ALL stories are complete and passing, reply with:
<promise>COMPLETE</promise>

If there are still stories with `passes: false`, end your response normally (another iteration will pick up the next story).

## Important

- Work on ONE story per iteration
- Commit frequently
- Keep CI green
- Read the Codebase Patterns section in progress.txt before starting

mcp startup: no servers

thinking
**Clarifying skill usage and task approach**
exec
/bin/bash -lc "bash -lc 'ls -la'" in /mnt/e/personal_project/rust_plc succeeded in 50ms:
total 112
drwxrwxrwx 1 liangyuhang liangyuhang  4096 Feb 11 10:12 .
drwxrwxrwx 1 liangyuhang liangyuhang  4096 Feb 10 20:47 ..
drwxrwxrwx 1 liangyuhang liangyuhang  4096 Feb 11 00:34 .claude
drwxrwxrwx 1 liangyuhang liangyuhang  4096 Feb 11 01:09 .codex
drwxrwxrwx 1 liangyuhang liangyuhang  4096 Feb 11 12:03 .git
-rwxrwxrwx 1 liangyuhang liangyuhang     8 Feb 11 01:17 .gitignore
drwxrwxrwx 1 liangyuhang liangyuhang  4096 Feb 11 12:03 .ralph_logs
-rwxrwxrwx 1 liangyuhang liangyuhang  4307 Feb 11 01:14 CODEX.md
-rwxrwxrwx 1 liangyuhang liangyuhang  7674 Feb 11 09:01 Cargo.lock
-rwxrwxrwx 1 liangyuhang liangyuhang   249 Feb 11 09:00 Cargo.toml
drwxrwxrwx 1 liangyuhang liangyuhang  4096 Feb 11 10:11 examples
-rwxrwxrwx 1 liangyuhang liangyuhang 18675 Feb 11 12:00 prd.json
-rwxrwxrwx 1 liangyuhang liangyuhang 38276 Feb 11 00:28 prd.md
-rwxrwxrwx 1 liangyuhang liangyuhang 23714 Feb 11 12:01 progress.txt
-rwxrwxrwx 1 liangyuhang liangyuhang  4307 Jan 23 10:30 prompt.md
-rwxrwxrwx 1 liangyuhang liangyuhang  3816 Feb 11 01:14 ralph.sh
drwxrwxrwx 1 liangyuhang liangyuhang  4096 Feb 11 11:55 src
drwxrwxrwx 1 liangyuhang liangyuhang  4096 Feb 11 10:12 target
drwxrwxrwx 1 liangyuhang liangyuhang  4096 Feb 11 10:12 tests

thinking
**Locating AGENTS.md for review**
exec
/bin/bash -lc "bash -lc 'rg --files -g \"AGENTS.md\"'" in /mnt/e/personal_project/rust_plc exited 1 in 50ms:


thinking
**Inspecting project descriptor file**
exec
/bin/bash -lc "bash -lc 'python - <<\"PY\"
import json, pathlib
p=pathlib.Path(\"prd.json\")
obj=json.loads(p.read_text())
print(obj.keys())
print(\"branchName\",obj.get(\"branchName\"))
for s in obj.get(\"userStories\",[]):
    print(s.get(\"id\"),s.get(\"title\"),\"priority\",s.get(\"priority\"),\"passes\",s.get(\"passes\"))
PY'" in /mnt/e/personal_project/rust_plc exited 127 in 51ms:
bash: line 1: /mnt/c/Users/liangyuhang/.pyenv/pyenv-win/shims/python: cannot execute: required file not found

thinking
**Switching from Python to jq**
exec
/bin/bash -lc "bash -lc 'jq \"keys\" prd.json'" in /mnt/e/personal_project/rust_plc exited 127 in 51ms:
bash: line 1: jq: command not found

thinking
**Considering scripting tools for parsing**
exec
/bin/bash -lc "bash -lc 'head -n 80 prd.json'" in /mnt/e/personal_project/rust_plc succeeded in 51ms:
{
  "project": "RustPLC",
  "branchName": "ralph/phase1-2-parser-and-verification",
  "description": "Phase 1+2: DSL 解析器、语义分析器与形式化验证引擎 — 解析 .plc 文件生成 AST，构建 IR（TopologyGraph、StateMachine、ConstraintSet、TimingModel），并完成四项形式化验证（Safety、Liveness、Timing、Causality）",
  "userStories": [
    {
      "id": "US-001",
      "title": "初始化 Rust 项目与依赖",
      "description": "作为开发者，我需要搭建 Rust 项目脚手架并配置所有必要依赖，以便后续故事可以在此基础上构建。",
      "acceptanceCriteria": [
        "Cargo.toml 存在，项目名为 'rust_plc'",
        "依赖包含：pest、pest_derive、petgraph、serde、serde_json、thiserror",
        "src/main.rs 存在，实现基本 CLI，接受 .plc 文件路径参数",
        "src/lib.rs 存在，声明模块：parser、ast、ir、semantic、error",
        "每个模块有占位文件（如 src/parser/mod.rs）",
        "cargo build 成功",
        "类型检查通过"
      ],
      "priority": 1,
      "passes": true,

thinking
**Searching for false passes**
exec
/bin/bash -lc "bash -lc 'rg -n \"\\\"passes\\\": (true|false)\" prd.json'" in /mnt/e/personal_project/rust_plc succeeded in 51ms:
20:      "passes": true,
37:      "passes": true,
56:      "passes": true,
74:      "passes": true,
95:      "passes": true,
112:      "passes": true,
129:      "passes": true,
147:      "passes": true,
169:      "passes": true,
187:      "passes": true,
204:      "passes": true,
222:      "passes": true,
240:      "passes": true,
263:      "passes": false,
284:      "passes": false,
312:      "passes": false,
330:      "passes": false,

thinking
**Inspecting key code sections**
exec
/bin/bash -lc "bash -lc 'sed -n \"230,350p\" prd.json'" in /mnt/e/personal_project/rust_plc succeeded in 51ms:
        "src/verification/causality.rs 实现因果链验证",
        "对每条 causality 约束（如 Y0 -> valve_A -> cyl_A -> sensor_A_ext），使用 petgraph 可达性验证路径存在",
        "对 tasks 中的每个 action+wait 对，推断隐式因果链并验证连通性",
        "失败时：报告断裂的链路、期望链路、实际链路和修复建议（匹配 PRD 3.2.4 节错误格式）",
        "错误信息为中文，包含行号",
        "单元测试：验证 PRD 5.4 节示例的因果链通过",
        "单元测试：验证缺少连接时（如 valve_A 未连接到 cyl_A）因果链失败",
        "类型检查通过"
      ],
      "priority": 13,
      "passes": true,
      "notes": ""
    },
    {
      "id": "US-014",
      "title": "实现时序检查器（Timing Checker）",
      "description": "作为开发者，我需要时序验证，检查物理动作时间是否满足时序约束。",
      "acceptanceCriteria": [
        "src/verification/timing.rs 实现时序包络验证",
        "对每个 must_complete_within 约束，计算作用域（task 或 step）的最坏情况关键路径时间",

thinking
**Inspecting progress file structure**
exec
/bin/bash -lc "bash -lc 'sed -n \"1,220p\" progress.txt'" in /mnt/e/personal_project/rust_plc succeeded in 51ms:
# Ralph Progress Log
## Codebase Patterns
- TopologyGraph JSON 调试依赖 `petgraph` 的 `serde-1` feature；若缺失会导致 DiGraph 无法序列化。
- In parser-to-AST lowering, unwrap wrapper PEG rules (e.g., `constraint_declaration`, `step_statement`) before matching concrete rule kinds, or valid nodes can be silently skipped.
- Keep public module declarations centralized in `src/lib.rs`; implementation files live at `src/<module>/mod.rs`.
- For early story scaffolding, keep module placeholders compiling so CLI and library can evolve incrementally without breaking builds.
- Model DSL enums with `serde(rename_all = "snake_case")` and tagged enums so serialized AST tokens stay aligned with DSL keywords.
- In pest grammars, define silent `WHITESPACE` and `COMMENT` rules so inline `#` comments and multiline section formatting parse without extra boilerplate.
- For block-style DSL sections, parse optional `reason: "..."` clauses directly in each declaration rule so indented multiline annotations remain valid without separate line handling.
- In nested `parallel`/`race` grammar, require branch bodies to consume concrete statements so step-level directives are not misparsed as branch labels.
- In semantic topology lowering, treat `connected_to` as upstream linkage (`target -> current`) so causality traversals follow physical flow direction.
- Preserve directive line metadata in AST (e.g., `GotoDirective.line`, `TaskDeclaration.on_complete_line`) so semantic passes can report precise line-numbered errors without reparsing source text.
- For constraint semantic validation, seed known device states from device-type defaults plus `sensor.detects` references before checking `safety` state expressions.
- Use `PlcError` constructors (`undefined_reference` / `type_mismatch` / `duplicate_definition`) so diagnostics share unified ERROR blocks with `位置/原因/建议` fields.
- For end-to-end compilation paths (CLI/tests), run all four semantic builders and aggregate their errors so users get complete diagnostics in one run.
- For causality verification, augment TopologyGraph with logical edges from `detects.device -> sensor` before running reachability, otherwise output-to-sensor chains may appear disconnected.
Started: Wed Feb 11 01:14:39 CST 2026
---
## [2026-02-11 01:19:50 CST] - US-001
Thread: https://ampcode.com/threads/$AMP_CURRENT_THREAD_ID

thinking
**Inspecting recent story status**
exec
/bin/bash -lc "bash -lc 'tail -n 220 progress.txt'" in /mnt/e/personal_project/rust_plc succeeded in 51ms:
  - Initialized Cargo project `rust_plc` with required dependencies (`pest`, `pest_derive`, `petgraph`, `serde`, `serde_json`, `thiserror`).
  - Added `src/lib.rs` module exports and placeholder module files for `parser`, `ast`, `ir`, `semantic`, and `error`.
  - Replaced default CLI with argument validation that accepts exactly one `.plc` file path.
- Files changed
  - `Cargo.toml`, `Cargo.lock`, `src/main.rs`, `src/lib.rs`, `src/parser/mod.rs`, `src/ast/mod.rs`, `src/ir/mod.rs`, `src/semantic/mod.rs`, `src/error/mod.rs`, `prd.json`, `progress.txt`
- **Learnings for future iterations:**
  - Patterns discovered (e.g., "this codebase uses X for Y")
    - Library-facing modules are declared in `src/lib.rs` even when implementation is still a placeholder.
  - Gotchas encountered (e.g., "do not forget to update Z when changing W")
    - `python` shim is unavailable in this environment; use `python3` for JSON/text automation scripts.
  - Useful context (e.g., "the evaluation panel is in component X")
    - This story established the baseline crate structure; subsequent parser/AST stories can add logic directly in existing module files.
---
## [2026-02-11 01:31:17 CST] - US-002
Thread: https://ampcode.com/threads/$AMP_CURRENT_THREAD_ID
- What was implemented
  - Replaced the AST placeholder with typed syntax tree models for topology, constraints, and tasks sections.
  - Added device/constraint/task enums and structs covering all required DSL categories (device types, attributes, safety/timing/causality constraints, actions, wait/timeout/goto/on_complete/parallel/race/allow_indefinite_wait/unreachable).
  - Derived `Debug`, `Clone`, `Serialize`, and `Deserialize` for all AST-facing data structures to support parser output and downstream serialization.
- Files changed

thinking
**Checking current Git branch**
exec
/bin/bash -lc "bash -lc 'git status -sb'" in /mnt/e/personal_project/rust_plc succeeded in 178ms:
## ralph/phase1-2-parser-and-verification
 M .ralph_logs/iter_14.log
?? .ralph_logs/iter_15.log

thinking
**Confirming uncommitted changes and scanning source**
exec
/bin/bash -lc "bash -lc 'ls -R src'" in /mnt/e/personal_project/rust_plc succeeded in 51ms:
src:
ast
error
ir
lib.rs
main.rs
parser
semantic
verification

src/ast:
mod.rs

src/error:
mod.rs

src/ir:
mod.rs

src/parser:

thinking
**Exploring AST semantic for timing**
exec
/bin/bash -lc "bash -lc 'sed -n \"1,260p\" src/ir/mod.rs'" in /mnt/e/personal_project/rust_plc succeeded in 51ms:
use petgraph::graph::{DiGraph, NodeIndex};
use serde::{Deserialize, Serialize};
use std::collections::BTreeMap;

#[derive(Debug, Clone, Serialize, Deserialize, PartialEq)]
pub struct Device {
    pub name: String,
    pub kind: DeviceKind,
}

#[derive(Debug, Clone, Serialize, Deserialize, PartialEq)]
#[serde(rename_all = "snake_case")]
pub enum DeviceKind {
    DigitalOutput,
    DigitalInput,
    SolenoidValve,
    Cylinder,
    Sensor,
    Motor,
}

thinking
**Reviewing timing model details**
exec
/bin/bash -lc "bash -lc 'sed -n \"1,320p\" src/semantic/mod.rs'" in /mnt/e/personal_project/rust_plc succeeded in 51ms:
use crate::ast::{
    ActionStatement, BinaryValue as AstBinaryValue, ComparisonOperator, ConditionExpression,
    ConstraintsSection, DeviceType, DurationValue, GotoDirective, LiteralValue,
    OnCompleteDirective, ParallelBlock, PlcProgram, RaceBlock, SafetyRelation as AstSafetyRelation,
    StepStatement, TaskDeclaration, TasksSection, TimeUnit, TimeoutDirective,
    TimingRelation as AstTimingRelation, TimingTarget, TopologySection, WaitStatement,
};
use crate::error::PlcError;
use crate::ir::{
    ActionKind, ActionRef, ActionTiming, BinaryValue as IrBinaryValue, CausalityChain,
    ConnectionType, ConstraintSet, Device, DeviceKind, SafetyRelation as IrSafetyRelation,
    SafetyRule, State, StateExpr, StateMachine, TimeInterval, TimerOperation, TimerOperationKind,
    TimingModel, TimingRelation as IrTimingRelation, TimingRule, TimingScope, TopologyGraph,
    Transition, TransitionAction, TransitionGuard,
};
use petgraph::graph::NodeIndex;
use std::collections::{BTreeMap, HashMap, HashSet};

#[derive(Debug, Clone)]
struct DeviceNode {

thinking
**Inspecting timing-related helpers**
exec
/bin/bash -lc "bash -lc 'rg -n \"timing|Timing|duration|action_to_timing|collect_actions|must_start_after|must_complete_within\" src/semantic/mod.rs'" in /mnt/e/personal_project/rust_plc succeeded in 51ms:
6:    TimingRelation as AstTimingRelation, TimingTarget, TopologySection, WaitStatement,
10:    ActionKind, ActionRef, ActionTiming, BinaryValue as IrBinaryValue, CausalityChain,
13:    TimingModel, TimingRelation as IrTimingRelation, TimingRule, TimingScope, TopologyGraph,
37:pub fn build_timing_model(program: &PlcProgram) -> Result<TimingModel, Vec<PlcError>> {
38:    build_timing_model_from_ast(&program.topology, &program.tasks)
148:    for timing in &constraints.timing {
149:        validate_timing_target(&timing.target, timing.line, &task_steps, &mut errors);
151:        constraint_set.timing.push(TimingRule {
152:            scope: map_timing_scope(&timing.target),
153:            relation: map_timing_relation(&timing.relation),
154:            duration_ms: duration_value_to_ms(&timing.duration),
155:            reason: timing.reason.clone(),
187:pub fn build_timing_model_from_ast(
190:) -> Result<TimingModel, Vec<PlcError>> {
191:    let device_profiles = collect_device_timing_profiles(topology);
198:            collect_actions(&step.statements, &mut actions);
201:                if let Some(action_timing) = action_to_timing(
209:                    insert_action_timing(&mut intervals, action_timing);
216:        Ok(TimingModel { intervals })
353:                    let duration_ms = duration_to_ms(timeout);

thinking
**Reviewing helper functions and tests**
exec
/bin/bash -lc "bash -lc 'sed -n \"430,860p\" src/semantic/mod.rs'" in /mnt/e/personal_project/rust_plc succeeded in 51ms:
            });
        }

        State {
            task_name: key.0,
            step_name: key.1,
        }
    }

    fn add_transition(
        &mut self,
        from: State,
        to: State,
        guard: TransitionGuard,
        actions: Vec<TransitionAction>,
        timers: Vec<TimerOperation>,
    ) {
        self.transitions.push(Transition {
            from,
            to,

thinking
**Addressing truncated sed output**
exec
/bin/bash -lc "bash -lc 'sed -n \"620,780p\" src/semantic/mod.rs'" in /mnt/e/personal_project/rust_plc succeeded in 51ms:
            }
        }
    }
}

fn map_safety_relation(relation: &AstSafetyRelation) -> IrSafetyRelation {
    match relation {
        AstSafetyRelation::ConflictsWith => IrSafetyRelation::ConflictsWith,
        AstSafetyRelation::Requires => IrSafetyRelation::Requires,
    }
}

fn map_timing_scope(target: &TimingTarget) -> TimingScope {
    match target {
        TimingTarget::Task { task } => TimingScope::Task { task: task.clone() },
        TimingTarget::Step { task, step } => TimingScope::Step {
            task: task.clone(),
            step: step.clone(),
        },
    }

thinking
**Identifying verification module scope**
exec
/bin/bash -lc "bash -lc 'sed -n \"1,260p\" src/verification/mod.rs'" in /mnt/e/personal_project/rust_plc succeeded in 51ms:
pub mod causality;

thinking
**Planning timing module implementation**
exec
/bin/bash -lc "bash -lc 'sed -n \"1,360p\" src/verification/causality.rs'" in /mnt/e/personal_project/rust_plc succeeded in 51ms:
use crate::ast::{
    ActionStatement, BinaryValue, ComparisonOperator, LiteralValue, PlcProgram, StepStatement,
    WaitStatement,
};
use crate::ir::{ConstraintSet, DeviceKind, TopologyGraph};
use petgraph::algo::has_path_connecting;
use petgraph::graph::{DiGraph, NodeIndex};
use petgraph::visit::EdgeRef;
use std::collections::{HashMap, HashSet, VecDeque};
use std::fmt;

#[derive(Debug, Clone, PartialEq, Eq)]
pub struct CausalityDiagnostic {
    pub line: usize,
    pub action: Option<String>,
    pub wait: Option<String>,
    pub broken_link: String,
    pub expected_chain: String,
    pub actual_chain: String,
    pub suggestion: String,

thinking
**Inspecting test style and usage**
exec
/bin/bash -lc "bash -lc 'sed -n \"360,760p\" src/verification/causality.rs'" in /mnt/e/personal_project/rust_plc succeeded in 51ms:
        && sensor_names.contains(candidate)
    {
        return Some(candidate.to_string());
    }

    if let LiteralValue::State(state) = &wait.condition.right
        && sensor_names.contains(&state.device)
    {
        return Some(state.device.clone());
    }

    None
}

fn wait_to_text(wait: &WaitStatement) -> String {
    format!(
        "{} {} {}",
        wait.condition.left,
        comparison_operator_text(&wait.condition.operator),
        literal_to_text(&wait.condition.right)

thinking
**Reviewing library exports**
exec
/bin/bash -lc "bash -lc 'sed -n \"1,220p\" src/lib.rs'" in /mnt/e/personal_project/rust_plc succeeded in 51ms:
pub mod ast;
pub mod error;
pub mod ir;
pub mod parser;
pub mod semantic;
pub mod verification;

thinking
**Inspecting AST for timing metadata**
exec
/bin/bash -lc "bash -lc 'sed -n \"1,360p\" src/ast/mod.rs'" in /mnt/e/personal_project/rust_plc succeeded in 51ms:
use serde::{Deserialize, Serialize};

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct PlcProgram {
    pub topology: TopologySection,
    pub constraints: ConstraintsSection,
    pub tasks: TasksSection,
}

#[derive(Debug, Clone, Serialize, Deserialize, Default)]
pub struct TopologySection {
    pub devices: Vec<DeviceDeclaration>,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct DeviceDeclaration {
    #[serde(default)]
    pub line: usize,
    pub name: String,
    pub device_type: DeviceType,

thinking
**Inspecting parser for timing tests**
exec
/bin/bash -lc "bash -lc 'sed -n \"1,360p\" src/parser/mod.rs'" in /mnt/e/personal_project/rust_plc succeeded in 51ms:
use crate::ast::{
    ActionStatement, BinaryValue, Branch, CausalityConstraint, ComparisonOperator,
    ConditionExpression, ConstraintsSection, DeviceAttributes, DeviceDeclaration, DeviceType,
    DurationValue, GotoDirective, LiteralValue, MeasuredValue, OnCompleteDirective, ParallelBlock,
    PlcProgram, RaceBlock, RaceBranch, SafetyConstraint, SafetyRelation, StateReference,
    StepDeclaration, StepStatement, TaskDeclaration, TasksSection, TimeUnit, TimeoutDirective,
    TimingConstraint, TimingRelation, TimingTarget, TopologySection, WaitStatement,
};
use crate::error::PlcError;
use pest::Parser;
use pest::error::LineColLocation;
use pest::iterators::Pair;

#[derive(pest_derive::Parser)]
#[grammar = "parser/plc.pest"]
pub struct PlcParser;

pub fn parse_topology(input: &str) -> Result<(), pest::error::Error<Rule>> {
    PlcParser::parse(Rule::topology_file, input).map(|_| ())
}

thinking
**Assessing error handling approach**
exec
/bin/bash -lc "bash -lc 'cat examples/two_cylinder.plc'" in /mnt/e/personal_project/rust_plc succeeded in 51ms:
[topology]

device Y0: digital_output
device Y1: digital_output
device X0: digital_input
device X1: digital_input
device X2: digital_input
device X3: digital_input
device X4: digital_input

device start_button: digital_input {
    connected_to: X4
    debounce: 20ms
}

device valve_A: solenoid_valve {
    connected_to: Y0
    response_time: 20ms
}


thinking
**Reviewing timing examples**
exec
/bin/bash -lc "bash -lc 'cat examples/half_rotation.plc'" in /mnt/e/personal_project/rust_plc succeeded in 51ms:
[topology]

device Y0: digital_output
device X0: digital_input
device X1: digital_input
device X2: digital_input

device start_button: digital_input {
    connected_to: X2
    debounce: 20ms
}

device motor_ctrl: motor {
    connected_to: Y0
    rated_speed: 60rpm
    ramp_time: 50ms
}

device sensor_A: sensor {
    type: proximity

thinking
**Planning critical path timing logic**
exec
/bin/bash -lc "bash -lc 'rg -n \"3\\.2\\.3|Timing|must_start_after|must_complete_within|时序\" prd.md'" in /mnt/e/personal_project/rust_plc succeeded in 51ms:
13:用 Rust 替代传统 PLC 编程语言（梯形图/ST/FBD），建立一套 **"程序即结构"** 的工业控制系统。用户用极简的领域专用语言（DSL）描述物理拓扑、控制逻辑和安全约束，系统在编译期自动完成形式化验证（安全性、活性、时序、因果链），验证通过后生成确定性 Rust 执行代码。
110:#### 3.2.3 时序包络（Timing）
112:**目标**：如果物理属性定义的动作时间与时序要求矛盾，直接编译报错。
116:- 用户要求 `step_1 must_complete_within 100ms`
122:- 与用户声明的时序约束对比
128:ERROR [timing] 时序包络违反
129:  约束: step_1 must_complete_within 100ms (main.plc:30)
188:        --> TimingModel    (每个动作的时间区间)
195:    [x] Timing:    时序包络验证
236:    |--- TimingModel     (每个动作的时间区间)
242:    |-- Timing Checker    --> 区间算术: max_time <= constraint
394:# ===== 时序约束 (Timing) =====
395:timing: task.init must_complete_within 5000ms
398:timing: task.init.step_extend_A must_complete_within 500ms
415:| timing | X must_complete_within Nms | X 必须在 N 毫秒内完成 |
416:| timing | X must_start_after Nms | X 必须在 N 毫秒后才能开始 |
427:- **Timing 计算**：同一 step 内多条 action 的时间取最大值（并行），而非累加（串行）
714:      - TimingModel: 时间区间集合
743:      C3. Timing 检查
744:          - 对每个 must_complete_within 约束:
exec
/bin/bash -lc "bash -lc 'sed -n \"100,170p\" prd.md'" in /mnt/e/personal_project/rust_plc succeeded in 51ms:

```
ERROR [liveness] 潜在死锁
  位置: task init, step 2 (main.plc:25)
  原因: wait: sensor_A == true 没有 timeout 分支
  物理分析: sensor_A 依赖链路 [Y0 -> valve_A -> cyl_A -> sensor_A]
            如果链路中任一环节故障, sensor_A 将永远为 false
  建议: 添加 timeout: 600ms -> goto error_handler
```

#### 3.2.3 时序包络（Timing）

**目标**：如果物理属性定义的动作时间与时序要求矛盾，直接编译报错。

**场景示例**：
- 用户定义 `cyl_A.stroke_time: 200ms`
- 用户要求 `step_1 must_complete_within 100ms`
- 物理上不可能：气缸需要 200ms 才能到位，但要求 100ms 完成

**验证方法**：
exec
/bin/bash -lc "bash -lc 'sed -n \"720,780p\" prd.md'" in /mnt/e/personal_project/rust_plc succeeded in 51ms:
      C1. Safety 检查
          - 遍历所有 conflicts_with / requires 约束
          - 对每条约束生成 Z3 公式
          - 分层验证策略:
            1. 首先尝试 k-induction (归纳证明)，若成立则获得完备证明
            2. 若 k-induction 无法收敛，回退到 BMC 搜索反例，
               展开深度 = 状态节点数 (用户可通过 bmc_max_depth 配置上限，
               含 SCC 时至少展开 SCC 节点数 + 1 层)
            3. 状态空间较小时 (状态数 < 可配置阈值) 直接穷举
          - 验证结论分两级:
            完备证明 (k-induction/穷举): "Safety 已完备证明"
            有界验证 (仅 BMC): "WARNING: 深度 N 内未发现反例，未获完备证明"
      C2. Liveness 检查
          - 遍历所有 wait 语句
          - 无 timeout 且无 allow_indefinite_wait -> 报错
          - 检查状态图是否存在无出边的非终态
            (通过 on_complete: goto 形成的常驻循环是合法的，不算死锁)
          - on_complete: unreachable 的 task 不算"无出边非终态"，
            但编译器必须验证该 task 内所有执行路径均以 goto 结尾；
            若存在未跳转的路径，报错："unreachable 标记无效，

thinking
**Planning rotation timing calculation**
exec
/bin/bash -lc "bash -lc 'rg -n \"response_time|stroke_time|must_start_after|泄压|关键路径|parallel|并行\" prd.md'" in /mnt/e/personal_project/rust_plc succeeded in 51ms:
51:- 如果逻辑中存在并行路径可能导致两缸同时伸出，编译报错并给出反例路径
115:- 用户定义 `cyl_A.stroke_time: 200ms`
121:- 计算最长完成时间（最坏情况关键路径）
131:        cyl_A.stroke_time = 200ms (main.plc:6)
315:    response_time: 15ms                 # 电磁阀响应时间
321:    response_time: 15ms
329:    stroke_time: 200ms                  # 全行程伸出时间
337:    stroke_time: 300ms
373:| 电磁阀 | solenoid_valve | connected_to, response_time | type |
374:| 气缸 | cylinder | connected_to, stroke_time, retract_time | type, stroke |
416:| timing | X must_start_after Nms | X 必须在 N 毫秒后才能开始 |
425:同一个 step 中出现多条 action 时，它们被视为**同时发出**（并行），在同一个扫描周期内写入所有输出。这意味着：
427:- **Timing 计算**：同一 step 内多条 action 的时间取最大值（并行），而非累加（串行）
434:# 这两条 action 在同一周期同时执行（并行）
507:#### 5.5.4 并行执行
512:task parallel_demo:
514:        parallel:
558:| parallel | 并行执行多个分支 | parallel: ... |
617:    response_time: 20ms
621:    response_time: 20ms
exec
/bin/bash -lc "bash -lc 'sed -n \"410,455p\" prd.md'" in /mnt/e/personal_project/rust_plc succeeded in 51ms:

| 类型 | 语法 | 含义 |
|------|------|------|
| safety | A conflicts_with B | 状态 A 和 B 不能同时为真 |
| safety | A requires B | 状态 A 为真时 B 必须为真 |
| timing | X must_complete_within Nms | X 必须在 N 毫秒内完成 |
| timing | X must_start_after Nms | X 必须在 N 毫秒后才能开始 |
| causality | A -> B -> C -> D | 从 A 到 D 的物理因果链必须连通 |

### 5.5 控制逻辑 [tasks]

#### 5.5.0 执行语义规则

**单个 step 内多条 action 的执行语义**：

同一个 step 中出现多条 action 时，它们被视为**同时发出**（并行），在同一个扫描周期内写入所有输出。这意味着：

- **Timing 计算**：同一 step 内多条 action 的时间取最大值（并行），而非累加（串行）
- **Safety 检查**：同一 step 内的多条 action 会被视为同时生效，编译器会检查它们是否违反 conflicts_with 约束
- **物理含义**：对应"同时给多个电磁阀通电"这类操作

thinking
**Reviewing must_start_after usage**
exec
/bin/bash -lc "bash -lc 'rg -n \"must_start_after\" -n prd.md'" in /mnt/e/personal_project/rust_plc succeeded in 51ms:
416:| timing | X must_start_after Nms | X 必须在 N 毫秒后才能开始 |
748:          - 对每个 must_start_after 约束:

thinking
**Analyzing must-start-after interval logic**
Plan update
Starting US-014 by understanding existing IR/AST patterns before coding the timing verifier.
  → Inspect current verification/semantic code and derive timing-checker data needed for US-014
  • Implement timing checker module with must_complete_within and must_start_after diagnostics plus tests
  • Run cargo quality checks, update PRD/progress, and commit story changes

thinking
**Inspecting state machine transitions**
exec
/bin/bash -lc "bash -lc 'rg -n \"fn build_.*step|timeout|goto|waits|analyzed\" src/semantic/mod.rs'" in /mnt/e/personal_project/rust_plc succeeded in 51ms:
295:            let analyzed = analyze_statements(&step.statements);
297:            for (block_index, block) in analyzed.parallel_blocks.iter().enumerate() {
308:                    analyzed.actions.clone(),
312:            for (block_index, block) in analyzed.race_blocks.iter().enumerate() {
323:                    analyzed.actions.clone(),
327:            for goto in &analyzed.gotos {
329:                    &goto.step,
330:                    goto.line,
333:                    "goto",
339:                        analyzed.actions.clone(),
345:            for (timeout_index, timeout) in analyzed.timeouts.iter().enumerate() {
347:                    &timeout.target.step,
348:                    timeout.target.line,
351:                    "timeout -> goto",
353:                    let duration_ms = duration_to_ms(timeout);
361:                                "{}.{}.timeout_{}",
364:                                timeout_index + 1
373:            for wait_expression in &analyzed.waits {
381:                        analyzed.actions.clone(),
387:            let has_control_flow = !analyzed.waits.is_empty()

thinking
**Inspecting transitions creation**
exec
/bin/bash -lc "bash -lc 'sed -n \"300,430p\" src/semantic/mod.rs'" in /mnt/e/personal_project/rust_plc succeeded in 51ms:
                    task,
                    &step.name,
                    &from_state,
                    block_index,
                    block,
                    completion_target.clone(),
                    &task_initial_states,
                    &mut errors,
                    analyzed.actions.clone(),
                );
            }

            for (block_index, block) in analyzed.race_blocks.iter().enumerate() {
                build_race_block(
                    &mut builder,
                    task,
                    &step.name,
                    &from_state,
                    block_index,
                    block,



thinking
**Designing timing constraint analysis**
thinking
**Detailing timing duration computations and must-start-after logic**
thinking
**Finalizing timing verification diagnostics and test plans**
Plan update
Reviewed AST/IR/semantic transition patterns and defined how timing verification should compute worst-case and minimum intervals.
  ✓ Inspect current verification/semantic code and derive timing-checker data needed for US-014
  → Implement timing checker module with must_complete_within and must_start_after diagnostics plus tests
  • Run cargo quality checks, update PRD/progress, and commit story changes

thinking
**Implementing detailed timing verification**
exec
/bin/bash -lc "bash -lc 'cat > src/verification/timing.rs <<\"EOF\"
use crate::ast::{ActionStatement, PlcProgram, StepStatement};
use crate::ir::{ConstraintSet, StateMachine, TimingRelation, TimingScope, TopologyGraph, TransitionGuard};
use petgraph::visit::EdgeRef;
use std::collections::{HashMap, HashSet};
use std::fmt;

#[derive(Debug, Clone, PartialEq, Eq)]
pub struct TimingDiagnostic {
    pub line: usize,
    pub constraint: String,
    pub analysis: String,
    pub conclusion: String,
}

impl fmt::Display for TimingDiagnostic {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        writeln"'!(f, "ERROR [timing] 时序包络违反")?;
        writeln!(f, "  位置: <input>:{}:1", self.line)?;
        writeln!(f, "  约束: {}", self.constraint)?;
        writeln!(f, "  分析: {}", self.analysis)?;
        write!(f, "  结论: {}", self.conclusion)
    }
}

#[derive(Debug, Clone, Default)]
struct DeviceTimingProfile {
    response_ms: Option<u64>,
    stroke_ms: Option<u64>,
    retract_ms: Option<u64>,
    ramp_ms: Option<u64>,
}

#[derive(Debug, Clone, Default)]
struct StepTimingEstimate {
    action_max_ms: u64,
    timeout_max_ms: u64,
    worst_case_ms: u64,
    action_details: Vec<String>,
}

#[derive(Debug, Clone, Default)]
struct TimingContext {
    profiles: HashMap<String, DeviceTimingProfile>,
    // `A connected_to B` lowers to `B -> A`; store reverse adjacency for upstream response tracing.
    upstream_by_target: HashMap<String, Vec<String>>,
}

pub fn verify_timing(
    program: &PlcProgram,
    topology: &TopologyGraph,
    constraints: &ConstraintSet,
    state_machine: &StateMachine,
) -> Result<(), Vec<TimingDiagnostic>> {
    let context = TimingContext::from_inputs(program, topology);
    let step_estimates = build_step_estimates(program, &context);
    let task_worst_case = build_task_worst_case(program, &step_estimates);

    let mut diagnostics = Vec::new();

    for (index, rule) in constraints.timing.iter().enumerate() {
        let line = timing_constraint_line(program, index);
        let constraint_text = format_timing_constraint(rule);

        match rule.relation {
            TimingRelation::MustCompleteWithin => {
                let (observed_ms, analysis) = match &rule.scope {
                    TimingScope::Task { task } => {
                        let observed = task_worst_case.get(task).copied().unwrap_or(0);
                        (
                            observed,
                            format!("task {task} 的最坏关键路径时间 = {observed}ms（顺序 step 累加）"),
                        )
                    }
                    TimingScope::Step { task, step } => {
                        let key = step_key(task, step);
                        let estimate = step_estimates.get(&key).cloned().unwrap_or_default();
                        let mut analysis = format!(
                            "step {task}.{step} 的最坏关键路径时间 = {}ms（同 step 动作并行取最大值 {}ms，timeout 上界 {}ms）",
                            estimate.worst_case_ms, estimate.action_max_ms, estimate.timeout_max_ms
                        );
                        if !estimate.action_details.is_empty() {
                            analysis.push_str("；动作明细: ");
                            analysis.push_str(&estimate.action_details.join("；"));
                        }
                        (estimate.worst_case_ms, analysis)
                    }
                };

                if observed_ms > rule.duration_ms {
                    diagnostics.push(TimingDiagnostic {
                        line,
                        constraint: constraint_text,
                        analysis,
                        conclusion: format!(
                            "最坏情况下无法在 {}ms 内完成，当前关键路径为 {}ms",
                            rule.duration_ms, observed_ms
                        ),
                    });
                }
            }
            TimingRelation::MustStartAfter => {
                let (min_interval_ms, predecessor_detail) =
                    shortest_predecessor_interval_ms(&rule.scope, program, state_machine);

                if min_interval_ms < rule.duration_ms {
                    diagnostics.push(TimingDiagnostic {
                        line,
                        constraint: constraint_text,
                        analysis: format!(
                            "前驱结束到当前开始的最短间隔 = {min_interval_ms}ms（{predecessor_detail}）"
                        ),
                        conclusion: format!(
                            "无法保证 {} 在 {}ms 后才开始，当前最短间隔为 {}ms",
                            format_scope(&rule.scope),
                            rule.duration_ms,
                            min_interval_ms
                        ),
                    });
                }
            }
        }
    }

    if diagnostics.is_empty() {
        Ok(())
    } else {
        Err(diagnostics)
    }
}

impl TimingContext {
    fn from_inputs(program: &PlcProgram, topology: &TopologyGraph) -> Self {
        let mut profiles = HashMap::new();
        for device in &program.topology.devices {
            profiles.insert(
                device.name.clone(),
                DeviceTimingProfile {
                    response_ms: device.attributes.response_time.as_ref().map(duration_value_to_ms),
                    stroke_ms: device.attributes.stroke_time.as_ref().map(duration_value_to_ms),
                    retract_ms: device.attributes.retract_time.as_ref().map(duration_value_to_ms),
                    ramp_ms: device.attributes.ramp_time.as_ref().map(duration_value_to_ms),
                },
            );
        }

        let mut upstream_by_target = HashMap::<String, Vec<String>>::new();
        for edge in topology.graph.edge_references() {
            let source = topology.graph[edge.source()].name.clone();
            let target = topology.graph[edge.target()].name.clone();
            upstream_by_target.entry(target).or_default().push(source);
        }

        Self {
            profiles,
            upstream_by_target,
        }
    }

    fn action_duration_ms(&self, action: &ActionStatement) -> Option<(String, u64)> {
        let (target, action_name, own_duration_ms) = match action {
            ActionStatement::Extend { target } => {
                let profile = self.profiles.get(target)?;
                let own = profile
                    .stroke_ms
                    .or(profile.response_ms)
                    .or(profile.ramp_ms)?;
                (target.as_str(), format!("extend {target}"), own)
            }
            ActionStatement::Retract { target } => {
                let profile = self.profiles.get(target)?;
                let own = profile
                    .retract_ms
                    .or(profile.response_ms)
                    .or(profile.ramp_ms)?;
                (target.as_str(), format!("retract {target}"), own)
            }
            ActionStatement::Set { target, value } => {
                let profile = self.profiles.get(target)?;
                let own = profile.ramp_ms.or(profile.response_ms)?;
                (
                    target.as_str(),
                    format!("set {target} {}", binary_value_text(value)),
                    own,
                )
            }
            ActionStatement::Log { .. } => return None,
        };

        let upstream_response_ms = self.max_upstream_response_ms(target, &mut HashSet::new());
        let total_ms = own_duration_ms.saturating_add(upstream_response_ms);

        let detail = if upstream_response_ms > 0 {
            format!(
                "{action_name} = 动作本体 {own_duration_ms}ms + 上游 response_time {upstream_response_ms}ms = {total_ms}ms"
            )
        } else {
            format!("{action_name} = {total_ms}ms")
        };

        Some((detail, total_ms))
    }

    fn max_upstream_response_ms(&self, target: &str, visited: &mut HashSet<String>) -> u64 {
        if !visited.insert(target.to_string()) {
            return 0;
        }

        let mut best = 0;
        if let Some(upstream_nodes) = self.upstream_by_target.get(target) {
            for upstream in upstream_nodes {
                let own_response = self
                    .profiles
                    .get(upstream)
                    .and_then(|profile| profile.response_ms)
                    .unwrap_or(0);
                let chain_response = self.max_upstream_response_ms(upstream, visited);
                best = best.max(own_response.saturating_add(chain_response));
            }
        }

        visited.remove(target);
        best
    }
}

fn build_step_estimates(
    program: &PlcProgram,
    context: &TimingContext,
) -> HashMap<String, StepTimingEstimate> {
    let mut estimates = HashMap::new();

    for task in &program.tasks.tasks {
        for step in &task.steps {
            let mut actions = Vec::new();
            collect_actions(&step.statements, &mut actions);

            let mut action_max_ms = 0;
            let mut action_details = Vec::new();
            for action in &actions {
                if let Some((detail, duration_ms)) = context.action_duration_ms(action) {
                    action_max_ms = action_max_ms.max(duration_ms);
                    action_details.push(detail);
                }
            }

            let timeout_max_ms = max_timeout_ms(&step.statements);
            let worst_case_ms = action_max_ms.max(timeout_max_ms);

            estimates.insert(
                step_key(&task.name, &step.name),
                StepTimingEstimate {
                    action_max_ms,
                    timeout_max_ms,
                    worst_case_ms,
                    action_details,
                },
            );
        }
    }

    estimates
}

fn build_task_worst_case(
    program: &PlcProgram,
    step_estimates: &HashMap<String, StepTimingEstimate>,
) -> HashMap<String, u64> {
    let mut task_worst_case = HashMap::new();

    for task in &program.tasks.tasks {
        let total = task.steps.iter().fold(0u64, |acc, step| {
            let step_worst_case = step_estimates
                .get(&step_key(&task.name, &step.name))
                .map(|estimate| estimate.worst_case_ms)
                .unwrap_or(0);
            acc.saturating_add(step_worst_case)
        });
        task_worst_case.insert(task.name.clone(), total);
    }

    task_worst_case
}

fn shortest_predecessor_interval_ms(
    scope: &TimingScope,
    program: &PlcProgram,
    state_machine: &StateMachine,
) -> (u64, String) {
    let (target_task, target_step) = match scope {
        TimingScope::Task { task } => {
            let Some(step) = initial_step_for_task(program, task) else {
                return (0, format!("未找到 task {task} 的初始 step，按 0ms 处理"));
            };
            (task.as_str(), step)
        }
        TimingScope::Step { task, step } => (task.as_str(), step.as_str()),
    };

    let mut best: Option<(u64, String)> = None;

    for transition in &state_machine.transitions {
        if transition.to.task_name != target_task || transition.to.step_name != target_step {
            continue;
        }

        let interval_ms = transition_guard_min_interval_ms(&transition.guard);
        let detail = format!(
            "{}.{}, guard={} -> {}.{}",
            transition.from.task_name,
            transition.from.step_name,
            transition_guard_name(&transition.guard),
            transition.to.task_name,
            transition.to.step_name
        );

        let replace = best
            .as_ref()
            .map(|(best_interval, _)| interval_ms < *best_interval)
            .unwrap_or(true);

        if replace {
            best = Some((interval_ms, detail));
        }
    }

    if let Some(result) = best {
        return result;
    }

    if state_machine.initial.task_name == target_task && state_machine.initial.step_name == target_step {
        return (0, "目标是状态机初始状态，无前驱延迟".to_string());
    }

    (0, "未找到前驱转移，按 0ms 处理".to_string())
}

fn transition_guard_min_interval_ms(guard: &TransitionGuard) -> u64 {
    match guard {
        TransitionGuard::Timeout { duration_ms } => *duration_ms,
        TransitionGuard::Always | TransitionGuard::Condition { .. } => 0,
    }
}

fn transition_guard_name(guard: &TransitionGuard) -> String {
    match guard {
        TransitionGuard::Always => "always".to_string(),
        TransitionGuard::Condition { expression } => format!("condition({expression})"),
        TransitionGuard::Timeout { duration_ms } => format!("timeout({duration_ms}ms)"),
    }
}

fn collect_actions(statements: &[StepStatement], actions: &mut Vec<ActionStatement>) {
    for statement in statements {
        match statement {
            StepStatement::Action(action) => actions.push(action.clone()),
            StepStatement::Parallel(block) => {
                for branch in &block.branches {
                    collect_actions(&branch.statements, actions);
                }
            }
            StepStatement::Race(block) => {
                for branch in &block.branches {
                    collect_actions(&branch.statements, actions);
                }
            }
            StepStatement::Wait(_)
            | StepStatement::Timeout(_)
            | StepStatement::Goto(_)
            | StepStatement::AllowIndefiniteWait(_) => {}
        }
    }
}

fn max_timeout_ms(statements: &[StepStatement]) -> u64 {
    let mut timeout_max_ms = 0;

    for statement in statements {
        match statement {
            StepStatement::Timeout(timeout) => {
                timeout_max_ms = timeout_max_ms.max(duration_value_to_ms(&timeout.duration));
            }
            StepStatement::Parallel(block) => {
                for branch in &block.branches {
                    timeout_max_ms = timeout_max_ms.max(max_timeout_ms(&branch.statements));
                }
            }
            StepStatement::Race(block) => {
                for branch in &block.branches {
                    timeout_max_ms = timeout_max_ms.max(max_timeout_ms(&branch.statements));
                }
            }
            StepStatement::Action(_)
            | StepStatement::Wait(_)
            | StepStatement::Goto(_)
            | StepStatement::AllowIndefiniteWait(_) => {}
        }
    }

    timeout_max_ms
}

fn step_key(task: &str, step: &str) -> String {
    format!("{task}.{step}")
}

fn format_timing_constraint(rule: &crate::ir::TimingRule) -> String {
    format!(
        "{} {} {}ms",
        format_scope(&rule.scope),
        format_relation(&rule.relation),
        rule.duration_ms
    )
}

fn format_scope(scope: &TimingScope) -> String {
    match scope {
        TimingScope::Task { task } => format!("task.{task}"),
        TimingScope::Step { task, step } => format!("task.{task}.{step}"),
    }
}

fn format_relation(relation: &TimingRelation) -> &'"'static str {
    match relation {
        TimingRelation::MustCompleteWithin => \"must_complete_within\",
        TimingRelation::MustStartAfter => \"must_start_after\",
    }
}

fn timing_constraint_line(program: &PlcProgram, index: usize) -> usize {
    program
        .constraints
        .timing
        .get(index)
        .map(|constraint| constraint.line.max(1))
        .unwrap_or(1)
}

fn duration_value_to_ms(duration: &crate::ast::DurationValue) -> u64 {
    match duration.unit {
        crate::ast::TimeUnit::Ms => duration.value,
        crate::ast::TimeUnit::S => duration.value.saturating_mul(1000),
    }
}

fn binary_value_text(value: &crate::ast::BinaryValue) -> &'static str {
    match value {
        crate::ast::BinaryValue::On => \"on\",
        crate::ast::BinaryValue::Off => \"off\",
    }
}

fn initial_step_for_task<'a>(program: &'a PlcProgram, task_name: &str) -> Option<&'a str> {
    program
        .tasks
        .tasks
        .iter()
        .find(|task| task.name == task_name)
        .and_then(|task| task.steps.first())
        .map(|step| step.name.as_str())
}

#[cfg(test)]
mod tests {
    use super::verify_timing;
    use crate::parser::parse_plc;
    use crate::semantic::{build_constraint_set, build_state_machine, build_topology_graph};

    #[test]
    fn passes_when_step_stroke_time_is_within_constraint() {
        let source = r#\"
[topology]

device Y0: digital_output

device valve_A: solenoid_valve {
    connected_to: Y0,
    response_time: 20ms
}

device cyl_A: cylinder {
    connected_to: valve_A,
    stroke_time: 200ms,
    retract_time: 180ms
}

[constraints]

timing: task.init.step_extend_A must_complete_within 500ms

[tasks]

task init:
    step step_extend_A:
        action: extend cyl_A
\"#;

        let program = parse_plc(source).expect(\"测试程序应能解析\");
        let topology = build_topology_graph(&program).expect(\"拓扑应构建成功\");
        let constraints = build_constraint_set(&program).expect(\"约束应构建成功\");
        let state_machine = build_state_machine(&program).expect(\"状态机应构建成功\");

        verify_timing(&program, &topology, &constraints, &state_machine)
            .expect(\"200ms(动作) + 20ms(上游响应) < 500ms 时应通过\");
    }

    #[test]
    fn fails_when_step_stroke_time_exceeds_constraint() {
        let source = r#\"
[topology]

device Y0: digital_output

device valve_A: solenoid_valve {
    connected_to: Y0,
    response_time: 20ms
}

device cyl_A: cylinder {
    connected_to: valve_A,
    stroke_time: 200ms,
    retract_time: 180ms
}

[constraints]

timing: task.init.step_extend_A must_complete_within 100ms

[tasks]

task init:
    step step_extend_A:
        action: extend cyl_A
\"#;

        let program = parse_plc(source).expect(\"测试程序应能解析\");
        let topology = build_topology_graph(&program).expect(\"拓扑应构建成功\");
        let constraints = build_constraint_set(&program).expect(\"约束应构建成功\");
        let state_machine = build_state_machine(&program).expect(\"状态机应构建成功\");

        let errors = verify_timing(&program, &topology, &constraints, &state_machine)
            .expect_err(\"200ms+20ms 超过 100ms 时应报时序错误\");

        assert"'!(
            errors
                .iter()
                .any(|error| error.to_string().contains("ERROR [timing] 时序包络违反")),
            "错误信息应包含 timing 标题"
        );
        assert!(
            errors
                .iter()
                .any(|error| error.to_string().contains("无法在 100ms 内完成")),
            "错误结论应指出违反约束"
        );
        assert!(
            errors
                .iter()
                .any(|error| error.to_string().contains("220ms")),
            "错误分析应体现上游 response_time + stroke_time 的链路时间"
        );
    }

    #[test]
    fn passes_must_start_after_when_shortest_interval_is_sufficient() {
        let source = r#"
[topology]

[constraints]

timing: task.cooldown must_start_after 200ms

[tasks]

task pre:
    step hold:
        timeout: 300ms -> goto cooldown

task cooldown:
    step begin:
        action: log "ok"
"#;

        let program = parse_plc(source).expect("测试程序应能解析");
        let topology = build_topology_graph(&program).expect("拓扑应构建成功");
        let constraints = build_constraint_set(&program).expect("约束应构建成功");
        let state_machine = build_state_machine(&program).expect("状态机应构建成功");

        verify_timing(&program, &topology, &constraints, &state_machine)
            .expect("最短间隔 300ms 足以满足 must_start_after 200ms");
    }

    #[test]
    fn fails_must_start_after_when_shortest_interval_is_insufficient() {
        let source = r#"
[topology]

[constraints]

timing: task.cooldown must_start_after 200ms

[tasks]

task pre:
    step hold:
        timeout: 100ms -> goto cooldown

task cooldown:
    step begin:
        action: log "ok"
"#;

        let program = parse_plc(source).expect("测试程序应能解析");
        let topology = build_topology_graph(&program).expect("拓扑应构建成功");
        let constraints = build_constraint_set(&program).expect("约束应构建成功");
        let state_machine = build_state_machine(&program).expect("状态机应构建成功");

        let errors = verify_timing(&program, &topology, &constraints, &state_machine)
            .expect_err("最短间隔不足时应报错");

        assert!(
            errors.iter().any(|error| {
                error.to_string().contains(
                    "无法保证 task.cooldown 在 200ms 后才开始，当前最短间隔为 100ms",
                )
            }),
            "错误应包含 must_start_after 失败模板"
        );
    }
}
EOF'"'" in /mnt/e/personal_project/rust_plc exited 2 in 51ms:
/bin/bash: -c: line 17: syntax error near unexpected token `)'
/bin/bash: -c: line 17: `    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {'

thinking
**Fixing heredoc quoting for single quotes**
exec
/bin/bash -lc "cat > src/verification/timing.rs <<'EOF'
use crate::ast::{ActionStatement, PlcProgram, StepStatement};
use crate::ir::{ConstraintSet, StateMachine, TimingRelation, TimingScope, TopologyGraph, TransitionGuard};
use petgraph::visit::EdgeRef;
use std::collections::{HashMap, HashSet};
use std::fmt;

#[derive(Debug, Clone, PartialEq, Eq)]
pub struct TimingDiagnostic {
    pub line: usize,
    pub constraint: String,
    pub analysis: String,
    pub conclusion: String,
}

impl fmt::Display for TimingDiagnostic {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        writeln"'!(f, "ERROR [timing] 时序包络违反")?;
        writeln!(f, "  位置: <input>:{}:1", self.line)?;
        writeln!(f, "  约束: {}", self.constraint)?;
        writeln!(f, "  分析: {}", self.analysis)?;
        write!(f, "  结论: {}", self.conclusion)
    }
}

#[derive(Debug, Clone, Default)]
struct DeviceTimingProfile {
    response_ms: Option<u64>,
    stroke_ms: Option<u64>,
    retract_ms: Option<u64>,
    ramp_ms: Option<u64>,
}

#[derive(Debug, Clone, Default)]
struct StepTimingEstimate {
    action_max_ms: u64,
    timeout_max_ms: u64,
    worst_case_ms: u64,
    action_details: Vec<String>,
}

#[derive(Debug, Clone, Default)]
struct TimingContext {
    profiles: HashMap<String, DeviceTimingProfile>,
    // `A connected_to B` lowers to `B -> A`; store reverse adjacency for upstream response tracing.
    upstream_by_target: HashMap<String, Vec<String>>,
}

pub fn verify_timing(
    program: &PlcProgram,
    topology: &TopologyGraph,
    constraints: &ConstraintSet,
    state_machine: &StateMachine,
) -> Result<(), Vec<TimingDiagnostic>> {
    let context = TimingContext::from_inputs(program, topology);
    let step_estimates = build_step_estimates(program, &context);
    let task_worst_case = build_task_worst_case(program, &step_estimates);

    let mut diagnostics = Vec::new();

    for (index, rule) in constraints.timing.iter().enumerate() {
        let line = timing_constraint_line(program, index);
        let constraint_text = format_timing_constraint(rule);

        match rule.relation {
            TimingRelation::MustCompleteWithin => {
                let (observed_ms, analysis) = match &rule.scope {
                    TimingScope::Task { task } => {
                        let observed = task_worst_case.get(task).copied().unwrap_or(0);
                        (
                            observed,
                            format!("task {task} 的最坏关键路径时间 = {observed}ms（顺序 step 累加）"),
                        )
                    }
                    TimingScope::Step { task, step } => {
                        let key = step_key(task, step);
                        let estimate = step_estimates.get(&key).cloned().unwrap_or_default();
                        let mut analysis = format!(
                            "step {task}.{step} 的最坏关键路径时间 = {}ms（同 step 动作并行取最大值 {}ms，timeout 上界 {}ms）",
                            estimate.worst_case_ms, estimate.action_max_ms, estimate.timeout_max_ms
                        );
                        if !estimate.action_details.is_empty() {
                            analysis.push_str("；动作明细: ");
                            analysis.push_str(&estimate.action_details.join("；"));
                        }
                        (estimate.worst_case_ms, analysis)
                    }
                };

                if observed_ms > rule.duration_ms {
                    diagnostics.push(TimingDiagnostic {
                        line,
                        constraint: constraint_text,
                        analysis,
                        conclusion: format!(
                            "最坏情况下无法在 {}ms 内完成，当前关键路径为 {}ms",
                            rule.duration_ms, observed_ms
                        ),
                    });
                }
            }
            TimingRelation::MustStartAfter => {
                let (min_interval_ms, predecessor_detail) =
                    shortest_predecessor_interval_ms(&rule.scope, program, state_machine);

                if min_interval_ms < rule.duration_ms {
                    diagnostics.push(TimingDiagnostic {
                        line,
                        constraint: constraint_text,
                        analysis: format!(
                            "前驱结束到当前开始的最短间隔 = {min_interval_ms}ms（{predecessor_detail}）"
                        ),
                        conclusion: format!(
                            "无法保证 {} 在 {}ms 后才开始，当前最短间隔为 {}ms",
                            format_scope(&rule.scope),
                            rule.duration_ms,
                            min_interval_ms
                        ),
                    });
                }
            }
        }
    }

    if diagnostics.is_empty() {
        Ok(())
    } else {
        Err(diagnostics)
    }
}

impl TimingContext {
    fn from_inputs(program: &PlcProgram, topology: &TopologyGraph) -> Self {
        let mut profiles = HashMap::new();
        for device in &program.topology.devices {
            profiles.insert(
                device.name.clone(),
                DeviceTimingProfile {
                    response_ms: device.attributes.response_time.as_ref().map(duration_value_to_ms),
                    stroke_ms: device.attributes.stroke_time.as_ref().map(duration_value_to_ms),
                    retract_ms: device.attributes.retract_time.as_ref().map(duration_value_to_ms),
                    ramp_ms: device.attributes.ramp_time.as_ref().map(duration_value_to_ms),
                },
            );
        }

        let mut upstream_by_target = HashMap::<String, Vec<String>>::new();
        for edge in topology.graph.edge_references() {
            let source = topology.graph[edge.source()].name.clone();
            let target = topology.graph[edge.target()].name.clone();
            upstream_by_target.entry(target).or_default().push(source);
        }

        Self {
            profiles,
            upstream_by_target,
        }
    }

    fn action_duration_ms(&self, action: &ActionStatement) -> Option<(String, u64)> {
        let (target, action_name, own_duration_ms) = match action {
            ActionStatement::Extend { target } => {
                let profile = self.profiles.get(target)?;
                let own = profile.stroke_ms.or(profile.response_ms).or(profile.ramp_ms)?;
                (target.as_str(), format!("extend {target}"), own)
            }
            ActionStatement::Retract { target } => {
                let profile = self.profiles.get(target)?;
                let own = profile
                    .retract_ms
                    .or(profile.response_ms)
                    .or(profile.ramp_ms)?;
                (target.as_str(), format!("retract {target}"), own)
            }
            ActionStatement::Set { target, value } => {
                let profile = self.profiles.get(target)?;
                let own = profile.ramp_ms.or(profile.response_ms)?;
                (
                    target.as_str(),
                    format!("set {target} {}", binary_value_text(value)),
                    own,
                )
            }
            ActionStatement::Log { .. } => return None,
        };

        let upstream_response_ms = self.max_upstream_response_ms(target, &mut HashSet::new());
        let total_ms = own_duration_ms.saturating_add(upstream_response_ms);

        let detail = if upstream_response_ms > 0 {
            format!(
                "{action_name} = 动作本体 {own_duration_ms}ms + 上游 response_time {upstream_response_ms}ms = {total_ms}ms"
            )
        } else {
            format!("{action_name} = {total_ms}ms")
        };

        Some((detail, total_ms))
    }

    fn max_upstream_response_ms(&self, target: &str, visited: &mut HashSet<String>) -> u64 {
        if !visited.insert(target.to_string()) {
            return 0;
        }

        let mut best = 0;
        if let Some(upstream_nodes) = self.upstream_by_target.get(target) {
            for upstream in upstream_nodes {
                let own_response = self
                    .profiles
                    .get(upstream)
                    .and_then(|profile| profile.response_ms)
                    .unwrap_or(0);
                let chain_response = self.max_upstream_response_ms(upstream, visited);
                best = best.max(own_response.saturating_add(chain_response));
            }
        }

        visited.remove(target);
        best
    }
}

fn build_step_estimates(
    program: &PlcProgram,
    context: &TimingContext,
) -> HashMap<String, StepTimingEstimate> {
    let mut estimates = HashMap::new();

    for task in &program.tasks.tasks {
        for step in &task.steps {
            let mut actions = Vec::new();
            collect_actions(&step.statements, &mut actions);

            let mut action_max_ms = 0;
            let mut action_details = Vec::new();
            for action in &actions {
                if let Some((detail, duration_ms)) = context.action_duration_ms(action) {
                    action_max_ms = action_max_ms.max(duration_ms);
                    action_details.push(detail);
                }
            }

            let timeout_max_ms = max_timeout_ms(&step.statements);
            let worst_case_ms = action_max_ms.max(timeout_max_ms);

            estimates.insert(
                step_key(&task.name, &step.name),
                StepTimingEstimate {
                    action_max_ms,
                    timeout_max_ms,
                    worst_case_ms,
                    action_details,
                },
            );
        }
    }

    estimates
}

fn build_task_worst_case(
    program: &PlcProgram,
    step_estimates: &HashMap<String, StepTimingEstimate>,
) -> HashMap<String, u64> {
    let mut task_worst_case = HashMap::new();

    for task in &program.tasks.tasks {
        let total = task.steps.iter().fold(0u64, |acc, step| {
            let step_worst_case = step_estimates
                .get(&step_key(&task.name, &step.name))
                .map(|estimate| estimate.worst_case_ms)
                .unwrap_or(0);
            acc.saturating_add(step_worst_case)
        });
        task_worst_case.insert(task.name.clone(), total);
    }

    task_worst_case
}

fn shortest_predecessor_interval_ms(
    scope: &TimingScope,
    program: &PlcProgram,
    state_machine: &StateMachine,
) -> (u64, String) {
    let (target_task, target_step) = match scope {
        TimingScope::Task { task } => {
            let Some(step) = initial_step_for_task(program, task) else {
                return (0, format!("未找到 task {task} 的初始 step，按 0ms 处理"));
            };
            (task.as_str(), step)
        }
        TimingScope::Step { task, step } => (task.as_str(), step.as_str()),
    };

    let mut best: Option<(u64, String)> = None;

    for transition in &state_machine.transitions {
        if transition.to.task_name != target_task || transition.to.step_name != target_step {
            continue;
        }

        let interval_ms = transition_guard_min_interval_ms(&transition.guard);
        let detail = format!(
            "{}.{}, guard={} -> {}.{}",
            transition.from.task_name,
            transition.from.step_name,
            transition_guard_name(&transition.guard),
            transition.to.task_name,
            transition.to.step_name
        );

        let replace = best
            .as_ref()
            .map(|(best_interval, _)| interval_ms < *best_interval)
            .unwrap_or(true);

        if replace {
            best = Some((interval_ms, detail));
        }
    }

    if let Some(result) = best {
        return result;
    }

    if state_machine.initial.task_name == target_task && state_machine.initial.step_name == target_step {
        return (0, "目标是状态机初始状态，无前驱延迟".to_string());
    }

    (0, "未找到前驱转移，按 0ms 处理".to_string())
}

fn transition_guard_min_interval_ms(guard: &TransitionGuard) -> u64 {
    match guard {
        TransitionGuard::Timeout { duration_ms } => *duration_ms,
        TransitionGuard::Always | TransitionGuard::Condition { .. } => 0,
    }
}

fn transition_guard_name(guard: &TransitionGuard) -> String {
    match guard {
        TransitionGuard::Always => "always".to_string(),
        TransitionGuard::Condition { expression } => format!("condition({expression})"),
        TransitionGuard::Timeout { duration_ms } => format!("timeout({duration_ms}ms)"),
    }
}

fn collect_actions(statements: &[StepStatement], actions: &mut Vec<ActionStatement>) {
    for statement in statements {
        match statement {
            StepStatement::Action(action) => actions.push(action.clone()),
            StepStatement::Parallel(block) => {
                for branch in &block.branches {
                    collect_actions(&branch.statements, actions);
                }
            }
            StepStatement::Race(block) => {
                for branch in &block.branches {
                    collect_actions(&branch.statements, actions);
                }
            }
            StepStatement::Wait(_)
            | StepStatement::Timeout(_)
            | StepStatement::Goto(_)
            | StepStatement::AllowIndefiniteWait(_) => {}
        }
    }
}

fn max_timeout_ms(statements: &[StepStatement]) -> u64 {
    let mut timeout_max_ms = 0;

    for statement in statements {
        match statement {
            StepStatement::Timeout(timeout) => {
                timeout_max_ms = timeout_max_ms.max(duration_value_to_ms(&timeout.duration));
            }
            StepStatement::Parallel(block) => {
                for branch in &block.branches {
                    timeout_max_ms = timeout_max_ms.max(max_timeout_ms(&branch.statements));
                }
            }
            StepStatement::Race(block) => {
                for branch in &block.branches {
                    timeout_max_ms = timeout_max_ms.max(max_timeout_ms(&branch.statements));
                }
            }
            StepStatement::Action(_)
            | StepStatement::Wait(_)
            | StepStatement::Goto(_)
            | StepStatement::AllowIndefiniteWait(_) => {}
        }
    }

    timeout_max_ms
}

fn step_key(task: &str, step: &str) -> String {
    format!("{task}.{step}")
}

fn format_timing_constraint(rule: &crate::ir::TimingRule) -> String {
    format!(
        "{} {} {}ms",
        format_scope(&rule.scope),
        format_relation(&rule.relation),
        rule.duration_ms
    )
}

fn format_scope(scope: &TimingScope) -> String {
    match scope {
        TimingScope::Task { task } => format!("task.{task}"),
        TimingScope::Step { task, step } => format!("task.{task}.{step}"),
    }
}

fn format_relation(relation: &TimingRelation) -> &'"'static str {
    match relation {
        TimingRelation::MustCompleteWithin => \"must_complete_within\",
        TimingRelation::MustStartAfter => \"must_start_after\",
    }
}

fn timing_constraint_line(program: &PlcProgram, index: usize) -> usize {
    program
        .constraints
        .timing
        .get(index)
        .map(|constraint| constraint.line.max(1))
        .unwrap_or(1)
}

fn duration_value_to_ms(duration: &crate::ast::DurationValue) -> u64 {
    match duration.unit {
        crate::ast::TimeUnit::Ms => duration.value,
        crate::ast::TimeUnit::S => duration.value.saturating_mul(1000),
    }
}

fn binary_value_text(value: &crate::ast::BinaryValue) -> &'static str {
    match value {
        crate::ast::BinaryValue::On => \"on\",
        crate::ast::BinaryValue::Off => \"off\",
    }
}

fn initial_step_for_task<'a>(program: &'a PlcProgram, task_name: &str) -> Option<&'a str> {
    program
        .tasks
        .tasks
        .iter()
        .find(|task| task.name == task_name)
        .and_then(|task| task.steps.first())
        .map(|step| step.name.as_str())
}

#[cfg(test)]
mod tests {
    use super::verify_timing;
    use crate::parser::parse_plc;
    use crate::semantic::{build_constraint_set, build_state_machine, build_topology_graph};

    #[test]
    fn passes_when_step_stroke_time_is_within_constraint() {
        let source = r#\"
[topology]

device Y0: digital_output

device valve_A: solenoid_valve {
    connected_to: Y0,
    response_time: 20ms
}

device cyl_A: cylinder {
    connected_to: valve_A,
    stroke_time: 200ms,
    retract_time: 180ms
}

[constraints]

timing: task.init.step_extend_A must_complete_within 500ms

[tasks]

task init:
    step step_extend_A:
        action: extend cyl_A
\"#;

        let program = parse_plc(source).expect(\"测试程序应能解析\");
        let topology = build_topology_graph(&program).expect(\"拓扑应构建成功\");
        let constraints = build_constraint_set(&program).expect(\"约束应构建成功\");
        let state_machine = build_state_machine(&program).expect(\"状态机应构建成功\");

        verify_timing(&program, &topology, &constraints, &state_machine)
            .expect(\"200ms(动作) + 20ms(上游响应) < 500ms 时应通过\");
    }

    #[test]
    fn fails_when_step_stroke_time_exceeds_constraint() {
        let source = r#\"
[topology]

device Y0: digital_output

device valve_A: solenoid_valve {
    connected_to: Y0,
    response_time: 20ms
}

device cyl_A: cylinder {
    connected_to: valve_A,
    stroke_time: 200ms,
    retract_time: 180ms
}

[constraints]

timing: task.init.step_extend_A must_complete_within 100ms

[tasks]

task init:
    step step_extend_A:
        action: extend cyl_A
\"#;

        let program = parse_plc(source).expect(\"测试程序应能解析\");
        let topology = build_topology_graph(&program).expect(\"拓扑应构建成功\");
        let constraints = build_constraint_set(&program).expect(\"约束应构建成功\");
        let state_machine = build_state_machine(&program).expect(\"状态机应构建成功\");

        let errors = verify_timing(&program, &topology, &constraints, &state_machine)
            .expect_err(\"200ms+20ms 超过 100ms 时应报时序错误\");

        assert"'!(
            errors
                .iter()
                .any(|error| error.to_string().contains("ERROR [timing] 时序包络违反")),
            "错误信息应包含 timing 标题"
        );
        assert!(
            errors
                .iter()
                .any(|error| error.to_string().contains("无法在 100ms 内完成")),
            "错误结论应指出违反约束"
        );
        assert!(
            errors
                .iter()
                .any(|error| error.to_string().contains("220ms")),
            "错误分析应体现上游 response_time + stroke_time 的链路时间"
        );
    }

    #[test]
    fn passes_must_start_after_when_shortest_interval_is_sufficient() {
        let source = r#"
[topology]

[constraints]

timing: task.cooldown must_start_after 200ms

[tasks]

task pre:
    step hold:
        timeout: 300ms -> goto cooldown

task cooldown:
    step begin:
        action: log "ok"
"#;

        let program = parse_plc(source).expect("测试程序应能解析");
        let topology = build_topology_graph(&program).expect("拓扑应构建成功");
        let constraints = build_constraint_set(&program).expect("约束应构建成功");
        let state_machine = build_state_machine(&program).expect("状态机应构建成功");

        verify_timing(&program, &topology, &constraints, &state_machine)
            .expect("最短间隔 300ms 足以满足 must_start_after 200ms");
    }

    #[test]
    fn fails_must_start_after_when_shortest_interval_is_insufficient() {
        let source = r#"
[topology]

[constraints]

timing: task.cooldown must_start_after 200ms

[tasks]

task pre:
    step hold:
        timeout: 100ms -> goto cooldown

task cooldown:
    step begin:
        action: log "ok"
"#;

        let program = parse_plc(source).expect("测试程序应能解析");
        let topology = build_topology_graph(&program).expect("拓扑应构建成功");
        let constraints = build_constraint_set(&program).expect("约束应构建成功");
        let state_machine = build_state_machine(&program).expect("状态机应构建成功");

        let errors = verify_timing(&program, &topology, &constraints, &state_machine)
            .expect_err("最短间隔不足时应报错");

        assert!(
            errors.iter().any(|error| {
                error.to_string().contains(
                    "无法保证 task.cooldown 在 200ms 后才开始，当前最短间隔为 100ms",
                )
            }),
            "错误应包含 must_start_after 失败模板"
        );
    }
}
EOF' in /mnt/e/personal_project/rust_plc succeeded in 51ms:


thinking
**Updating module declarations**
file update
M /mnt/e/personal_project/rust_plc/src/verification/mod.rs
@@ -1 +1,2 @@
 pub mod causality;
+pub mod timing;
apply_patch(auto_approved=true) exited 0 in 52ms:
Success. Updated the following files:
M src/verification/mod.rs
file update:
diff --git a/src/verification/mod.rs b/src/verification/mod.rs
index 210f379c1e732ffff36ac3222eb51055c809581d..f6ab36aa410316b9e4d4170d094e9ae2085fcbf0
--- a/src/verification/mod.rs
+++ b/src/verification/mod.rs
@@ -1 +1,2 @@
 pub mod causality;
+pub mod timing;

file update:
diff --git a/src/verification/mod.rs b/src/verification/mod.rs
index 210f379c1e732ffff36ac3222eb51055c809581d..f6ab36aa410316b9e4d4170d094e9ae2085fcbf0
--- a/src/verification/mod.rs
+++ b/src/verification/mod.rs
@@ -1 +1,2 @@
 pub mod causality;
+pub mod timing;


thinking
**Running tests and formatting checks**
exec
/bin/bash -lc 'cargo test' in /mnt/e/personal_project/rust_plc succeeded in 16.66s:
   Compiling rust_plc v0.1.0 (/mnt/e/personal_project/rust_plc)
    Finished `test` profile [unoptimized + debuginfo] target(s) in 16.04s
     Running unittests src/lib.rs (target/debug/deps/rust_plc-750d18e2a560a5e9)

running 30 tests
test error::tests::format_undefined_reference_contains_missing_device_name ... ok
test ir::tests::topology_graph_supports_device_nodes_and_connection_edges ... ok
test error::tests::format_parse_error_contains_line_and_chinese_message ... ok
test parser::tests::parses_prd_5_5_2_wait_and_jump_tasks_example ... ok
test parser::tests::parses_prd_5_5_1_basic_sequence_tasks_example ... ok
test parser::tests::parses_requires_and_must_start_after_constraints ... ok
test parser::tests::parses_prd_5_5_3_fault_handler_tasks_example ... ok
test parser::tests::parses_prd_5_4_constraints_example ... ok
test parser::tests::parses_all_topology_device_types_and_property_shapes ... ok
test parser::tests::parses_prd_5_5_4_parallel_tasks_example ... ok
test parser::tests::parses_prd_5_3_topology_example ... ok
test parser::tests::parses_prd_5_5_5_race_tasks_example ... ok
test parser::tests::parse_plc_reports_line_number_for_syntax_errors ... ok
test semantic::tests::reports_error_when_connected_to_references_undefined_device ... ok
test semantic::tests::reports_undefined_goto_target_with_line_number ... ok
file update:
diff --git a/src/verification/mod.rs b/src/verification/mod.rs
index 210f379c1e732ffff36ac3222eb51055c809581d..f6ab36aa410316b9e4d4170d094e9ae2085fcbf0
--- a/src/verification/mod.rs
+++ b/src/verification/mod.rs
@@ -1 +1,2 @@
 pub mod causality;
+pub mod timing;


thinking
**Running code formatter**
exec
/bin/bash -lc 'cargo fmt' in /mnt/e/personal_project/rust_plc succeeded in 153ms:

file update:
diff --git a/src/verification/mod.rs b/src/verification/mod.rs
index 210f379c1e732ffff36ac3222eb51055c809581d..f6ab36aa410316b9e4d4170d094e9ae2085fcbf0
--- a/src/verification/mod.rs
+++ b/src/verification/mod.rs
@@ -1 +1,2 @@
 pub mod causality;
+pub mod timing;


thinking
**Rerunning tests after formatting**
exec
/bin/bash -lc 'cargo test' in /mnt/e/personal_project/rust_plc succeeded in 15.00s:
   Compiling rust_plc v0.1.0 (/mnt/e/personal_project/rust_plc)
    Finished `test` profile [unoptimized + debuginfo] target(s) in 14.51s
     Running unittests src/lib.rs (target/debug/deps/rust_plc-750d18e2a560a5e9)

running 30 tests
test error::tests::format_parse_error_contains_line_and_chinese_message ... ok
test error::tests::format_undefined_reference_contains_missing_device_name ... ok
test ir::tests::topology_graph_supports_device_nodes_and_connection_edges ... ok
test ir::tests::ir_structures_are_serializable_to_pretty_json ... ok
test parser::tests::parses_requires_and_must_start_after_constraints ... ok
test parser::tests::parses_prd_5_5_5_race_tasks_example ... ok
test parser::tests::parses_prd_5_4_constraints_example ... ok
test parser::tests::parse_plc_reports_line_number_for_syntax_errors ... ok
test parser::tests::parses_all_topology_device_types_and_property_shapes ... ok
test parser::tests::parses_prd_5_5_4_parallel_tasks_example ... ok
test parser::tests::parses_prd_5_5_2_wait_and_jump_tasks_example ... ok
test parser::tests::parses_prd_5_5_3_fault_handler_tasks_example ... ok
test parser::tests::parses_prd_5_5_1_basic_sequence_tasks_example ... ok
test parser::tests::parses_prd_5_3_topology_example ... ok
test semantic::tests::reports_error_when_connected_to_references_undefined_device ... ok
file update:
diff --git a/src/verification/mod.rs b/src/verification/mod.rs
index 210f379c1e732ffff36ac3222eb51055c809581d..f6ab36aa410316b9e4d4170d094e9ae2085fcbf0
--- a/src/verification/mod.rs
+++ b/src/verification/mod.rs
@@ -1 +1,2 @@
 pub mod causality;
+pub mod timing;


thinking
**Confirming no AGENTS update needed**
Plan update
Timing verifier added with Chinese diagnostics and four unit tests; now finalizing PRD/progress updates and commit.
  ✓ Inspect current verification/semantic code and derive timing-checker data needed for US-014
  ✓ Implement timing checker module with must_complete_within and must_start_after diagnostics plus tests
  → Run cargo quality checks, update PRD/progress, and commit story changes
file update:
diff --git a/src/verification/mod.rs b/src/verification/mod.rs
index 210f379c1e732ffff36ac3222eb51055c809581d..f6ab36aa410316b9e4d4170d094e9ae2085fcbf0
--- a/src/verification/mod.rs
+++ b/src/verification/mod.rs
@@ -1 +1,2 @@
 pub mod causality;
+pub mod timing;


thinking
**Confirming python3 availability**
exec
/bin/bash -lc 'python3 --version' in /mnt/e/personal_project/rust_plc succeeded in 50ms:
Python 3.12.3
file update:
diff --git a/src/verification/mod.rs b/src/verification/mod.rs
index 210f379c1e732ffff36ac3222eb51055c809581d..f6ab36aa410316b9e4d4170d094e9ae2085fcbf0
--- a/src/verification/mod.rs
+++ b/src/verification/mod.rs
@@ -1 +1,2 @@
 pub mod causality;
+pub mod timing;


thinking
**Planning progress append and commit**
exec
/bin/bash -lc "python3 - <<'PY'
import json
from pathlib import Path
path = Path('prd.json')
obj = json.loads(path.read_text())
for story in obj.get('userStories', []):
    if story.get('id') == 'US-014':
        story['passes'] = True
        break
else:
    raise SystemExit('US-014 not found')
path.write_text(json.dumps(obj, ensure_ascii=False, indent=2) + '\\n')
PY" in /mnt/e/personal_project/rust_plc succeeded in 51ms:

file update:
diff --git a/src/verification/mod.rs b/src/verification/mod.rs
index 210f379c1e732ffff36ac3222eb51055c809581d..f6ab36aa410316b9e4d4170d094e9ae2085fcbf0
--- a/src/verification/mod.rs
+++ b/src/verification/mod.rs
@@ -1 +1,2 @@
 pub mod causality;
+pub mod timing;


thinking
**Scripting timestamped progress update**
exec
/bin/bash -lc "python3 - <<'PY'
from pathlib import Path
from datetime import datetime
import subprocess
path = Path('progress.txt')
text = path.read_text()
pattern_line = \"- For timing envelopes, include upstream "'`response_time` along `connected_to` chains and treat incoming `StateMachine` guards as must_start_after lower bounds (`timeout` contributes delay, `always/condition` = 0ms)."
if pattern_line not in text:
    marker = "## Codebase Patterns'"\\n\"
    idx = text.find(marker)
    if idx == -1:
        text = marker + pattern_line + \"\\n\" + text
    else:
        insert_at = idx + len(marker)
        text = text[:insert_at] + pattern_line + \"\\n\" + text[insert_at:]

timestamp = subprocess.check_output(['date', '+%Y-%m-%d %H:%M:%S %Z'], text=True).strip()
entry = f\"\\n## [{timestamp}] - US-014\\nThread: https://ampcode.com/threads/"'$AMP_CURRENT_THREAD_ID'"\\n- What was implemented\\n  - Added "'`src/verification/timing.rs` with `verify_timing` to validate `must_complete_within` and `must_start_after` timing rules against topology/constraints/state machine IR.'"\\n  - Implemented worst-case timing envelopes: same-step actions are treated as parallel (max duration), step timeouts provide upper bounds, and task-level checks sum ordered step envelopes.\\n  - Added physical chain timing inference that augments action duration with upstream device "'`response_time` along `connected_to` links (e.g., valve response + cylinder stroke).'"\\n  - Added Chinese timing diagnostics with line numbers and structured "'`约束/分析/结论` output for both timing violation classes.'"\\n  - Added four unit tests covering pass/fail cases for "'`must_complete_within` and `must_start_after`.'"\\n- Files changed\\n  - "'`src/verification/mod.rs`, `src/verification/timing.rs`, `prd.json`, `progress.txt`'"\\n- **Learnings for future iterations:**\\n  - Patterns discovered (e.g., \\\"this codebase uses X for Y\\\")\\n    - "'`must_start_after` is most robust when computed from inbound `StateMachine` transitions to the scoped task/step, using guard-implied minimum delay rather than AST-only heuristics.'"\\n  - Gotchas encountered (e.g., \\\"do not forget to update Z when changing W\\\")\\n    - Timing scope diagnostics need AST line metadata from "'`program.constraints.timing[index].line`; IR `TimingRule` currently does not carry source line numbers.'"\\n  - Useful context (e.g., \\\"the evaluation panel is in component X\\\")\\n    - Timing verifier APIs currently accept both semantic IR and the original AST program so error reports can preserve source-location precision.\\n---\\n\"
text += entry
path.write_text(text)
PY" in /mnt/e/personal_project/rust_plc succeeded in 51ms:

file update:
diff --git a/src/verification/mod.rs b/src/verification/mod.rs
index 210f379c1e732ffff36ac3222eb51055c809581d..f6ab36aa410316b9e4d4170d094e9ae2085fcbf0
--- a/src/verification/mod.rs
+++ b/src/verification/mod.rs
@@ -1 +1,2 @@
 pub mod causality;
+pub mod timing;


thinking
**Verifying progress file integrity**
exec
/bin/bash -lc "sed -n '1,40p' progress.txt" in /mnt/e/personal_project/rust_plc succeeded in 51ms:
# Ralph Progress Log
## Codebase Patterns
- For timing envelopes, include upstream `response_time` along `connected_to` chains and treat incoming `StateMachine` guards as must_start_after lower bounds (`timeout` contributes delay, `always/condition` = 0ms).
- TopologyGraph JSON 调试依赖 `petgraph` 的 `serde-1` feature；若缺失会导致 DiGraph 无法序列化。
- In parser-to-AST lowering, unwrap wrapper PEG rules (e.g., `constraint_declaration`, `step_statement`) before matching concrete rule kinds, or valid nodes can be silently skipped.
- Keep public module declarations centralized in `src/lib.rs`; implementation files live at `src/<module>/mod.rs`.
- For early story scaffolding, keep module placeholders compiling so CLI and library can evolve incrementally without breaking builds.
- Model DSL enums with `serde(rename_all = "snake_case")` and tagged enums so serialized AST tokens stay aligned with DSL keywords.
- In pest grammars, define silent `WHITESPACE` and `COMMENT` rules so inline `#` comments and multiline section formatting parse without extra boilerplate.
- For block-style DSL sections, parse optional `reason: "..."` clauses directly in each declaration rule so indented multiline annotations remain valid without separate line handling.
- In nested `parallel`/`race` grammar, require branch bodies to consume concrete statements so step-level directives are not misparsed as branch labels.
- In semantic topology lowering, treat `connected_to` as upstream linkage (`target -> current`) so causality traversals follow physical flow direction.
- Preserve directive line metadata in AST (e.g., `GotoDirective.line`, `TaskDeclaration.on_complete_line`) so semantic passes can report precise line-numbered errors without reparsing source text.
- For constraint semantic validation, seed known device states from device-type defaults plus `sensor.detects` references before checking `safety` state expressions.
- Use `PlcError` constructors (`undefined_reference` / `type_mismatch` / `duplicate_definition`) so diagnostics share unified ERROR blocks with `位置/原因/建议` fields.
- For end-to-end compilation paths (CLI/tests), run all four semantic builders and aggregate their errors so users get complete diagnostics in one run.
- For causality verification, augment TopologyGraph with logical edges from `detects.device -> sensor` before running reachability, otherwise output-to-sensor chains may appear disconnected.
Started: Wed Feb 11 01:14:39 CST 2026
---
## [2026-02-11 01:19:50 CST] - US-001
file update:
diff --git a/src/verification/mod.rs b/src/verification/mod.rs
index 210f379c1e732ffff36ac3222eb51055c809581d..f6ab36aa410316b9e4d4170d094e9ae2085fcbf0
--- a/src/verification/mod.rs
+++ b/src/verification/mod.rs
@@ -1 +1,2 @@
 pub mod causality;
+pub mod timing;

exec
/bin/bash -lc 'tail -n 80 progress.txt' in /mnt/e/personal_project/rust_plc succeeded in 51ms:
  - Patterns discovered (e.g., "this codebase uses X for Y")
    - Constraint validation is most stable when state legality is inferred from both device-type defaults and topology `detects` declarations.
  - Gotchas encountered (e.g., "do not forget to update Z when changing W")
    - If semantic errors must report constraint line numbers, parser must persist line metadata on each constraint AST node (not only on tasks/topology).
  - Useful context (e.g., "the evaluation panel is in component X")
    - `TimingModel` extraction now recursively traverses `parallel`/`race` branch statements, so action timing coverage is no longer limited to top-level step statements.
---
## [2026-02-11 10:02:12 CST] - US-011
Thread: https://ampcode.com/threads/$AMP_CURRENT_THREAD_ID
- What was implemented
  - Rebuilt `src/error/mod.rs` into a unified error-reporting system with `PlcError` variants covering `ParseError` / `SemanticError` / `UndefinedReference` / `TypeMismatch` / `DuplicateDefinition`.
  - Added structured source location (`file`, `line`, `column`) and optional `reason` fields to every error variant, plus helper constructors for consistent creation.
  - Implemented custom `Display` output in Chinese using a consistent multiline format (`ERROR [code]` + `位置` + `原因` + optional `建议`) aligned with PRD error-reporting goals.
  - Updated parser parse-failure mapping to capture both line and column from pest parse errors, and updated semantic checks to emit typed `UndefinedReference` / `TypeMismatch` / `DuplicateDefinition` errors where appropriate.
  - Added unit tests that verify formatted ParseError content (line/Chinese text) and UndefinedReference content (missing device name + suggestion).
- Files changed
  - `src/error/mod.rs`, `src/parser/mod.rs`, `src/semantic/mod.rs`, `prd.json`, `progress.txt`, `.ralph_logs/iter_10.log`, `.ralph_logs/iter_11.log`
- **Learnings for future iterations:**
  - Patterns discovered (e.g., "this codebase uses X for Y")
    - Prefer `PlcError` typed constructors over ad-hoc semantic strings so all diagnostics share one output contract and future verifier stages can plug in directly.
file update:
diff --git a/src/verification/mod.rs b/src/verification/mod.rs
index 210f379c1e732ffff36ac3222eb51055c809581d..f6ab36aa410316b9e4d4170d094e9ae2085fcbf0
--- a/src/verification/mod.rs
+++ b/src/verification/mod.rs
@@ -1 +1,2 @@
 pub mod causality;
+pub mod timing;


thinking
**Checking for unstaged changes**
exec
/bin/bash -lc 'git status -sb' in /mnt/e/personal_project/rust_plc succeeded in 78ms:
## ralph/phase1-2-parser-and-verification
 M .ralph_logs/iter_14.log
 M prd.json
 M progress.txt
 M src/verification/mod.rs
?? .ralph_logs/iter_15.log
?? src/verification/timing.rs
file update:
diff --git a/src/verification/mod.rs b/src/verification/mod.rs
index 210f379c1e732ffff36ac3222eb51055c809581d..f6ab36aa410316b9e4d4170d094e9ae2085fcbf0
--- a/src/verification/mod.rs
+++ b/src/verification/mod.rs
@@ -1 +1,2 @@
 pub mod causality;
+pub mod timing;


thinking
**Verifying formatting-induced diffs**
exec
/bin/bash -lc "git diff -- src/verification/mod.rs src/verification/timing.rs | sed -n '1,220p'" in /mnt/e/personal_project/rust_plc succeeded in 51ms:
diff --git a/src/verification/mod.rs b/src/verification/mod.rs
index 210f379..f6ab36a 100644
--- a/src/verification/mod.rs
+++ b/src/verification/mod.rs
@@ -1 +1,2 @@
 pub mod causality;
+pub mod timing;
file update:
diff --git a/src/verification/mod.rs b/src/verification/mod.rs
index 210f379c1e732ffff36ac3222eb51055c809581d..f6ab36aa410316b9e4d4170d094e9ae2085fcbf0
--- a/src/verification/mod.rs
+++ b/src/verification/mod.rs
@@ -1 +1,2 @@
 pub mod causality;
+pub mod timing;

exec
/bin/bash -lc "git diff -- src/verification/timing.rs | sed -n '1,260p'" in /mnt/e/personal_project/rust_plc succeeded in 50ms:

file update:
diff --git a/src/verification/mod.rs b/src/verification/mod.rs
index 210f379c1e732ffff36ac3222eb51055c809581d..f6ab36aa410316b9e4d4170d094e9ae2085fcbf0
--- a/src/verification/mod.rs
+++ b/src/verification/mod.rs
@@ -1 +1,2 @@
 pub mod causality;
+pub mod timing;


thinking
**Checking production diff size**
exec
/bin/bash -lc "git diff -- prd.json | sed -n '1,200p'" in /mnt/e/personal_project/rust_plc succeeded in 50ms:
diff --git a/prd.json b/prd.json
index c6a60cc..cfdaea7 100644
--- a/prd.json
+++ b/prd.json
@@ -260,7 +260,7 @@
         "类型检查通过"
       ],
       "priority": 14,
-      "passes": false,
+      "passes": true,
       "notes": ""
     },
     {
file update:
diff --git a/src/verification/mod.rs b/src/verification/mod.rs
index 210f379c1e732ffff36ac3222eb51055c809581d..f6ab36aa410316b9e4d4170d094e9ae2085fcbf0
--- a/src/verification/mod.rs
+++ b/src/verification/mod.rs
@@ -1 +1,2 @@
 pub mod causality;
+pub mod timing;


thinking
**Checking minimal diff pattern**
exec
/bin/bash -lc "git diff -- progress.txt | sed -n '1,260p'" in /mnt/e/personal_project/rust_plc succeeded in 51ms:
diff --git a/progress.txt b/progress.txt
index 303dce0..312e0b2 100644
--- a/progress.txt
+++ b/progress.txt
@@ -1,5 +1,6 @@
 # Ralph Progress Log
 ## Codebase Patterns
+- For timing envelopes, include upstream `response_time` along `connected_to` chains and treat incoming `StateMachine` guards as must_start_after lower bounds (`timeout` contributes delay, `always/condition` = 0ms).
 - TopologyGraph JSON 调试依赖 `petgraph` 的 `serde-1` feature；若缺失会导致 DiGraph 无法序列化。
 - In parser-to-AST lowering, unwrap wrapper PEG rules (e.g., `constraint_declaration`, `step_statement`) before matching concrete rule kinds, or valid nodes can be silently skipped.
 - Keep public module declarations centralized in `src/lib.rs`; implementation files live at `src/<module>/mod.rs`.
@@ -239,3 +240,22 @@ Thread: https://ampcode.com/threads/$AMP_CURRENT_THREAD_ID
   - Useful context (e.g., "the evaluation panel is in component X")
     - `verify_causality` accepts both AST (`PlcProgram`) and IR (`TopologyGraph`/`ConstraintSet`) so future verifier orchestrators can reuse semantic outputs while preserving source-line context.
 ---
+
+## [2026-02-11 12:17:38 CST] - US-014
+Thread: https://ampcode.com/threads/$AMP_CURRENT_THREAD_ID
+- What was implemented
+  - Added `src/verification/timing.rs` with `verify_timing` to validate `must_complete_within` and `must_start_after` timing rules against topology/constraints/state machine IR.
file update:
diff --git a/src/verification/mod.rs b/src/verification/mod.rs
index 210f379c1e732ffff36ac3222eb51055c809581d..f6ab36aa410316b9e4d4170d094e9ae2085fcbf0
--- a/src/verification/mod.rs
+++ b/src/verification/mod.rs
@@ -1 +1,2 @@
 pub mod causality;
+pub mod timing;


thinking
**Committing all changes with precise message**
exec
/bin/bash -lc 'git add -A && git commit -m "feat: [US-014] - [实现时序检查器（Timing Checker）]"' in /mnt/e/personal_project/rust_plc succeeded in 936ms:
[ralph/phase1-2-parser-and-verification 6024959] feat: [US-014] - [实现时序检查器（Timing Checker）]
 6 files changed, 3214 insertions(+), 4 deletions(-)
 create mode 100644 .ralph_logs/iter_15.log
 create mode 100644 src/verification/timing.rs
file update:
diff --git a/src/verification/mod.rs b/src/verification/mod.rs
index 210f379c1e732ffff36ac3222eb51055c809581d..f6ab36aa410316b9e4d4170d094e9ae2085fcbf0
--- a/src/verification/mod.rs
+++ b/src/verification/mod.rs
@@ -1 +1,2 @@
 pub mod causality;
+pub mod timing;


thinking
**Verifying commit file changes**
exec
/bin/bash -lc 'git status -sb' in /mnt/e/personal_project/rust_plc succeeded in 91ms:
## ralph/phase1-2-parser-and-verification
 M .ralph_logs/iter_15.log
file update:
diff --git a/src/verification/mod.rs b/src/verification/mod.rs
index 210f379c1e732ffff36ac3222eb51055c809581d..f6ab36aa410316b9e4d4170d094e9ae2085fcbf0
--- a/src/verification/mod.rs
+++ b/src/verification/mod.rs
@@ -1 +1,2 @@
 pub mod causality;
+pub mod timing;


thinking
**Inspecting post-commit changes**
exec
/bin/bash -lc "git diff -- .ralph_logs/iter_15.log | sed -n '1,120p'" in /mnt/e/personal_project/rust_plc succeeded in 51ms:
diff --git a/.ralph_logs/iter_15.log b/.ralph_logs/iter_15.log
index 6ab928c..8bafac1 100644
--- a/.ralph_logs/iter_15.log
+++ b/.ralph_logs/iter_15.log
@@ -2473,4 +2473,36 @@ index 210f379c1e732ffff36ac3222eb51055c809581d..f6ab36aa410316b9e4d4170d094e9ae2
 thinking
 **Committing all changes with precise message**
 exec
-/bin/bash -lc 'git add -A && git commit -m "feat: [US-014] - [实现时序检查器（Timing Checker）]"' in /mnt/e/personal_project/rust_plc
\ No newline at end of file
+/bin/bash -lc 'git add -A && git commit -m "feat: [US-014] - [实现时序检查器（Timing Checker）]"' in /mnt/e/personal_project/rust_plc succeeded in 936ms:
+[ralph/phase1-2-parser-and-verification 6024959] feat: [US-014] - [实现时序检查器（Timing Checker）]
+ 6 files changed, 3214 insertions(+), 4 deletions(-)
+ create mode 100644 .ralph_logs/iter_15.log
+ create mode 100644 src/verification/timing.rs
+file update:
+diff --git a/src/verification/mod.rs b/src/verification/mod.rs
+index 210f379c1e732ffff36ac3222eb51055c809581d..f6ab36aa410316b9e4d4170d094e9ae2085fcbf0
+--- a/src/verification/mod.rs
++++ b/src/verification/mod.rs
file update:
diff --git a/src/verification/mod.rs b/src/verification/mod.rs
index 210f379c1e732ffff36ac3222eb51055c809581d..f6ab36aa410316b9e4d4170d094e9ae2085fcbf0
--- a/src/verification/mod.rs
+++ b/src/verification/mod.rs
@@ -1 +1,2 @@
 pub mod causality;
+pub mod timing;


thinking
**Finalizing commits amid auto-updating logs**
exec
/bin/bash -lc 'git add -A && git commit --amend --no-edit' in /mnt/e/personal_project/rust_plc